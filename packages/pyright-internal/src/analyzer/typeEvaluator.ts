/*
 * typeEvaluator.ts
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * Author: Eric Traut
 *
 * Module that evaluates types of parse tree nodes within
 * a program.
 *
 * Note: This is a gargantuan module - much larger than I would
 * normally create. It is written this way primarily for performance,
 * with the internal methods having access to the full closure of
 * the createTypeEvaluator function. This is the same approach
 * taken by the TypeScript compiler.
 */

import { CancellationToken } from 'vscode-languageserver';

import { Commands } from '../commands/commands';
import { throwIfCancellationRequested } from '../common/cancellationUtils';
import { appendArray } from '../common/collectionUtils';
import { DiagnosticLevel } from '../common/configOptions';
import { ConsoleInterface } from '../common/console';
import { assert, assertNever, fail } from '../common/debug';
import { AddMissingOptionalToParamAction, DiagnosticAddendum } from '../common/diagnostic';
import { DiagnosticRule } from '../common/diagnosticRules';
import { convertOffsetsToRange, convertOffsetToPosition } from '../common/positionUtils';
import { PythonVersion } from '../common/pythonVersion';
import { TextRange } from '../common/textRange';
import { Localizer } from '../localization/localize';
import {
    ArgumentCategory,
    AssignmentNode,
    AugmentedAssignmentNode,
    AwaitNode,
    BinaryOperationNode,
    CallNode,
    CaseNode,
    ClassNode,
    ConstantNode,
    DecoratorNode,
    DictionaryNode,
    ExceptNode,
    ExpressionNode,
    FormatStringNode,
    ForNode,
    FunctionNode,
    ImportAsNode,
    ImportFromAsNode,
    ImportFromNode,
    IndexNode,
    isExpressionNode,
    LambdaNode,
    ListComprehensionForIfNode,
    ListComprehensionNode,
    ListNode,
    MatchNode,
    MemberAccessNode,
    NameNode,
    NumberNode,
    ParameterCategory,
    ParameterNode,
    ParseNode,
    ParseNodeType,
    RaiseNode,
    SetNode,
    SliceNode,
    StringListNode,
    StringNode,
    TernaryNode,
    TupleNode,
    TypeAliasNode,
    TypeAnnotationNode,
    TypeParameterCategory,
    TypeParameterListNode,
    UnaryOperationNode,
    UnpackNode,
    WithItemNode,
    YieldFromNode,
    YieldNode,
} from '../parser/parseNodes';
import { ParseOptions, Parser } from '../parser/parser';
import { KeywordType, OperatorType, StringTokenFlags } from '../parser/tokenizerTypes';
import * as DeclarationUtils from './aliasDeclarationUtils';
import { AnalyzerFileInfo, ImportLookup, isAnnotationEvaluationPostponed } from './analyzerFileInfo';
import * as AnalyzerNodeInfo from './analyzerNodeInfo';
import { CodeFlowAnalyzer, FlowNodeTypeOptions, FlowNodeTypeResult, getCodeFlowEngine } from './codeFlowEngine';
import {
    CodeFlowReferenceExpressionNode,
    createKeyForReference,
    FlowNode,
    isCodeFlowSupportedForReference,
    wildcardImportReferenceKey,
} from './codeFlowTypes';
import { assignTypeToTypeVar, populateTypeVarContextBasedOnExpectedType } from './constraintSolver';
import { applyConstructorTransform } from './constructorTransform';
import {
    applyDataClassClassBehaviorOverrides,
    applyDataClassDecorator,
    applyDataClassDefaultBehaviors,
    getDataclassDecoratorBehaviors,
    synthesizeDataClassMethods,
    validateDataClassTransformDecorator,
} from './dataClasses';
import {
    ClassDeclaration,
    Declaration,
    DeclarationType,
    FunctionDeclaration,
    ModuleLoaderActions,
} from './declaration';
import {
    createSynthesizedAliasDeclaration,
    getDeclarationsWithUsesLocalNameRemoved,
    getNameNodeForDeclaration,
    isExplicitTypeAliasDeclaration,
    isFinalVariableDeclaration,
    isLegalTypeAliasExpressionForm,
    isPossibleTypeAliasDeclaration,
} from './declarationUtils';
import {
    createEnumType,
    getEnumAutoValueType,
    getTypeOfEnumMember,
    isDeclInEnumClass,
    isKnownEnumType,
    transformTypeForPossibleEnumClass,
} from './enums';
import { applyFunctionTransform } from './functionTransform';
import { createNamedTupleType } from './namedTuples';
import * as ParseTreeUtils from './parseTreeUtils';
import { assignTypeToPatternTargets, narrowTypeBasedOnPattern } from './patternMatching';
import {
    assignProperty,
    clonePropertyWithDeleter,
    clonePropertyWithSetter,
    createProperty,
    validatePropertyMethod,
} from './properties';
import { assignClassToProtocol, assignModuleToProtocol } from './protocols';
import { Scope, ScopeType, SymbolWithScope } from './scope';
import * as ScopeUtils from './scopeUtils';
import { evaluateStaticBoolExpression } from './staticExpressions';
import { indeterminateSymbolId, Symbol, SymbolFlags } from './symbol';
import { isConstantName, isPrivateName, isPrivateOrProtectedName } from './symbolNameUtils';
import { getLastTypedDeclaredForSymbol, isFinalVariable } from './symbolUtils';
import { CachedType, isIncompleteType, SpeculativeTypeTracker, TypeCache } from './typeCache';
import {
    assignToTypedDict,
    assignTypedDictToTypedDict as assignTypedDictToTypedDict,
    createTypedDictType,
    getTypedDictMembersForClass,
    getTypeOfIndexedTypedDict,
    synthesizeTypedDictClassMethods,
} from './typedDicts';
import {
    AbstractMethod,
    AnnotationTypeOptions,
    CallResult,
    CallSignature,
    CallSignatureInfo,
    ClassTypeResult,
    EffectiveTypeResult,
    EvaluatorFlags,
    EvaluatorUsage,
    ExpectedTypeOptions,
    ExpectedTypeResult,
    FunctionArgument,
    FunctionTypeResult,
    maxSubtypesForInferredType,
    PrintTypeOptions,
    TypeEvaluator,
    TypeResult,
    TypeResultWithNode,
    ValidateArgTypeParams,
} from './typeEvaluatorTypes';
import * as TypePrinter from './typePrinter';
import {
    AnyType,
    ClassType,
    ClassTypeFlags,
    combineTypes,
    DataClassBehaviors,
    findSubtype,
    FunctionParameter,
    FunctionType,
    FunctionTypeFlags,
    InheritanceChain,
    isAny,
    isAnyOrUnknown,
    isClass,
    isClassInstance,
    isFunction,
    isInstantiableClass,
    isModule,
    isNever,
    isNoneInstance,
    isNoneTypeClass,
    isOverloadedFunction,
    isParamSpec,
    isTypeSame,
    isTypeVar,
    isUnbound,
    isUnion,
    isUnknown,
    isUnpacked,
    isUnpackedClass,
    isUnpackedVariadicTypeVar,
    isVariadicTypeVar,
    LiteralValue,
    maxTypeRecursionCount,
    ModuleType,
    NeverType,
    NoneType,
    OverloadedFunctionType,
    ParamSpecEntry,
    removeFromUnion,
    removeNoneFromUnion,
    removeUnbound,
    TupleTypeArgument,
    Type,
    TypeBase,
    TypeCategory,
    TypeCondition,
    TypedDictEntry,
    TypeVarScopeId,
    TypeVarScopeType,
    TypeVarType,
    UnboundType,
    UnionType,
    UnknownType,
    Variance,
    WildcardTypeVarScopeId,
} from './types';
import {
    addConditionToType,
    addTypeVarsToListIfUnique,
    applySolvedTypeVars,
    areTypesSame,
    AssignTypeFlags,
    buildTypeVarContext,
    buildTypeVarContextFromSpecializedClass,
    ClassMember,
    ClassMemberLookupFlags,
    combineSameSizedTuples,
    computeMroLinearization,
    containsLiteralType,
    containsUnknown,
    convertParamSpecValueToType,
    convertToInstance,
    convertToInstantiable,
    derivesFromClassRecursive,
    doForEachSubtype,
    explodeGenericClass,
    getDeclaredGeneratorReturnType,
    getGeneratorTypeArgs,
    getLiteralTypeClassName,
    getParameterListDetails,
    getSpecializedTupleType,
    getTypeCondition,
    getTypeVarArgumentsRecursive,
    getTypeVarScopeId,
    getUnionSubtypeCount,
    isEllipsisType,
    isIncompleteUnknown,
    isLiteralType,
    isMaybeDescriptorInstance,
    isOptionalType,
    isPartlyUnknown,
    isProperty,
    isTupleClass,
    isTypeAliasPlaceholder,
    isTypeAliasRecursive,
    isUnboundedTupleClass,
    isUnionableType,
    isVarianceOfTypeArgumentCompatible,
    lookUpClassMember,
    lookUpObjectMember,
    mapSubtypes,
    ParameterListDetails,
    ParameterSource,
    partiallySpecializeType,
    preserveUnknown,
    removeParamSpecVariadicsFromFunction,
    removeParamSpecVariadicsFromSignature,
    requiresSpecialization,
    requiresTypeArguments,
    setTypeArgumentsRecursive,
    sortTypes,
    specializeClassType,
    specializeForBaseClass,
    specializeTupleClass,
    synthesizeTypeVarForSelfCls,
    transformPossibleRecursiveTypeAlias,
    VirtualParameterDetails,
} from './typeUtils';
import { TypeVarContext } from './typeVarContext';

const enum MemberAccessFlags {
    None = 0,

    // By default, member accesses are assumed to access the attributes
    // of a class instance. By setting this flag, only attributes of
    // the class are considered.
    AccessClassMembersOnly = 1 << 0,

    // By default, members of base classes are also searched.
    // Set this flag to consider only the specified class' members.
    SkipBaseClasses = 1 << 1,

    // Do not include the "object" base class in the search.
    SkipObjectBaseClass = 1 << 2,

    // Consider writes to symbols flagged as ClassVars as an error.
    DisallowClassVarWrites = 1 << 3,

    // Normally __new__ is treated as a static method, but when
    // it is invoked implicitly through a constructor call, it
    // acts like a class method instead.
    TreatConstructorAsClassMethod = 1 << 4,

    // By default, class member lookups start with the class itself
    // and fall back on the metaclass if it's not found. This option
    // skips the first check.
    ConsiderMetaclassOnly = 1 << 5,

    // If an attribute cannot be found when looking for instance
    // members, normally an attribute access override method
    // (__getattr__, etc.) may provide the missing attribute type.
    // This disables this check.
    SkipAttributeAccessOverride = 1 << 6,

    // Do not include the class itself, only base classes.
    SkipOriginalClass = 1 << 7,

    // Do not include the "type" base class in the search.
    SkipTypeBaseClass = 1 << 8,
}

interface ValidateTypeArgsOptions {
    allowEmptyTuple?: boolean;
    allowVariadicTypeVar?: boolean;
    allowParamSpec?: boolean;
    allowTypeArgList?: boolean;
    allowUnpackedTuples?: boolean;
}

interface MatchArgsToParamsResult {
    overload: FunctionType;
    overloadIndex: number;

    argumentErrors: boolean;
    isTypeIncomplete: boolean;
    argParams: ValidateArgTypeParams[];
    activeParam?: FunctionParameter | undefined;
    paramSpecTarget?: TypeVarType | undefined;
    paramSpecArgList?: FunctionArgument[] | undefined;

    // A higher relevance means that it should be considered
    // first, before lower relevance overloads.
    relevance: number;
}

interface ArgResult {
    isCompatible: boolean;
    argType: Type;
    isTypeIncomplete?: boolean | undefined;
    condition?: TypeCondition[];
    skippedOverloadArg?: boolean;
}

interface ClassMemberLookup {
    symbol: Symbol | undefined;

    // Type of symbol.
    type: Type;
    isTypeIncomplete: boolean;

    // True if class member, false otherwise.
    isClassMember: boolean;

    // The class that declares the accessed member.
    classType?: ClassType | UnknownType;

    // True if the member is explicitly declared as ClassVar
    // within a Protocol.
    isClassVar: boolean;

    // Is member a descriptor object that is asymmetric with respect
    // to __get__ and __set__ types?
    isAsymmetricDescriptor: boolean;
}

export interface DescriptorTypeResult {
    type: Type;
    isAsymmetricDescriptor: boolean;
}

interface AliasMapEntry {
    alias: string;
    module: 'builtins' | 'collections' | 'self';
}

interface ParamAssignmentInfo {
    argsNeeded: number;
    argsReceived: number;
    isPositionalOnly: boolean;
}

// Maps binary operators to the magic methods that implement them.
const binaryOperatorMap: { [operator: number]: [string, string] } = {
    [OperatorType.Add]: ['__add__', '__radd__'],
    [OperatorType.Subtract]: ['__sub__', '__rsub__'],
    [OperatorType.Multiply]: ['__mul__', '__rmul__'],
    [OperatorType.FloorDivide]: ['__floordiv__', '__rfloordiv__'],
    [OperatorType.Divide]: ['__truediv__', '__rtruediv__'],
    [OperatorType.Mod]: ['__mod__', '__rmod__'],
    [OperatorType.Power]: ['__pow__', '__rpow__'],
    [OperatorType.MatrixMultiply]: ['__matmul__', '__rmatmul__'],
    [OperatorType.BitwiseAnd]: ['__and__', '__rand__'],
    [OperatorType.BitwiseOr]: ['__or__', '__ror__'],
    [OperatorType.BitwiseXor]: ['__xor__', '__rxor__'],
    [OperatorType.LeftShift]: ['__lshift__', '__rlshift__'],
    [OperatorType.RightShift]: ['__rshift__', '__rrshift__'],
    [OperatorType.Equals]: ['__eq__', '__ne__'],
    [OperatorType.NotEquals]: ['__ne__', '__eq__'],
    [OperatorType.LessThan]: ['__lt__', '__ge__'],
    [OperatorType.LessThanOrEqual]: ['__le__', '__gt__'],
    [OperatorType.GreaterThan]: ['__gt__', '__le__'],
    [OperatorType.GreaterThanOrEqual]: ['__ge__', '__lt__'],
};

// Map of operators that always return a bool result.
const booleanOperatorMap: { [operator: number]: true } = {
    [OperatorType.And]: true,
    [OperatorType.Or]: true,
    [OperatorType.Is]: true,
    [OperatorType.IsNot]: true,
    [OperatorType.In]: true,
    [OperatorType.NotIn]: true,
};

// This table contains the names of several built-in types that
// are not subscriptable at runtime on older versions of Python.
// It lists the first version of Python where subscripting is
// allowed.
const nonSubscriptableBuiltinTypes: Map<string, PythonVersion> = new Map([
    ['asyncio.futures.Future', PythonVersion.V3_9],
    ['asyncio.tasks.Task', PythonVersion.V3_9],
    ['builtins.dict', PythonVersion.V3_9],
    ['builtins.frozenset', PythonVersion.V3_9],
    ['builtins.list', PythonVersion.V3_9],
    ['builtins._PathLike', PythonVersion.V3_9],
    ['builtins.set', PythonVersion.V3_9],
    ['builtins.tuple', PythonVersion.V3_9],
    ['collections.ChainMap', PythonVersion.V3_9],
    ['collections.Counter', PythonVersion.V3_9],
    ['collections.defaultdict', PythonVersion.V3_9],
    ['collections.DefaultDict', PythonVersion.V3_9],
    ['collections.deque', PythonVersion.V3_9],
    ['collections.OrderedDict', PythonVersion.V3_9],
    ['queue.Queue', PythonVersion.V3_9],
]);

// Some types that do not inherit from others are still considered
// "compatible" based on the Python spec. These are sometimes referred
// to as "type promotions".
const typePromotions: Map<string, string[]> = new Map([
    ['builtins.float', ['builtins.int']],
    ['builtins.complex', ['builtins.float', 'builtins.int']],
    ['builtins.bytes', ['builtins.bytearray', 'builtins.memoryview']],
]);

interface SymbolResolutionStackEntry {
    // The symbol ID and declaration being resolved.
    symbolId: number;
    declaration: Declaration;

    // Initially true, it's set to false if a recursion
    // is detected.
    isResultValid: boolean;

    // Some limited forms of recursion are allowed. In these
    // cases, a partially-constructed type can be registered.
    partialType?: Type | undefined;
}

interface ReturnTypeInferenceContext {
    functionNode: FunctionNode;
    codeFlowAnalyzer: CodeFlowAnalyzer;
}

// How many levels deep should we attempt to infer return
// types based on call-site argument types? The deeper we go,
// the more types we may be able to infer, but the worse the
// performance.
const maxReturnTypeInferenceStackSize = 2;

// What is the max number of input arguments we should allow
// for call-site return type inference? We've found that large,
// complex functions with many arguments can take too long to
// analyze.
const maxReturnTypeInferenceArgumentCount = 6;

// What is the max complexity of the code flow graph that
// we will analyze to determine the return type of a function
// when its parameters are unannotated? We want to keep this
// pretty low because this can be very costly.
const maxReturnTypeInferenceCodeFlowComplexity = 32;

// What is the max complexity of the code flow graph for
// call-site type inference? This is very expensive, so we
// want to keep this very low.
const maxReturnCallSiteTypeInferenceCodeFlowComplexity = 8;

// What is the max number of return types cached per function
// when using call-site inference?
const maxCallSiteReturnTypeCacheSize = 8;

// How many entries in a list, set, or dict should we examine
// when inferring the type? We need to cut it off at some point
// to avoid excessive computation.
const maxEntriesToUseForInference = 64;

// How many assignments to an unannotated variable should be used
// when inferring its type? We need to cut it off at some point
// to avoid excessive computation.
const maxDeclarationsToUseForInference = 64;

// Maximum number of times to attempt effective type evaluation
// of a variable that has no type declaration.
const maxEffectiveTypeEvaluationAttempts = 16;

// Maximum number of combinatoric union type expansions allowed
// when resolving an overload.
const maxOverloadUnionExpansionCount = 64;

// Maximum number of recursive function return type inference attempts
// that can be concurrently pending before we give up.
const maxInferFunctionReturnRecursionCount = 12;

// Maximum recursion amount when comparing two recursive type aliases.
// Increasing this can greatly increase the time required to evaluate
// two recursive type aliases that have the same definition. Decreasing
// it can increase the chance of false negatives for such recursive
// type aliases.
const maxRecursiveTypeAliasRecursionCount = 10;

// This switch enables a special debug mode that attempts to catch
// bugs due to inconsistent evaluation flags used when reading types
// from the type cache.
const verifyTypeCacheEvaluatorFlags = false;

// This debugging option prints each expression and its evaluated type.
const printExpressionTypes = false;

// If the number of subtypes starts to explode when applying "literal math",
// cut off the literal union and fall back to the non-literal supertype.
const maxLiteralMathSubtypeCount = 64;

// The following number is chosen somewhat arbitrarily. We need to cut
// off code flow analysis at some point for code flow graphs that are too
// complex. Otherwise we risk overflowing the stack or incurring extremely
// long analysis times. This number has been tuned empirically.
export const maxCodeComplexity = 768;

export interface EvaluatorOptions {
    printTypeFlags: TypePrinter.PrintTypeFlags;
    logCalls: boolean;
    minimumLoggingThreshold: number;
    evaluateUnknownImportsAsAny: boolean;
    verifyTypeCacheEvaluatorFlags: boolean;
}

// Describes a "callback hook" that is called when a class type is
// fully created and the "PartiallyEvaluated" flag has just been cleared.
// This allows us to properly compute information like the MRO which
// depends on a full understanding of base classes.
interface ClassTypeHook {
    dependency: ClassType;
    callback: () => void;
}

export function createTypeEvaluator(importLookup: ImportLookup, evaluatorOptions: EvaluatorOptions): TypeEvaluator {
    return new TypeEvaulatorImpl(importLookup, evaluatorOptions);
}

class TypeEvaulatorImpl implements TypeEvaluator {
    constructor(private _importLookup: ImportLookup, private _evaluatorOptions: EvaluatorOptions) {}

    private _symbolResolutionStack: SymbolResolutionStackEntry[] = [];
    private _typeCacheFlags = new Map<number, EvaluatorFlags>();
    private _asymmetricDescriptorAssignmentCache = new Set<number>();
    private _speculativeTypeTracker = new SpeculativeTypeTracker();
    private _suppressedNodeStack: ParseNode[] = [];

    private _functionRecursionMap = new Set<number>();
    private _codeFlowAnalyzerCache = new Map<number, CodeFlowAnalyzer>();
    private _typeCache: TypeCache = new Map<number, CachedType>();
    private _effectiveTypeCache = new Map<number, Map<string, EffectiveTypeResult>>();
    private _expectedTypeCache = new Map<number, Type>();
    private _classTypeHooks: ClassTypeHook[] = [];
    private _cancellationToken: CancellationToken | undefined;
    private _isBasicTypesInitialized = false;
    private _noneType: Type | undefined;
    private _unionType: Type | undefined;
    private _objectType: Type | undefined;
    private _typeClassType: Type | undefined;
    private _functionObj: Type | undefined;
    private _tupleClassType: Type | undefined;
    private _boolClassType: Type | undefined;
    private _intClassType: Type | undefined;
    private _strClassType: Type | undefined;
    private _dictClassType: Type | undefined;
    private _typedDictClassType: Type | undefined;
    private _incompleteTypeCache: TypeCache | undefined;
    private _printExpressionSpaceCount = 0;
    private _returnTypeInferenceContextStack: ReturnTypeInferenceContext[] = [];
    private _returnTypeInferenceTypeCache: TypeCache | undefined;
    private _codeFlowEngine = getCodeFlowEngine(this, this._speculativeTypeTracker);

    runWithCancellationToken<T>(token: CancellationToken, callback: () => T): T {
        try {
            this._cancellationToken = token;
            return callback();
        } finally {
            this._cancellationToken = undefined;
        }
    }

    checkForCancellation() {
        if (this._cancellationToken) {
            throwIfCancellationRequested(this._cancellationToken);
        }
    }

    getTypeCacheEntryCount(): number {
        return this._typeCache.size;
    }

    // This should be called immediately prior to discarding
    // the type evaluator. It forcibly replacing existing cache maps
    // with empty equivalents. This shouldn't be necessary, but there
    // is apparently a bug in the v8 GC where it is unable to detect
    // circular references in complex data structures, so it fails
    // to clean up the objects if we don't help it out.
    disposeEvaluator() {
        this._functionRecursionMap = new Set<number>();
        this._codeFlowAnalyzerCache = new Map<number, CodeFlowAnalyzer>();
        this._typeCache = new Map<number, CachedType>();
        this._effectiveTypeCache = new Map<number, Map<string, EffectiveTypeResult>>();
        this._expectedTypeCache = new Map<number, Type>();
    }

    isTypeCached(node: ParseNode) {
        let cachedType: CachedType | undefined;

        if (this._returnTypeInferenceTypeCache && this.isNodeInReturnTypeInferenceContext(node)) {
            cachedType = this._returnTypeInferenceTypeCache.get(node.id);
        } else {
            cachedType = this._typeCache.get(node.id);
        }

        return cachedType !== undefined;
    }

    readTypeCache(node: ParseNode, flags: EvaluatorFlags | undefined): Type | undefined {
        let cachedType: CachedType | undefined;

        // Should we use a temporary cache associated with a contextual
        // analysis of a function, contextualized based on call-site argument types?
        if (this._returnTypeInferenceTypeCache && this.isNodeInReturnTypeInferenceContext(node)) {
            cachedType = this._returnTypeInferenceTypeCache.get(node.id);
        } else {
            cachedType = this._typeCache.get(node.id);
        }

        if (cachedType === undefined) {
            return undefined;
        }

        if (this._evaluatorOptions.verifyTypeCacheEvaluatorFlags || verifyTypeCacheEvaluatorFlags) {
            if (flags !== undefined) {
                const expectedFlags = this._typeCacheFlags.get(node.id);

                if (expectedFlags !== undefined && flags !== expectedFlags) {
                    const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
                    const position = convertOffsetToPosition(node.start, fileInfo.lines);

                    const message =
                        `Type cache flag mismatch for node type ${node.nodeType} ` +
                        `(parent ${node.parent?.nodeType ?? 'none'}): ` +
                        `cached flags = ${expectedFlags}, access flags = ${flags}, ` +
                        `file = {${fileInfo.filePath} [${position.line + 1}:${position.character + 1}]}`;
                    if (this._evaluatorOptions.verifyTypeCacheEvaluatorFlags) {
                        fail(message);
                    } else {
                        console.log(message);
                    }
                }
            }
        }

        assert(!isIncompleteType(cachedType));
        return cachedType as Type;
    }

    writeTypeCache(
        node: ParseNode,
        type: Type,
        flags: EvaluatorFlags | undefined,
        isIncomplete: boolean,
        expectedType?: Type,
        allowSpeculativeCaching = false
    ) {
        if (isIncomplete) {
            if (this._incompleteTypeCache) {
                this._incompleteTypeCache.set(node.id, type);
            }
            return;
        }

        // Should we use a temporary cache associated with a contextual
        // analysis of a function, contextualized based on call-site argument types?
        const typeCacheToUse =
            this._returnTypeInferenceTypeCache && this.isNodeInReturnTypeInferenceContext(node)
                ? this._returnTypeInferenceTypeCache
                : this._typeCache;

        typeCacheToUse.set(node.id, type);

        if (this._evaluatorOptions.verifyTypeCacheEvaluatorFlags || verifyTypeCacheEvaluatorFlags) {
            if (typeCacheToUse === this._typeCache && flags !== undefined) {
                this._typeCacheFlags.set(node.id, flags);
            }
        }

        // If the entry is located within a part of the parse tree that is currently being
        // "speculatively" evaluated, track it so we delete the cached entry when we leave
        // this speculative context.
        if (this._speculativeTypeTracker.isSpeculative(node)) {
            this._speculativeTypeTracker.trackEntry(typeCacheToUse, node.id);
            if (allowSpeculativeCaching) {
                this._speculativeTypeTracker.addSpeculativeType(node, type, expectedType);
            }
        }
    }

    deleteTypeCacheEntry(node: ParseNode) {
        const typeCacheToUse =
            this._returnTypeInferenceTypeCache && this.isNodeInReturnTypeInferenceContext(node)
                ? this._returnTypeInferenceTypeCache
                : this._typeCache;

        typeCacheToUse.delete(node.id);
    }

    setTypeForNode(node: ParseNode, type: Type = UnknownType.create(), flags = EvaluatorFlags.None) {
        this.writeTypeCache(node, type, flags, /* isIncomplete */ false);
    }

    setAsymmetricDescriptorAssignment(node: ParseNode) {
        if (this._speculativeTypeTracker.isSpeculative(/* node */ undefined)) {
            return;
        }

        this._asymmetricDescriptorAssignmentCache.add(node.id);
    }

    isAsymmetricDescriptorAssignment(node: ParseNode) {
        return this._asymmetricDescriptorAssignmentCache.has(node.id);
    }

    // Determines whether the specified node is contained within
    // the node corresponding to the function that we
    // are currently analyzing in the context of parameter types
    // defined by a call site.
    isNodeInReturnTypeInferenceContext(node: ParseNode) {
        const stackSize = this._returnTypeInferenceContextStack.length;
        if (stackSize === 0) {
            return false;
        }

        const contextNode = this._returnTypeInferenceContextStack[stackSize - 1];

        let curNode: ParseNode | undefined = node;
        while (curNode) {
            if (curNode === contextNode.functionNode) {
                return true;
            }
            curNode = curNode.parent;
        }

        return false;
    }

    getCodeFlowAnalyzerForReturnTypeInferenceContext() {
        const stackSize = this._returnTypeInferenceContextStack.length;
        assert(stackSize > 0);
        const contextNode = this._returnTypeInferenceContextStack[stackSize - 1];
        return contextNode.codeFlowAnalyzer;
    }

    getIndexOfSymbolResolution(symbol: Symbol, declaration: Declaration) {
        return this._symbolResolutionStack.findIndex(
            (entry) => entry.symbolId === symbol.id && entry.declaration === declaration
        );
    }

    pushSymbolResolution(symbol: Symbol, declaration: Declaration) {
        const index = this.getIndexOfSymbolResolution(symbol, declaration);
        if (index >= 0) {
            // Mark all of the entries between these two as invalid.
            for (let i = index + 1; i < this._symbolResolutionStack.length; i++) {
                this._symbolResolutionStack[i].isResultValid = false;
            }
            return false;
        }

        this._symbolResolutionStack.push({
            symbolId: symbol.id,
            declaration,
            isResultValid: true,
        });
        return true;
    }

    popSymbolResolution(symbol: Symbol) {
        const poppedEntry = this._symbolResolutionStack.pop()!;
        assert(poppedEntry.symbolId === symbol.id);
        return poppedEntry.isResultValid;
    }

    setSymbolResolutionPartialType(symbol: Symbol, declaration: Declaration, type: Type) {
        const index = this.getIndexOfSymbolResolution(symbol, declaration);
        if (index >= 0) {
            this._symbolResolutionStack[index].partialType = type;
        }
    }

    getSymbolResolutionPartialType(symbol: Symbol, declaration: Declaration): Type | undefined {
        const index = this.getIndexOfSymbolResolution(symbol, declaration);
        if (index >= 0) {
            return this._symbolResolutionStack[index].partialType;
        }

        return undefined;
    }

    // Determines the type of the specified node by evaluating it in
    // context, logging any errors in the process. This may require the
    // type of surrounding statements to be evaluated.
    getType(node: ExpressionNode): Type | undefined {
        return this.evaluateTypeForSubnode(node, () => {
            this.evaluateTypesForExpressionInContext(node);
        })?.type;
    }

    // Reads the type of the node from the cache.
    getCachedType(node: ExpressionNode): Type | undefined {
        return this.readTypeCache(node, EvaluatorFlags.None);
    }

    // Determines the expected type of a specified node based on surrounding
    // context. For example, if it's a subexpression of an argument expression,
    // the associated parameter type might inform the expected type.
    getExpectedType(node: ExpressionNode): ExpectedTypeResult | undefined {
        // Scan up the parse tree to find the top-most expression node
        // so we can evaluate the entire expression.
        let topExpression = node;
        let curNode: ParseNode | undefined = node;
        while (curNode) {
            if (isExpressionNode(curNode)) {
                topExpression = curNode;
            }

            curNode = curNode.parent;
        }

        // Evaluate the expression. This will have the side effect of
        // storing an expected type in the expected type cache.
        this.evaluateTypesForExpressionInContext(topExpression);

        // Look for the resulting expected type by scanning up the parse tree.
        curNode = node;
        while (curNode) {
            const expectedType = this._expectedTypeCache.get(curNode.id);
            if (expectedType) {
                return {
                    type: expectedType,
                    node: curNode,
                };
            }

            if (curNode === topExpression) {
                break;
            }

            curNode = curNode.parent;
        }

        return undefined;
    }

    initializedBasicTypes(node: ParseNode) {
        if (!this._isBasicTypesInitialized) {
            // Some of these types have cyclical dependencies on each other,
            // so don't re-enter this block once we start executing it.
            this._isBasicTypesInitialized = true;

            this._objectType = this.getBuiltInObject(node, 'object');
            this._typeClassType = this.getBuiltInType(node, 'type');
            this._functionObj = this.getBuiltInObject(node, 'function');

            // Initialize and cache "Collection" to break a cyclical dependency
            // that occurs when resolving tuple below.
            this.getTypingType(node, 'Collection');

            this._noneType = this.getTypeshedType(node, 'NoneType') || AnyType.create();
            this._tupleClassType = this.getBuiltInType(node, 'tuple');
            this._boolClassType = this.getBuiltInType(node, 'bool');
            this._intClassType = this.getBuiltInType(node, 'int');
            this._strClassType = this.getBuiltInType(node, 'str');
            this._dictClassType = this.getBuiltInType(node, 'dict');
            this._typedDictClassType = this.getTypingType(node, '_TypedDict');
        }
    }

    getTypeOfExpression(node: ExpressionNode, flags = EvaluatorFlags.None, expectedType?: Type): TypeResult {
        // Is this type already cached?
        const cachedType = this.readTypeCache(node, flags);
        if (cachedType) {
            if (printExpressionTypes) {
                console.log(
                    `${this.getPrintExpressionTypesSpaces()}${ParseTreeUtils.printExpression(node)} (${this.getLineNum(
                        node
                    )}): Cached ${this.printType(cachedType)}`
                );
            }
            return { type: cachedType };
        } else {
            // Is it cached in the speculative type cache?
            const speculativeCachedType = this._speculativeTypeTracker.getSpeculativeType(node, expectedType);
            if (speculativeCachedType) {
                if (printExpressionTypes) {
                    console.log(
                        `${this.getPrintExpressionTypesSpaces()}${ParseTreeUtils.printExpression(
                            node
                        )} (${this.getLineNum(node)}): Speculative ${this.printType(speculativeCachedType)}`
                    );
                }
                return { type: speculativeCachedType };
            }
        }

        if (printExpressionTypes) {
            console.log(
                `${this.getPrintExpressionTypesSpaces()}${ParseTreeUtils.printExpression(node)} (${this.getLineNum(
                    node
                )}): Pre`
            );
            this._printExpressionSpaceCount++;
        }

        // This is a frequently-called routine, so it's a good place to call
        // the cancellation check. If the operation is canceled, an exception
        // will be thrown at this point.
        this.checkForCancellation();

        expectedType = transformPossibleRecursiveTypeAlias(expectedType);

        // If we haven't already fetched some core type definitions from the
        // typeshed stubs, do so here. It would be better to fetch this when it's
        // needed in assignType, but we don't have access to the parse tree
        // at that point.
        this.initializedBasicTypes(node);

        let typeResult: TypeResult | undefined;
        let reportExpectingTypeErrors = (flags & EvaluatorFlags.ExpectingType) !== 0;

        switch (node.nodeType) {
            case ParseNodeType.Name: {
                typeResult = this.getTypeOfName(node, flags);
                break;
            }

            case ParseNodeType.MemberAccess: {
                typeResult = this.getTypeOfMemberAccess(node, flags);
                break;
            }

            case ParseNodeType.Index: {
                typeResult = this.getTypeOfIndex(node, flags);
                break;
            }

            case ParseNodeType.Call: {
                typeResult = this.getTypeOfCall(node, expectedType, flags);
                break;
            }

            case ParseNodeType.Tuple: {
                typeResult = this.getTypeOfTuple(node, expectedType, flags);
                break;
            }

            case ParseNodeType.Constant: {
                typeResult = this.getTypeOfConstant(node, flags);
                break;
            }

            case ParseNodeType.StringList: {
                const isExpectingType =
                    (flags & EvaluatorFlags.EvaluateStringLiteralAsType) !== 0 && !this.isAnnotationLiteralValue(node);

                if (isExpectingType) {
                    // Don't report expecting type errors again. We will have already
                    // reported them when analyzing the contents of the string.
                    reportExpectingTypeErrors = false;
                }

                typeResult = this.getTypeOfStringList(node, flags, isExpectingType);
                break;
            }

            case ParseNodeType.Number: {
                typeResult = this.getTypeOfNumber(node, typeResult);
                break;
            }

            case ParseNodeType.Ellipsis: {
                typeResult = this.getTypeOfEllipsis(flags, typeResult, node);
                break;
            }

            case ParseNodeType.UnaryOperation: {
                typeResult = this.getTypeOfUnaryOperation(node, expectedType);
                break;
            }

            case ParseNodeType.BinaryOperation: {
                typeResult = this.getTypeOfBinaryOperation(node, expectedType, flags);
                break;
            }

            case ParseNodeType.AugmentedAssignment: {
                typeResult = this.getTypeOfAugmentedAssignment(node, expectedType);
                break;
            }

            case ParseNodeType.List:
            case ParseNodeType.Set: {
                typeResult = this.getTypeOfListOrSet(node, expectedType);
                break;
            }

            case ParseNodeType.Slice: {
                typeResult = this.getTypeOfSlice(node);
                break;
            }

            case ParseNodeType.Await: {
                typeResult = this.getTypeOfAwaitOperator(node, flags, expectedType);
                break;
            }

            case ParseNodeType.Ternary: {
                typeResult = this.getTypeOfTernary(node, flags, expectedType);
                break;
            }

            case ParseNodeType.ListComprehension: {
                typeResult = this.getTypeOfListComprehension(node, expectedType);
                break;
            }

            case ParseNodeType.Dictionary: {
                typeResult = this.getTypeOfDictionary(node, expectedType);
                break;
            }

            case ParseNodeType.Lambda: {
                typeResult = this.getTypeOfLambda(node, expectedType);
                break;
            }

            case ParseNodeType.Assignment: {
                typeResult = this.getTypeOfExpression(node.rightExpression);
                this.assignTypeToExpression(
                    node.leftExpression,
                    typeResult.type,
                    /* isTypeIncomplete */ false,
                    node.rightExpression,
                    /* ignoreEmptyContainers */ true,
                    /* allowAssignmentToFinalVar */ true
                );
                break;
            }

            case ParseNodeType.AssignmentExpression: {
                typeResult = this.getTypeOfExpression(node.rightExpression);
                this.assignTypeToExpression(
                    node.name,
                    typeResult.type,
                    /* isTypeIncomplete */ false,
                    node.rightExpression,
                    /* ignoreEmptyContainers */ true
                );
                break;
            }

            case ParseNodeType.Yield: {
                typeResult = this.getTypeOfYield(node);
                break;
            }

            case ParseNodeType.YieldFrom: {
                typeResult = this.getTypeOfYieldFrom(node);
                break;
            }

            case ParseNodeType.Unpack: {
                typeResult = this.getTypeOfUnpackOperator(node, flags, expectedType);
                break;
            }

            case ParseNodeType.TypeAnnotation: {
                typeResult = this.getTypeOfExpression(
                    node.typeAnnotation,
                    EvaluatorFlags.ExpectingType |
                        EvaluatorFlags.ExpectingTypeAnnotation |
                        EvaluatorFlags.EvaluateStringLiteralAsType |
                        EvaluatorFlags.ParamSpecDisallowed |
                        EvaluatorFlags.TypeVarTupleDisallowed |
                        EvaluatorFlags.VariableTypeAnnotation
                );
                break;
            }

            case ParseNodeType.String:
            case ParseNodeType.FormatString: {
                typeResult = this.getTypeOfString(node);
                break;
            }

            case ParseNodeType.Error: {
                // Evaluate the child expression as best we can so the
                // type information is cached for the completion handler.
                this.suppressDiagnostics(node, () => {
                    if (node.child) {
                        this.getTypeOfExpression(node.child);
                    }
                });
                typeResult = { type: UnknownType.create() };
                break;
            }

            default:
                assertNever(node);
        }

        if (!typeResult) {
            // We shouldn't get here. If we do, report an error.
            fail(`Unhandled expression type '${ParseTreeUtils.printExpression(node)}'`);
        }

        if (reportExpectingTypeErrors && !typeResult.isIncomplete) {
            if (flags & EvaluatorFlags.TypeVarTupleDisallowed) {
                if (isVariadicTypeVar(typeResult.type) && !typeResult.type.isVariadicInUnion) {
                    this.addError(Localizer.Diagnostic.typeVarTupleContext(), node);
                    typeResult.type = UnknownType.create();
                }
            }

            if (!TypeBase.isInstantiable(typeResult.type)) {
                const isEmptyVariadic =
                    isClassInstance(typeResult.type) &&
                    ClassType.isTupleClass(typeResult.type) &&
                    typeResult.type.tupleTypeArguments?.length === 0;

                if (!isEmptyVariadic) {
                    this.addExpectedClassDiagnostic(typeResult.type, node);
                    typeResult.type = UnknownType.create();
                    typeResult.typeErrors = true;
                }
            }
        }

        if (flags & EvaluatorFlags.DisallowRecursiveTypeAliasPlaceholder) {
            if (isTypeVar(typeResult.type) && isTypeAliasPlaceholder(typeResult.type)) {
                typeResult.type.details.illegalRecursionDetected = true;
            }
        }

        this.writeTypeCache(
            node,
            typeResult.type,
            flags,
            !!typeResult.isIncomplete,
            expectedType,
            /* allowSpeculativeCaching */ true
        );

        if (expectedType && !isAnyOrUnknown(expectedType) && !isNever(expectedType)) {
            this._expectedTypeCache.set(node.id, expectedType);

            if (!typeResult.isIncomplete && !typeResult.expectedTypeDiagAddendum) {
                const diag = new DiagnosticAddendum();
                if (!this.assignType(expectedType, typeResult.type, diag)) {
                    typeResult.expectedTypeDiagAddendum = diag;
                    diag.addTextRange(node);
                }
            }
        }

        if (printExpressionTypes) {
            this._printExpressionSpaceCount--;
            console.log(
                `${this.getPrintExpressionTypesSpaces()}${ParseTreeUtils.printExpression(node)} (${this.getLineNum(
                    node
                )}): Post ${this.printType(typeResult.type)}${typeResult.isIncomplete ? ' Incomplete' : ''}`
            );
        }

        return typeResult;
    }

    getTypeOfAwaitOperator(node: AwaitNode, flags: EvaluatorFlags, expectedType?: Type) {
        const effectiveExpectedType = expectedType
            ? this.createAwaitableReturnType(node, expectedType, /* isGenerator */ false)
            : undefined;

        const exprTypeResult = this.getTypeOfExpression(node.expression, flags, effectiveExpectedType);
        const typeResult: TypeResult = {
            type: this.getTypeOfAwaitable(exprTypeResult.type, node.expression),
        };

        if (exprTypeResult.isIncomplete) {
            typeResult.isIncomplete = true;
        }
        return typeResult;
    }

    getTypeOfEllipsis(flags: EvaluatorFlags, typeResult: TypeResult | undefined, node: ExpressionNode) {
        if ((flags & EvaluatorFlags.ConvertEllipsisToAny) !== 0) {
            typeResult = { type: AnyType.create(/* isEllipsis */ true) };
        } else if ((flags & EvaluatorFlags.ConvertEllipsisToUnknown) !== 0) {
            typeResult = { type: UnknownType.create() };
        } else {
            const ellipsisType = this.getBuiltInObject(node, 'ellipsis') || AnyType.create();
            typeResult = { type: ellipsisType };
        }
        return typeResult;
    }

    getTypeOfNumber(node: NumberNode, typeResult: TypeResult | undefined) {
        if (node.isImaginary) {
            typeResult = { type: this.getBuiltInObject(node, 'complex') };
        } else if (node.isInteger) {
            typeResult = { type: this.cloneBuiltinObjectWithLiteral(node, 'int', node.value) };
        } else {
            typeResult = { type: this.getBuiltInObject(node, 'float') };
        }
        return typeResult;
    }

    getTypeOfUnpackOperator(node: UnpackNode, flags: EvaluatorFlags, expectedType?: Type) {
        let typeResult: TypeResult | undefined;
        let iterExpectedType: Type | undefined;

        if (expectedType) {
            const iterableType = this.getBuiltInType(node, 'Iterable');
            if (iterableType && isInstantiableClass(iterableType)) {
                iterExpectedType = ClassType.cloneAsInstance(
                    ClassType.cloneForSpecialization(iterableType, [expectedType], /* isTypeArgumentExplicit */ true)
                );
            }
        }

        const iterTypeResult = this.getTypeOfExpression(node.expression, flags, iterExpectedType);
        const iterType = iterTypeResult.type;
        if (
            (flags & EvaluatorFlags.TypeVarTupleDisallowed) === 0 &&
            isVariadicTypeVar(iterType) &&
            !iterType.isVariadicUnpacked
        ) {
            typeResult = { type: TypeVarType.cloneForUnpacked(iterType) };
        } else {
            if (
                (flags & EvaluatorFlags.AllowUnpackedTupleOrTypeVarTuple) !== 0 &&
                isInstantiableClass(iterType) &&
                ClassType.isBuiltIn(iterType, 'tuple')
            ) {
                typeResult = { type: ClassType.cloneForUnpacked(iterType) };
            } else {
                const iteratorTypeResult = this.getTypeOfIterator(iterTypeResult, /* isAsync */ false, node) ?? {
                    type: UnknownType.create(!!iterTypeResult.isIncomplete),
                    isIncomplete: iterTypeResult.isIncomplete,
                };
                typeResult = {
                    type: iteratorTypeResult.type,
                    unpackedType: iterType,
                    isIncomplete: iteratorTypeResult.isIncomplete,
                };
            }
        }
        return typeResult;
    }

    getTypeOfStringList(node: StringListNode, flags: EvaluatorFlags, isExpectingType: boolean) {
        let typeResult: TypeResult | undefined;

        if (isExpectingType) {
            let updatedFlags = flags | EvaluatorFlags.AllowForwardReferences | EvaluatorFlags.ExpectingType;

            // In most cases, annotations within a string are not parsed by the interpreter.
            // There are a few exceptions (e.g. the "bound" value for a TypeVar constructor).
            if ((flags & EvaluatorFlags.InterpreterParsesStringLiteral) === 0) {
                updatedFlags |= EvaluatorFlags.NotParsedByInterpreter;
            }

            if (node.typeAnnotation) {
                typeResult = this.getTypeOfExpression(node.typeAnnotation, updatedFlags);
            } else if (!node.typeAnnotation && node.strings.length === 1) {
                // We didn't know at parse time that this string node was going
                // to be evaluated as a forward-referenced type. We need
                // to re-invoke the parser at this stage.
                const expr = this.parseStringAsTypeAnnotation(node);
                if (expr) {
                    typeResult = this.getTypeOfExpression(expr, updatedFlags);
                }
            }

            if (!typeResult) {
                const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
                this.addDiagnostic(
                    fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                    DiagnosticRule.reportGeneralTypeIssues,
                    Localizer.Diagnostic.expectedTypeNotString(),
                    node
                );
                typeResult = { type: UnknownType.create() };
            }
        } else {
            // Evaluate the format string expressions in this context.
            let isLiteralString = true;
            let isIncomplete = false;

            node.strings.forEach((expr) => {
                const typeResult = this.getTypeOfString(expr);

                if (typeResult.isIncomplete) {
                    isIncomplete = true;
                }

                let isExprLiteralString = false;
                if (isClassInstance(typeResult.type)) {
                    if (ClassType.isBuiltIn(typeResult.type, 'str') && typeResult.type.literalValue !== undefined) {
                        isExprLiteralString = true;
                    } else if (ClassType.isBuiltIn(typeResult?.type, 'LiteralString')) {
                        isExprLiteralString = true;
                    }
                }

                if (!isExprLiteralString) {
                    isLiteralString = false;
                }
            });

            const isBytes = (node.strings[0].token.flags & StringTokenFlags.Bytes) !== 0;

            // Don't create a literal type if it's an f-string.
            if (node.strings.some((str) => str.nodeType === ParseNodeType.FormatString)) {
                if (isLiteralString) {
                    const literalStringType = this.getTypingType(node, 'LiteralString');
                    if (literalStringType && isInstantiableClass(literalStringType)) {
                        typeResult = { type: ClassType.cloneAsInstance(literalStringType) };
                    }
                }

                if (!typeResult) {
                    typeResult = {
                        type: this.getBuiltInObject(node, isBytes ? 'bytes' : 'str'),
                        isIncomplete,
                    };
                }
            } else {
                typeResult = {
                    type: this.cloneBuiltinObjectWithLiteral(
                        node,
                        isBytes ? 'bytes' : 'str',
                        node.strings.map((s) => s.value).join('')
                    ),
                    isIncomplete,
                };
            }
        }

        return typeResult;
    }

    getTypeOfString(node: StringNode | FormatStringNode): TypeResult {
        const isBytes = (node.token.flags & StringTokenFlags.Bytes) !== 0;
        let typeResult: TypeResult | undefined;

        // Don't create a literal type if it's an f-string.
        if (node.nodeType === ParseNodeType.FormatString) {
            let isLiteralString = true;

            // If all of the format expressions are of type LiteralString, then
            // the resulting formatted string is also LiteralString.
            node.expressions.forEach((expr) => {
                const exprType = this.getTypeOfExpression(expr).type;

                doForEachSubtype(exprType, (exprSubtype) => {
                    if (!isClassInstance(exprSubtype)) {
                        isLiteralString = false;
                        return;
                    }

                    if (ClassType.isBuiltIn(exprSubtype, 'LiteralString')) {
                        return;
                    }

                    if (ClassType.isBuiltIn(exprSubtype, 'str') && exprSubtype.literalValue !== undefined) {
                        return;
                    }

                    isLiteralString = false;
                });
            });

            if (!isBytes && isLiteralString) {
                const literalStringType = this.getTypingType(node, 'LiteralString');
                if (literalStringType && isInstantiableClass(literalStringType)) {
                    typeResult = { type: ClassType.cloneAsInstance(literalStringType) };
                }
            }

            if (!typeResult) {
                typeResult = {
                    type: this.getBuiltInObject(node, isBytes ? 'bytes' : 'str'),
                };
            }
        } else {
            typeResult = {
                type: this.cloneBuiltinObjectWithLiteral(node, isBytes ? 'bytes' : 'str', node.value),
            };
        }

        return typeResult;
    }

    stripLiteralValue(type: Type): Type {
        if (isClass(type)) {
            if (type.literalValue !== undefined) {
                type = ClassType.cloneWithLiteral(type, /* value */ undefined);
            } else if (ClassType.isBuiltIn(type, 'LiteralString')) {
                // Handle "LiteralString" specially.
                if (this._strClassType && isInstantiableClass(this._strClassType)) {
                    type = ClassType.cloneAsInstance(this._strClassType);
                }
            }

            return type;
        }

        if (isUnion(type)) {
            return mapSubtypes(type, (subtype) => {
                return this.stripLiteralValue(subtype);
            });
        }

        return type;
    }

    getTypeOfParameterAnnotation(paramTypeNode: ExpressionNode, paramCategory: ParameterCategory) {
        return this.getTypeOfAnnotation(paramTypeNode, {
            associateTypeVarsWithScope: true,
            allowTypeVarTuple: paramCategory === ParameterCategory.VarArgList,
            disallowRecursiveTypeAlias: true,
            allowUnpackedTypedDict: paramCategory === ParameterCategory.VarArgDictionary,
            allowUnpackedTuple: paramCategory === ParameterCategory.VarArgList,
        });
    }

    getTypeOfAnnotation(node: ExpressionNode, options?: AnnotationTypeOptions): Type {
        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);

        // Special-case the typing.pyi file, which contains some special
        // types that the type analyzer needs to interpret differently.
        if (fileInfo.isTypingStubFile || fileInfo.isTypingExtensionsStubFile) {
            const specialType = this.handleTypingStubTypeAnnotation(node);
            if (specialType) {
                return specialType;
            }
        }

        let evaluatorFlags =
            EvaluatorFlags.ExpectingType |
            EvaluatorFlags.ExpectingTypeAnnotation |
            EvaluatorFlags.ConvertEllipsisToAny |
            EvaluatorFlags.EvaluateStringLiteralAsType;

        if (options?.isVariableAnnotation) {
            evaluatorFlags |= EvaluatorFlags.VariableTypeAnnotation;
        }

        if (!options?.allowFinal) {
            evaluatorFlags |= EvaluatorFlags.FinalDisallowed;
        }

        if (!options?.allowClassVar) {
            evaluatorFlags |= EvaluatorFlags.ClassVarDisallowed;
        }

        if (!options?.allowTypeVarTuple) {
            evaluatorFlags |= EvaluatorFlags.TypeVarTupleDisallowed;
        } else {
            evaluatorFlags |= EvaluatorFlags.AllowUnpackedTupleOrTypeVarTuple;
        }

        if (!options?.allowParamSpec) {
            evaluatorFlags |= EvaluatorFlags.ParamSpecDisallowed;
        }

        if (options?.associateTypeVarsWithScope) {
            evaluatorFlags |= EvaluatorFlags.AssociateTypeVarsWithCurrentScope;
        } else {
            evaluatorFlags |= EvaluatorFlags.DisallowTypeVarsWithoutScopeId;
        }

        if (options?.disallowRecursiveTypeAlias) {
            evaluatorFlags |= EvaluatorFlags.DisallowRecursiveTypeAliasPlaceholder;
        }

        if (options?.allowUnpackedTypedDict) {
            evaluatorFlags |= EvaluatorFlags.AllowUnpackedTypedDict;
        }

        if (options?.allowUnpackedTuple) {
            evaluatorFlags |= EvaluatorFlags.AllowUnpackedTupleOrTypeVarTuple;
        }

        if (options?.notParsedByInterpreter) {
            evaluatorFlags |= EvaluatorFlags.NotParsedByInterpreter;
        }

        if (isAnnotationEvaluationPostponed(fileInfo)) {
            evaluatorFlags |= EvaluatorFlags.AllowForwardReferences;
        }

        // If the annotation is part of a comment, allow forward references
        // even if it's not enclosed in quotes.
        if (node?.parent?.nodeType === ParseNodeType.Assignment && node.parent.typeAnnotationComment === node) {
            evaluatorFlags |= EvaluatorFlags.AllowForwardReferences | EvaluatorFlags.NotParsedByInterpreter;
        } else if (node?.parent?.nodeType === ParseNodeType.FunctionAnnotation) {
            if (node.parent.returnTypeAnnotation === node || node.parent.paramTypeAnnotations.some((n) => n === node)) {
                evaluatorFlags |= EvaluatorFlags.AllowForwardReferences | EvaluatorFlags.NotParsedByInterpreter;
            }
        } else if (node?.parent?.nodeType === ParseNodeType.Parameter) {
            if (node.parent.typeAnnotationComment === node) {
                evaluatorFlags |= EvaluatorFlags.AllowForwardReferences | EvaluatorFlags.NotParsedByInterpreter;
            }
        }

        const annotationType = this.getTypeOfExpression(node, evaluatorFlags).type;

        if (isModule(annotationType)) {
            this.addDiagnostic(
                fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                DiagnosticRule.reportGeneralTypeIssues,
                Localizer.Diagnostic.moduleAsType(),
                node
            );
        }

        return convertToInstance(annotationType);
    }

    getTypeOfDecorator(node: DecoratorNode, functionOrClassType: Type): Type {
        // Evaluate the type of the decorator expression.
        let flags = AnalyzerNodeInfo.getFileInfo(node).isStubFile
            ? EvaluatorFlags.AllowForwardReferences
            : EvaluatorFlags.None;
        if (node.expression.nodeType !== ParseNodeType.Call) {
            flags |= EvaluatorFlags.DoNotSpecialize;
        }

        const decoratorTypeResult = this.getTypeOfExpression(node.expression, flags);

        // Special-case the combination of a classmethod decorator applied
        // to a property. This is allowed in Python 3.9, but it's not reflected
        // in the builtins.pyi stub for classmethod.
        if (
            isInstantiableClass(decoratorTypeResult.type) &&
            ClassType.isBuiltIn(decoratorTypeResult.type, 'classmethod') &&
            isProperty(functionOrClassType)
        ) {
            return functionOrClassType;
        }

        const argList: FunctionArgument[] = [
            {
                argumentCategory: ArgumentCategory.Simple,
                typeResult: { type: functionOrClassType },
            },
        ];

        const returnType =
            this.validateCallArguments(
                node.expression,
                argList,
                decoratorTypeResult,
                /* typeVarContext */ undefined,
                /* skipUnknownArgCheck */ true
            ).returnType || UnknownType.create();

        // If the return type is a function that has no annotations
        // and just *args and **kwargs parameters, assume that it
        // preserves the type of the input function.
        if (isFunction(returnType) && !returnType.details.declaredReturnType) {
            if (
                !returnType.details.parameters.some((param, index) => {
                    // Don't allow * or / separators or params with declared types.
                    if (!param.name || param.hasDeclaredType) {
                        return true;
                    }

                    // Allow *args or **kwargs parameters.
                    if (param.category !== ParameterCategory.Simple) {
                        return false;
                    }

                    // Allow inferred "self" or "cls" parameters.
                    return index !== 0 || !param.isTypeInferred;
                })
            ) {
                return functionOrClassType;
            }
        }

        // If the decorator is completely unannotated and the return type
        // includes unknowns, assume that it preserves the type of the input
        // function.
        if (isPartlyUnknown(returnType)) {
            if (isFunction(decoratorTypeResult.type)) {
                if (
                    !decoratorTypeResult.type.details.parameters.find((param) => param.typeAnnotation !== undefined) &&
                    decoratorTypeResult.type.details.declaredReturnType === undefined
                ) {
                    return functionOrClassType;
                }
            }
        }

        return returnType;
    }

    canBeFalsy(type: Type, recursionCount = 0): boolean {
        if (recursionCount > maxTypeRecursionCount) {
            return true;
        }
        recursionCount++;

        switch (type.category) {
            case TypeCategory.Unbound:
            case TypeCategory.Unknown:
            case TypeCategory.Any:
            case TypeCategory.Never:
            case TypeCategory.None: {
                return true;
            }

            case TypeCategory.Union: {
                return findSubtype(type, (subtype) => this.canBeFalsy(subtype, recursionCount)) !== undefined;
            }

            case TypeCategory.Function:
            case TypeCategory.OverloadedFunction:
            case TypeCategory.Module:
            case TypeCategory.TypeVar: {
                return false;
            }

            case TypeCategory.Class: {
                if (TypeBase.isInstantiable(type)) {
                    return false;
                }

                // Handle tuples specially.
                if (isTupleClass(type) && type.tupleTypeArguments) {
                    return isUnboundedTupleClass(type) || type.tupleTypeArguments.length === 0;
                }

                // Handle subclasses of tuple, such as NamedTuple.
                const tupleBaseClass = type.details.mro.find(
                    (mroClass) => !isClass(mroClass) || isTupleClass(mroClass)
                );
                if (tupleBaseClass && isClass(tupleBaseClass) && tupleBaseClass.tupleTypeArguments) {
                    return isUnboundedTupleClass(tupleBaseClass) || tupleBaseClass.tupleTypeArguments.length === 0;
                }

                // Check for Literal[False] and Literal[True].
                if (ClassType.isBuiltIn(type, 'bool') && type.literalValue !== undefined) {
                    return type.literalValue === false;
                }

                // If this is a protocol class, don't make any assumptions about the absence
                // of specific methods. These could be provided by a class that conforms
                // to the protocol.
                if (ClassType.isProtocolClass(type)) {
                    return true;
                }

                const lenMethod = lookUpObjectMember(type, '__len__');
                if (lenMethod) {
                    return true;
                }

                const boolMethod = lookUpObjectMember(type, '__bool__');
                if (boolMethod) {
                    const boolMethodType = this.getTypeOfMember(boolMethod);

                    // If the __bool__ function unconditionally returns True, it can never be falsy.
                    if (isFunction(boolMethodType) && boolMethodType.details.declaredReturnType) {
                        const returnType = boolMethodType.details.declaredReturnType;
                        if (
                            isClassInstance(returnType) &&
                            ClassType.isBuiltIn(returnType, 'bool') &&
                            returnType.literalValue === true
                        ) {
                            return false;
                        }
                    }

                    return true;
                }

                return false;
            }
        }
    }

    canBeTruthy(type: Type, recursionCount = 0): boolean {
        if (recursionCount > maxTypeRecursionCount) {
            return true;
        }
        recursionCount++;

        switch (type.category) {
            case TypeCategory.Unknown:
            case TypeCategory.Function:
            case TypeCategory.OverloadedFunction:
            case TypeCategory.Module:
            case TypeCategory.TypeVar:
            case TypeCategory.Never:
            case TypeCategory.Any: {
                return true;
            }

            case TypeCategory.Union: {
                return findSubtype(type, (subtype) => this.canBeTruthy(subtype, recursionCount)) !== undefined;
            }

            case TypeCategory.Unbound:
            case TypeCategory.None: {
                return false;
            }

            case TypeCategory.Class: {
                if (TypeBase.isInstantiable(type)) {
                    return true;
                }

                // Check for Tuple[()] (an empty tuple).
                if (isTupleClass(type)) {
                    if (type.tupleTypeArguments && type.tupleTypeArguments!.length === 0) {
                        return false;
                    }
                }

                // Check for Literal[False], Literal[0], Literal[""].
                if (
                    type.literalValue === false ||
                    type.literalValue === 0 ||
                    type.literalValue === BigInt(0) ||
                    type.literalValue === ''
                ) {
                    return false;
                }

                // If this is a protocol class, don't make any assumptions about the absence
                // of specific methods. These could be provided by a class that conforms
                // to the protocol.
                if (ClassType.isProtocolClass(type)) {
                    return true;
                }

                const boolMethod = lookUpObjectMember(type, '__bool__');
                if (boolMethod) {
                    const boolMethodType = this.getTypeOfMember(boolMethod);

                    // If the __bool__ function unconditionally returns False, it can never be truthy.
                    if (isFunction(boolMethodType) && boolMethodType.details.declaredReturnType) {
                        const returnType = boolMethodType.details.declaredReturnType;
                        if (
                            isClassInstance(returnType) &&
                            ClassType.isBuiltIn(returnType, 'bool') &&
                            returnType.literalValue === false
                        ) {
                            return false;
                        }
                    }
                }

                return true;
            }
        }
    }

    // Filters a type such that that no part of it is definitely
    // truthy. For example, if a type is a union of None
    // and a custom class "Foo" that has no __len__ or __nonzero__
    // method, this method would strip off the "Foo"
    // and return only the "None".
    removeTruthinessFromType(type: Type): Type {
        return mapSubtypes(type, (subtype) => {
            if (isClassInstance(subtype)) {
                if (subtype.literalValue !== undefined) {
                    // If the object is already definitely falsy, it's fine to
                    // include, otherwise it should be removed.
                    return !subtype.literalValue ? subtype : undefined;
                }

                // If the object is a bool, make it "false", since
                // "true" is a truthy value.
                if (ClassType.isBuiltIn(subtype, 'bool')) {
                    return ClassType.cloneWithLiteral(subtype, /* value */ false);
                }
            }

            // If it's possible for the type to be falsy, include it.
            if (this.canBeFalsy(subtype)) {
                return subtype;
            }

            return undefined;
        });
    }

    // Filters a type such that that no part of it is definitely
    // falsy. For example, if a type is a union of None
    // and an "int", this method would strip off the "None"
    // and return only the "int".
    removeFalsinessFromType(type: Type): Type {
        return mapSubtypes(type, (subtype) => {
            if (isClassInstance(subtype)) {
                if (subtype.literalValue !== undefined) {
                    // If the object is already definitely truthy, it's fine to
                    // include, otherwise it should be removed.
                    return subtype.literalValue ? subtype : undefined;
                }

                // If the object is a bool, make it "true", since
                // "false" is a falsy value.
                if (ClassType.isBuiltIn(subtype, 'bool')) {
                    return ClassType.cloneWithLiteral(subtype, /* value */ true);
                }
            }

            // If it's possible for the type to be truthy, include it.
            if (this.canBeTruthy(subtype)) {
                return subtype;
            }

            return undefined;
        });
    }

    // Gets a member type from an object and if it's a function binds
    // it to the object. If bindToClass is undefined, the binding is done
    // using the objectType parameter. Callers can specify these separately
    // to handle the case where we're fetching the object member from a
    // metaclass but binding to the class.
    getTypeOfObjectMember(
        errorNode: ExpressionNode,
        objectType: ClassType,
        memberName: string,
        usage: EvaluatorUsage = { method: 'get' },
        diag: DiagnosticAddendum | undefined = undefined,
        memberAccessFlags = MemberAccessFlags.None,
        bindToType?: ClassType | TypeVarType
    ): TypeResult | undefined {
        const memberInfo = this.getTypeOfClassMemberName(
            errorNode,
            ClassType.cloneAsInstantiable(objectType),
            /* isAccessedThroughObject */ true,
            memberName,
            usage,
            diag,
            memberAccessFlags | MemberAccessFlags.DisallowClassVarWrites,
            bindToType
        );

        if (memberInfo) {
            return {
                type: memberInfo.type,
                classType: memberInfo.classType,
                isIncomplete: !!memberInfo.isTypeIncomplete,
                isAsymmetricDescriptor: memberInfo.isAsymmetricDescriptor,
            };
        }
        return undefined;
    }

    // Gets a member type from a class and if it's a function binds
    // it to the class.
    getTypeOfClassMember(
        errorNode: ExpressionNode,
        classType: ClassType,
        memberName: string,
        usage: EvaluatorUsage = { method: 'get' },
        diag: DiagnosticAddendum | undefined = undefined,
        memberAccessFlags = MemberAccessFlags.None,
        bindToType?: ClassType | TypeVarType
    ): TypeResult | undefined {
        let memberInfo: ClassMemberLookup | undefined;
        const classDiag = diag ? new DiagnosticAddendum() : undefined;
        const metaclassDiag = diag ? new DiagnosticAddendum() : undefined;

        if (ClassType.isPartiallyEvaluated(classType)) {
            this.addDiagnostic(
                AnalyzerNodeInfo.getFileInfo(errorNode).diagnosticRuleSet.reportGeneralTypeIssues,
                DiagnosticRule.reportGeneralTypeIssues,
                Localizer.Diagnostic.classDefinitionCycle().format({ name: classType.details.name }),
                errorNode
            );
            return { type: UnknownType.create() };
        }

        if ((memberAccessFlags & MemberAccessFlags.ConsiderMetaclassOnly) === 0) {
            memberInfo = this.getTypeOfClassMemberName(
                errorNode,
                classType,
                /* isAccessedThroughObject */ false,
                memberName,
                usage,
                classDiag,
                memberAccessFlags | MemberAccessFlags.AccessClassMembersOnly,
                bindToType
            );
        }

        // If this is a protocol class X and we're accessing a non ClassVar,
        // emit an error.
        if (
            memberInfo &&
            memberInfo.classType &&
            memberInfo.symbol &&
            isClass(memberInfo.classType) &&
            ClassType.isProtocolClass(memberInfo.classType)
        ) {
            const primaryDecl = getLastTypedDeclaredForSymbol(memberInfo.symbol);
            if (primaryDecl && primaryDecl.type === DeclarationType.Variable && !memberInfo.isClassVar) {
                this.addDiagnostic(
                    AnalyzerNodeInfo.getFileInfo(errorNode).diagnosticRuleSet.reportGeneralTypeIssues,
                    DiagnosticRule.reportGeneralTypeIssues,
                    Localizer.Diagnostic.protocolMemberNotClassVar().format({
                        memberName,
                        className: memberInfo.classType.details.name,
                    }),
                    errorNode
                );
            }
        }

        const isMemberPresentOnClass = memberInfo?.classType !== undefined;

        // If it wasn't found on the class, see if it's part of the metaclass.
        if (!memberInfo) {
            const metaclass = classType.details.effectiveMetaclass;
            if (metaclass && isInstantiableClass(metaclass) && !ClassType.isSameGenericClass(metaclass, classType)) {
                memberInfo = this.getTypeOfClassMemberName(
                    errorNode,
                    metaclass,
                    /* isAccessedThroughObject */ true,
                    memberName,
                    usage,
                    metaclassDiag,
                    memberAccessFlags,
                    classType
                );
            }
        }

        if (memberInfo) {
            return {
                type: memberInfo.type,
                isIncomplete: !!memberInfo.isTypeIncomplete,
                isAsymmetricDescriptor: memberInfo.isAsymmetricDescriptor,
            };
        }

        // Determine whether to use the class or metaclass diagnostic addendum.
        const subDiag = isMemberPresentOnClass ? classDiag : metaclassDiag;
        if (diag && subDiag) {
            diag.addAddendum(subDiag);
        }

        return undefined;
    }

    getBoundMethod(
        classType: ClassType,
        memberName: string,
        recursionCount = 0,
        treatConstructorAsClassMember = false
    ): FunctionType | OverloadedFunctionType | undefined {
        const memberInfo = lookUpClassMember(classType, memberName, ClassMemberLookupFlags.SkipInstanceVariables);

        if (memberInfo) {
            const unboundMethodType = this.getTypeOfMember(memberInfo);
            if (isFunction(unboundMethodType) || isOverloadedFunction(unboundMethodType)) {
                const boundMethod = this.bindFunctionToClassOrObject(
                    ClassType.cloneAsInstance(classType),
                    unboundMethodType,
                    /* memberClass */ undefined,
                    /* errorNode */ undefined,
                    recursionCount,
                    treatConstructorAsClassMember
                );

                if (boundMethod) {
                    return boundMethod;
                }
            } else if (isAnyOrUnknown(unboundMethodType)) {
                const unknownFunction = FunctionType.createSynthesizedInstance(
                    '',
                    FunctionTypeFlags.SkipArgsKwargsCompatibilityCheck
                );
                FunctionType.addDefaultParameters(unknownFunction);
                return unknownFunction;
            }
        }

        return undefined;
    }

    // Returns the signature(s) associated with a call node that contains
    // the specified node. It also returns the index of the argument
    // that contains the node.
    getCallSignatureInfo(
        callNode: CallNode,
        activeIndex: number,
        activeOrFake: boolean
    ): CallSignatureInfo | undefined {
        const exprNode = callNode.leftExpression;
        const callType = this.getType(exprNode);
        if (callType === undefined) {
            return undefined;
        }

        const argList: FunctionArgument[] = [];
        let previousCategory = ArgumentCategory.Simple;

        // Empty arguments do not enter the AST as nodes, but instead are left blank.
        // Instead, we detect when we appear to be between two known arguments or at the
        // end of the argument list and insert a fake argument of an unknown type to have
        // something to match later.
        function addFakeArg() {
            argList.push({
                argumentCategory: previousCategory,
                typeResult: { type: UnknownType.create() },
                active: true,
            });
        }

        callNode.arguments.forEach((arg, index) => {
            let active = false;
            if (index === activeIndex) {
                if (activeOrFake) {
                    active = true;
                } else {
                    addFakeArg();
                }
            }

            previousCategory = arg.argumentCategory;

            argList.push({
                valueExpression: arg.valueExpression,
                argumentCategory: arg.argumentCategory,
                name: arg.name,
                active: active,
            });
        });

        if (callNode.arguments.length < activeIndex) {
            addFakeArg();
        }

        const signatures: CallSignature[] = [];

        const addOneFunctionToSignature = (type: FunctionType) => {
            let callResult: CallResult | undefined;

            this.useSpeculativeMode(callNode!, () => {
                callResult = this.validateFunctionArguments(
                    exprNode,
                    argList,
                    type,
                    new TypeVarContext(getTypeVarScopeId(type)),
                    /* skipUnknownArgCheck */ true
                );
            });

            signatures.push({
                type,
                activeParam: callResult?.activeParam,
            });
        };

        function addFunctionToSignature(type: FunctionType | OverloadedFunctionType) {
            if (isFunction(type)) {
                addOneFunctionToSignature(type);
            } else {
                OverloadedFunctionType.getOverloads(type).forEach((func) => {
                    addOneFunctionToSignature(func);
                });
            }
        }

        doForEachSubtype(callType, (subtype) => {
            switch (subtype.category) {
                case TypeCategory.Function:
                case TypeCategory.OverloadedFunction: {
                    addFunctionToSignature(subtype);
                    break;
                }

                case TypeCategory.Class: {
                    if (TypeBase.isInstantiable(subtype)) {
                        let methodType: FunctionType | OverloadedFunctionType | undefined;

                        // Try to get the `__init__` method first because it typically has more
                        // type information than `__new__`.
                        methodType = this.getBoundMethod(subtype, '__init__');

                        // Is this the __init__ method provided by the object class?
                        const isObjectInit =
                            !!methodType &&
                            isFunction(methodType) &&
                            methodType.details.fullName === 'builtins.object.__init__';
                        const isSkipConstructor =
                            !!methodType && isFunction(methodType) && FunctionType.isSkipConstructorCheck(methodType);

                        // If there was no `__init__` or the only `__init__` that was found
                        // was form the `object` class, see if we can find a better `__new__`
                        // method.
                        if (
                            !methodType ||
                            isObjectInit ||
                            isSkipConstructor ||
                            (methodType &&
                                isFunction(methodType) &&
                                (FunctionType.hasDefaultParameters(methodType) ||
                                    methodType.details.parameters.length === 0))
                        ) {
                            const constructorType = this.getBoundMethod(
                                subtype,
                                '__new__',
                                /* recursionCount */ undefined,
                                /* treatConstructorAsClassMember */ true
                            );

                            if (constructorType) {
                                // Is this the __new__ method provided by the object class?
                                const isObjectNew =
                                    isFunction(constructorType) &&
                                    constructorType.details.fullName === 'builtins.object.__new__';

                                if (!isObjectNew) {
                                    methodType = constructorType;
                                }
                            }
                        }

                        if (methodType) {
                            addFunctionToSignature(methodType);
                        }
                    } else {
                        const methodType = this.getBoundMethod(subtype, '__call__');
                        if (methodType) {
                            addFunctionToSignature(methodType);
                        }
                    }
                    break;
                }
            }
        });

        if (signatures.length === 0) {
            return undefined;
        }

        return {
            callNode,
            signatures,
        };
    }

    // Determines whether the specified expression is an explicit TypeAlias declaration.
    isDeclaredTypeAlias(expression: ExpressionNode): boolean {
        if (expression.nodeType === ParseNodeType.TypeAnnotation) {
            if (expression.valueExpression.nodeType === ParseNodeType.Name) {
                const symbolWithScope = this.lookUpSymbolRecursive(
                    expression,
                    expression.valueExpression.value,
                    /* honorCodeFlow */ false
                );
                if (symbolWithScope) {
                    const symbol = symbolWithScope.symbol;
                    return symbol.getDeclarations().find((decl) => isExplicitTypeAliasDeclaration(decl)) !== undefined;
                }
            }
        }

        return false;
    }

    // Determines whether the specified expression is a symbol with a declared type.
    getDeclaredTypeForExpression(expression: ExpressionNode, usage?: EvaluatorUsage): Type | undefined {
        let symbol: Symbol | undefined;
        let classOrObjectBase: ClassType | undefined;
        let memberAccessClass: Type | undefined;
        let bindFunction = true;

        switch (expression.nodeType) {
            case ParseNodeType.Name: {
                const symbolWithScope = this.lookUpSymbolRecursive(
                    expression,
                    expression.value,
                    /* honorCodeFlow */ true
                );
                if (symbolWithScope) {
                    symbol = symbolWithScope.symbol;

                    // Handle the case where the symbol is a class-level variable
                    // where the type isn't declared in this class but is in
                    // a parent class.
                    if (
                        this.getDeclaredTypeOfSymbol(symbol, expression) === undefined &&
                        symbolWithScope.scope.type === ScopeType.Class
                    ) {
                        const enclosingClass = ParseTreeUtils.getEnclosingClassOrFunction(expression);
                        if (enclosingClass && enclosingClass.nodeType === ParseNodeType.Class) {
                            const classTypeInfo = this.getTypeOfClass(enclosingClass);
                            if (classTypeInfo) {
                                const classMemberInfo = lookUpClassMember(
                                    classTypeInfo.classType,
                                    expression.value,
                                    ClassMemberLookupFlags.SkipInstanceVariables |
                                        ClassMemberLookupFlags.DeclaredTypesOnly
                                );
                                if (classMemberInfo) {
                                    symbol = classMemberInfo.symbol;
                                }
                            }
                        }
                    }
                }
                break;
            }

            case ParseNodeType.TypeAnnotation: {
                return this.getDeclaredTypeForExpression(expression.valueExpression, usage);
            }

            case ParseNodeType.MemberAccess: {
                const baseType = this.makeTopLevelTypeVarsConcrete(
                    this.getTypeOfExpression(expression.leftExpression, EvaluatorFlags.DoNotSpecialize).type
                );
                let classMemberInfo: ClassMember | undefined;

                if (isClassInstance(baseType)) {
                    classMemberInfo = lookUpObjectMember(
                        baseType,
                        expression.memberName.value,
                        ClassMemberLookupFlags.DeclaredTypesOnly
                    );
                    classOrObjectBase = baseType;
                    memberAccessClass = classMemberInfo?.classType;

                    // If this is an instance member (e.g. a dataclass field), don't
                    // bind it to the object if it's a function.
                    if (classMemberInfo?.isInstanceMember) {
                        bindFunction = false;
                    }
                } else if (isInstantiableClass(baseType)) {
                    classMemberInfo = lookUpClassMember(
                        baseType,
                        expression.memberName.value,
                        ClassMemberLookupFlags.SkipInstanceVariables | ClassMemberLookupFlags.DeclaredTypesOnly
                    );
                    classOrObjectBase = baseType;
                    memberAccessClass = classMemberInfo?.classType;
                }

                if (classMemberInfo) {
                    symbol = classMemberInfo.symbol;
                }
                break;
            }

            case ParseNodeType.Index: {
                const baseType = this.makeTopLevelTypeVarsConcrete(
                    this.getTypeOfExpression(expression.baseExpression, EvaluatorFlags.DoNotSpecialize).type
                );

                if (baseType && isClassInstance(baseType)) {
                    const setItemMember = lookUpClassMember(baseType, '__setitem__');
                    if (setItemMember) {
                        const setItemType = this.getTypeOfMember(setItemMember);
                        if (isFunction(setItemType)) {
                            const boundFunction = this.bindFunctionToClassOrObject(
                                baseType,
                                setItemType,
                                isInstantiableClass(setItemMember.classType) ? setItemMember.classType : undefined,
                                expression,
                                /* recursionCount */ undefined,
                                /* treatConstructorAsClassMember */ false
                            );
                            if (boundFunction && isFunction(boundFunction)) {
                                if (boundFunction.details.parameters.length >= 2) {
                                    const paramType = FunctionType.getEffectiveParameterType(boundFunction, 1);
                                    if (!isAnyOrUnknown(paramType)) {
                                        return paramType;
                                    }
                                }
                            }
                        }
                    } else if (ClassType.isTypedDictClass(baseType)) {
                        const typeFromTypedDict = getTypeOfIndexedTypedDict(
                            this,
                            expression,
                            baseType,
                            usage || { method: 'get' }
                        );
                        if (typeFromTypedDict) {
                            return typeFromTypedDict.type;
                        }
                    }
                }
                break;
            }
        }

        if (symbol) {
            let declaredType = this.getDeclaredTypeOfSymbol(symbol);
            if (declaredType) {
                // If it's a descriptor, we need to get the setter type.
                if (isClassInstance(declaredType)) {
                    const setterInfo = lookUpClassMember(declaredType, '__set__');
                    const setter = setterInfo ? this.getTypeOfMember(setterInfo) : undefined;
                    if (setter && isFunction(setter) && setter.details.parameters.length >= 3) {
                        declaredType = setter.details.parameters[2].type;

                        if (isAnyOrUnknown(declaredType)) {
                            return undefined;
                        }
                    }
                }

                if (classOrObjectBase) {
                    if (memberAccessClass && isInstantiableClass(memberAccessClass)) {
                        declaredType = partiallySpecializeType(declaredType, memberAccessClass);
                    }

                    if (isFunction(declaredType) || isOverloadedFunction(declaredType)) {
                        if (bindFunction) {
                            declaredType = this.bindFunctionToClassOrObject(
                                classOrObjectBase,
                                declaredType,
                                /* memberClass */ undefined,
                                expression
                            );
                        }
                    }
                }

                return declaredType;
            }
        }

        return undefined;
    }

    // Applies an "await" operation to the specified type and returns
    // the result. According to PEP 492, await operates on an Awaitable
    // (object that provides an __await__ that returns a generator object).
    // If errorNode is undefined, no errors are reported.
    getTypeOfAwaitable(type: Type, errorNode?: ExpressionNode): Type {
        return mapSubtypes(type, (subtype) => {
            subtype = this.makeTopLevelTypeVarsConcrete(subtype);

            if (isAnyOrUnknown(subtype)) {
                return subtype;
            }

            if (isClassInstance(subtype)) {
                const awaitReturnType = this.getSpecializedReturnType(subtype, '__await__', [], errorNode);
                if (awaitReturnType) {
                    if (isAnyOrUnknown(awaitReturnType)) {
                        return awaitReturnType;
                    }

                    if (isClassInstance(awaitReturnType)) {
                        const iterReturnType = this.getSpecializedReturnType(
                            awaitReturnType,
                            '__iter__',
                            [],
                            errorNode
                        );

                        if (iterReturnType) {
                            const generatorReturnType = this.getReturnTypeFromGenerator(awaitReturnType);
                            if (generatorReturnType) {
                                return generatorReturnType;
                            }
                        }
                    }
                }
            }

            if (errorNode) {
                const fileInfo = AnalyzerNodeInfo.getFileInfo(errorNode);
                this.addDiagnostic(
                    fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                    DiagnosticRule.reportGeneralTypeIssues,
                    Localizer.Diagnostic.typeNotAwaitable().format({ type: this.printType(subtype) }),
                    errorNode
                );
            }

            return UnknownType.create();
        });
    }

    // Validates that the type is an iterator and returns the iterated type
    // (i.e. the type returned from the '__next__' or '__anext__' method).
    getTypeOfIterator(
        typeResult: TypeResult,
        isAsync: boolean,
        errorNode: ExpressionNode | undefined
    ): TypeResult | undefined {
        const iterMethodName = isAsync ? '__aiter__' : '__iter__';
        const nextMethodName = isAsync ? '__anext__' : '__next__';
        let isValidIterator = true;

        let type = transformPossibleRecursiveTypeAlias(typeResult.type);
        type = this.makeTopLevelTypeVarsConcrete(type);

        if (isOptionalType(type)) {
            if (errorNode && !typeResult.isIncomplete) {
                this.addDiagnostic(
                    AnalyzerNodeInfo.getFileInfo(errorNode).diagnosticRuleSet.reportOptionalIterable,
                    DiagnosticRule.reportOptionalIterable,
                    Localizer.Diagnostic.noneNotIterable(),
                    errorNode
                );
            }
            type = removeNoneFromUnion(type);
        }

        const iterableType = mapSubtypes(type, (subtype) => {
            subtype = this.makeTopLevelTypeVarsConcrete(subtype);

            if (isAnyOrUnknown(subtype)) {
                return subtype;
            }

            const diag = new DiagnosticAddendum();
            if (isClass(subtype)) {
                let iterReturnType: Type | undefined;

                if (TypeBase.isInstance(subtype)) {
                    // Handle an empty tuple specially.
                    if (
                        isTupleClass(subtype) &&
                        subtype.tupleTypeArguments &&
                        subtype.tupleTypeArguments.length === 0
                    ) {
                        return NeverType.createNever();
                    }

                    iterReturnType = this.getSpecializedReturnType(subtype, iterMethodName, [], errorNode);
                } else if (
                    TypeBase.isInstantiable(subtype) &&
                    subtype.details.effectiveMetaclass &&
                    isInstantiableClass(subtype.details.effectiveMetaclass)
                ) {
                    iterReturnType = this.getSpecializedReturnType(
                        ClassType.cloneAsInstance(subtype.details.effectiveMetaclass),
                        iterMethodName,
                        [],
                        errorNode,
                        subtype
                    );
                }

                if (!iterReturnType) {
                    // There was no __iter__. See if we can fall back to
                    // the __getitem__ method instead.
                    if (!isAsync && isClassInstance(subtype)) {
                        const getItemReturnType = this.getSpecializedReturnType(
                            subtype,
                            '__getitem__',
                            [
                                {
                                    argumentCategory: ArgumentCategory.Simple,
                                    typeResult: {
                                        type:
                                            this._intClassType && isInstantiableClass(this._intClassType)
                                                ? ClassType.cloneAsInstance(this._intClassType)
                                                : UnknownType.create(),
                                    },
                                },
                            ],
                            errorNode
                        );
                        if (getItemReturnType) {
                            return getItemReturnType;
                        }
                    }

                    diag.addMessage(Localizer.Diagnostic.methodNotDefined().format({ name: iterMethodName }));
                } else {
                    const iterReturnTypeDiag = new DiagnosticAddendum();

                    const returnType = this.mapSubtypesExpandTypeVars(
                        iterReturnType,
                        /* conditionFilter */ undefined,
                        (subtype) => {
                            if (isAnyOrUnknown(subtype)) {
                                return subtype;
                            }

                            if (isClassInstance(subtype)) {
                                let nextReturnType = this.getSpecializedReturnType(
                                    subtype,
                                    nextMethodName,
                                    [],
                                    errorNode
                                );

                                if (!nextReturnType) {
                                    iterReturnTypeDiag.addMessage(
                                        Localizer.Diagnostic.methodNotDefinedOnType().format({
                                            name: nextMethodName,
                                            type: this.printType(subtype!),
                                        })
                                    );
                                } else {
                                    // Convert any unpacked TypeVarTuples into object instances. We don't
                                    // know anything more about them.
                                    nextReturnType = mapSubtypes(nextReturnType, (returnSubtype) => {
                                        if (isTypeVar(returnSubtype) && isUnpackedVariadicTypeVar(returnSubtype)) {
                                            return this._objectType ?? UnknownType.create();
                                        }

                                        return returnSubtype;
                                    });

                                    if (!isAsync) {
                                        return nextReturnType;
                                    }

                                    // If it's an async iteration, there's an implicit
                                    // 'await' operator applied.
                                    return this.getTypeOfAwaitable(nextReturnType, errorNode);
                                }
                            } else {
                                iterReturnTypeDiag.addMessage(
                                    Localizer.Diagnostic.methodReturnsNonObject().format({ name: iterMethodName })
                                );
                            }

                            return undefined;
                        }
                    );

                    if (iterReturnTypeDiag.isEmpty()) {
                        return returnType;
                    }

                    diag.addAddendum(iterReturnTypeDiag);
                }
            }

            if (errorNode && !typeResult.isIncomplete) {
                this.addDiagnostic(
                    AnalyzerNodeInfo.getFileInfo(errorNode).diagnosticRuleSet.reportGeneralTypeIssues,
                    DiagnosticRule.reportGeneralTypeIssues,
                    Localizer.Diagnostic.typeNotIterable().format({ type: this.printType(subtype) }) + diag.getString(),
                    errorNode
                );
            }

            isValidIterator = false;
            return undefined;
        });

        return isValidIterator ? { type: iterableType, isIncomplete: typeResult.isIncomplete } : undefined;
    }

    // Validates that the type is an iterable and returns the iterable type argument.
    getTypeOfIterable(
        typeResult: TypeResult,
        isAsync: boolean,
        errorNode: ExpressionNode | undefined
    ): TypeResult | undefined {
        const iterMethodName = isAsync ? '__aiter__' : '__iter__';
        let isValidIterable = true;

        let type = this.makeTopLevelTypeVarsConcrete(typeResult.type);

        if (isOptionalType(type)) {
            if (errorNode && !typeResult.isIncomplete) {
                this.addDiagnostic(
                    AnalyzerNodeInfo.getFileInfo(errorNode).diagnosticRuleSet.reportOptionalIterable,
                    DiagnosticRule.reportOptionalIterable,
                    Localizer.Diagnostic.noneNotIterable(),
                    errorNode
                );
            }
            type = removeNoneFromUnion(type);
        }

        const iterableType = mapSubtypes(type, (subtype) => {
            if (isAnyOrUnknown(subtype)) {
                return subtype;
            }

            if (isClass(subtype)) {
                let iterReturnType: Type | undefined;

                if (TypeBase.isInstance(subtype)) {
                    iterReturnType = this.getSpecializedReturnType(subtype, iterMethodName, [], errorNode);
                } else if (
                    TypeBase.isInstantiable(subtype) &&
                    subtype.details.effectiveMetaclass &&
                    isInstantiableClass(subtype.details.effectiveMetaclass)
                ) {
                    iterReturnType = this.getSpecializedReturnType(
                        ClassType.cloneAsInstance(subtype.details.effectiveMetaclass),
                        iterMethodName,
                        [],
                        errorNode,
                        subtype
                    );
                }

                if (iterReturnType) {
                    return this.makeTopLevelTypeVarsConcrete(iterReturnType);
                }
            }

            if (errorNode) {
                this.addDiagnostic(
                    AnalyzerNodeInfo.getFileInfo(errorNode).diagnosticRuleSet.reportGeneralTypeIssues,
                    DiagnosticRule.reportGeneralTypeIssues,
                    Localizer.Diagnostic.typeNotIterable().format({ type: this.printType(subtype) }),
                    errorNode
                );
            }

            isValidIterable = false;
            return undefined;
        });

        return isValidIterable ? { type: iterableType, isIncomplete: typeResult.isIncomplete } : undefined;
    }

    isTypeHashable(type: Type): boolean {
        let isTypeHashable = true;

        doForEachSubtype(this.makeTopLevelTypeVarsConcrete(type), (subtype) => {
            if (isClassInstance(subtype)) {
                // Assume the class is hashable.
                let isObjectHashable = true;

                // Have we already computed and cached the hashability?
                if (subtype.details.isInstanceHashable !== undefined) {
                    isObjectHashable = subtype.details.isInstanceHashable;
                } else {
                    const hashMember = lookUpObjectMember(
                        subtype,
                        '__hash__',
                        ClassMemberLookupFlags.SkipObjectBaseClass
                    );

                    if (hashMember && hashMember.isTypeDeclared) {
                        const decls = hashMember.symbol.getTypedDeclarations();
                        const synthesizedType = hashMember.symbol.getSynthesizedType();

                        // Handle the case where the type is synthesized (used for
                        // dataclasses).
                        if (synthesizedType) {
                            isObjectHashable = !isNoneInstance(synthesizedType);
                        } else {
                            // Assume that if '__hash__' is declared as a variable, it is
                            // not hashable. If it's declared as a function, it is. We'll
                            // skip evaluating its full type because that's not needed in
                            // this case.
                            if (decls.every((decl) => decl.type === DeclarationType.Variable)) {
                                isObjectHashable = false;
                            }
                        }
                    }

                    // Cache the hashability for next time.
                    subtype.details.isInstanceHashable = isObjectHashable;
                }

                if (!isObjectHashable) {
                    isTypeHashable = false;
                }
            }
        });

        return isTypeHashable;
    }

    getTypedDictClassType() {
        return this._typedDictClassType;
    }

    getTupleClassType() {
        return this._tupleClassType;
    }

    getObjectType() {
        return this._objectType;
    }

    getTypingType(node: ParseNode, symbolName: string): Type | undefined {
        return (
            this.getTypeOfModule(node, symbolName, ['typing']) ??
            this.getTypeOfModule(node, symbolName, ['typing_extensions'])
        );
    }

    getTypeshedType(node: ParseNode, symbolName: string): Type | undefined {
        return this.getTypeOfModule(node, symbolName, ['_typeshed']);
    }

    getTypeOfModule(node: ParseNode, symbolName: string, nameParts: string[]) {
        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
        const lookupResult = this._importLookup({ nameParts, importingFilePath: fileInfo.filePath });

        if (!lookupResult) {
            return undefined;
        }

        const symbol = lookupResult.symbolTable.get(symbolName);
        if (!symbol) {
            return undefined;
        }

        return this.getEffectiveTypeOfSymbol(symbol);
    }

    checkCodeFlowTooComplex(node: ParseNode): boolean {
        const scopeNode = node.nodeType === ParseNodeType.Function ? node : ParseTreeUtils.getExecutionScopeNode(node);
        const codeComplexity = AnalyzerNodeInfo.getCodeFlowComplexity(scopeNode);

        if (codeComplexity > maxCodeComplexity) {
            let errorRange: TextRange = scopeNode;
            if (scopeNode.nodeType === ParseNodeType.Function) {
                errorRange = scopeNode.name;
            } else if (scopeNode.nodeType === ParseNodeType.Module) {
                errorRange = { start: 0, length: 0 };
            }

            const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
            this.addDiagnosticForTextRange(
                fileInfo,
                fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                DiagnosticRule.reportGeneralTypeIssues,
                Localizer.Diagnostic.codeTooComplexToAnalyze(),
                errorRange
            );

            return true;
        }

        return false;
    }

    isNodeReachable(node: ParseNode, sourceNode?: ParseNode): boolean {
        if (this.checkCodeFlowTooComplex(node)) {
            return true;
        }

        const flowNode = AnalyzerNodeInfo.getFlowNode(node);
        if (!flowNode) {
            if (node.parent) {
                return this.isNodeReachable(node.parent, sourceNode);
            }
            return false;
        }

        const sourceFlowNode = sourceNode ? AnalyzerNodeInfo.getFlowNode(sourceNode) : undefined;

        return this._codeFlowEngine.isFlowNodeReachable(flowNode, sourceFlowNode);
    }

    isAfterNodeReachable(node: ParseNode): boolean {
        const returnFlowNode = AnalyzerNodeInfo.getAfterFlowNode(node);
        if (!returnFlowNode) {
            return false;
        }

        if (this.checkCodeFlowTooComplex(node)) {
            return true;
        }

        if (!this._codeFlowEngine.isFlowNodeReachable(returnFlowNode)) {
            return false;
        }

        if (!this.isFlowNodeReachableUsingNeverNarrowing(node, returnFlowNode)) {
            return false;
        }

        return true;
    }

    // Although isFlowNodeReachable indicates that the node is reachable, it
    // may not be reachable if we apply "never narrowing".
    isFlowNodeReachableUsingNeverNarrowing(node: ParseNode, flowNode: FlowNode) {
        const analyzer = this.getCodeFlowAnalyzerForNode(node.id);

        if (this.checkCodeFlowTooComplex(node)) {
            return true;
        }

        const codeFlowResult = analyzer.getTypeFromCodeFlow(
            flowNode,
            /* reference */ undefined,
            /* targetSymbolId */ undefined,
            /* typeAtStart */ UnboundType.create(),
            {
                skipNoReturnCallAnalysis: true,
            }
        );

        return codeFlowResult.type !== undefined && !isNever(codeFlowResult.type);
    }

    // Determines whether there is a code flow path from sourceNode to sinkNode.
    isFlowPathBetweenNodes(sourceNode: ParseNode, sinkNode: ParseNode, allowSelf = true) {
        if (this.checkCodeFlowTooComplex(sourceNode)) {
            return true;
        }

        const sourceFlowNode = AnalyzerNodeInfo.getFlowNode(sourceNode);
        const sinkFlowNode = AnalyzerNodeInfo.getFlowNode(sinkNode);
        if (!sourceFlowNode || !sinkFlowNode) {
            return false;
        }
        if (sourceFlowNode === sinkFlowNode) {
            return allowSelf;
        }

        return this._codeFlowEngine.isFlowNodeReachable(sinkFlowNode, sourceFlowNode, /* ignoreNoReturn */ true);
    }

    // Determines whether the specified string literal is part
    // of a Literal['xxx'] statement. If so, we will not treat
    // the string as a normal forward-declared type annotation.
    isAnnotationLiteralValue(node: StringListNode): boolean {
        if (node.parent && node.parent.nodeType === ParseNodeType.Index) {
            const baseType = this.getTypeOfExpression(node.parent.baseExpression).type;
            if (baseType && isInstantiableClass(baseType)) {
                if (ClassType.isSpecialBuiltIn(baseType, 'Literal')) {
                    return true;
                }
            }
        }

        return false;
    }

    addInformation(message: string, node: ParseNode, range?: TextRange) {
        return this.addDiagnosticWithSuppressionCheck('information', message, node, range);
    }

    addWarning(message: string, node: ParseNode, range?: TextRange) {
        return this.addDiagnosticWithSuppressionCheck('warning', message, node, range);
    }

    addError(message: string, node: ParseNode, range?: TextRange) {
        return this.addDiagnosticWithSuppressionCheck('error', message, node, range);
    }

    addUnusedCode(node: ParseNode, textRange: TextRange) {
        if (!this.isDiagnosticSuppressedForNode(node)) {
            const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
            fileInfo.diagnosticSink.addUnusedCodeWithTextRange(Localizer.Diagnostic.unreachableCode(), textRange);
        }
    }

    addUnreachableCode(node: ParseNode, textRange: TextRange) {
        if (!this.isDiagnosticSuppressedForNode(node)) {
            const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
            fileInfo.diagnosticSink.addUnreachableCodeWithTextRange(Localizer.Diagnostic.unreachableCode(), textRange);
        }
    }

    addDeprecated(message: string, node: ParseNode) {
        if (!this.isDiagnosticSuppressedForNode(node)) {
            const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
            fileInfo.diagnosticSink.addDeprecatedWithTextRange(message, node);
        }
    }

    addDiagnosticWithSuppressionCheck(diagLevel: DiagnosticLevel, message: string, node: ParseNode, range?: TextRange) {
        if (!this.isDiagnosticSuppressedForNode(node) && this.isNodeReachable(node)) {
            const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
            return fileInfo.diagnosticSink.addDiagnosticWithTextRange(diagLevel, message, range || node);
        }

        return undefined;
    }

    isDiagnosticSuppressedForNode(node: ParseNode) {
        return (
            this._suppressedNodeStack.some((suppressedNode) =>
                ParseTreeUtils.isNodeContainedWithin(node, suppressedNode)
            ) || this._speculativeTypeTracker.isSpeculative(node)
        );
    }

    addDiagnostic(diagLevel: DiagnosticLevel, rule: string, message: string, node: ParseNode, range?: TextRange) {
        if (diagLevel === 'none') {
            return undefined;
        }

        // Should we suppress this diagnostic because it's within an unannotated function?
        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
        if (!fileInfo.diagnosticRuleSet.analyzeUnannotatedFunctions) {
            const containingFunction = ParseTreeUtils.getEnclosingFunction(node);

            // Is the target node within the body of the function? If so, suppress the diagnostic.
            if (
                containingFunction &&
                ParseTreeUtils.isUnannotatedFunction(containingFunction) &&
                ParseTreeUtils.isNodeContainedWithin(node, containingFunction.suite)
            ) {
                return undefined;
            }
        }

        const diagnostic = this.addDiagnosticWithSuppressionCheck(diagLevel, message, node, range);
        if (diagnostic) {
            diagnostic.setRule(rule);
        }

        return diagnostic;
    }

    addDiagnosticForTextRange(
        fileInfo: AnalyzerFileInfo,
        diagLevel: DiagnosticLevel,
        rule: string,
        message: string,
        range: TextRange
    ) {
        if (diagLevel === 'none') {
            return undefined;
        }

        const diagnostic = fileInfo.diagnosticSink.addDiagnosticWithTextRange(diagLevel, message, range);
        if (rule) {
            diagnostic.setRule(rule);
        }

        return diagnostic;
    }

    addExpectedClassDiagnostic(type: Type, node: ParseNode) {
        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
        const diag = new DiagnosticAddendum();
        if (isUnion(type)) {
            doForEachSubtype(type, (subtype) => {
                if (!TypeBase.isInstantiable(subtype)) {
                    diag.addMessage(
                        Localizer.DiagnosticAddendum.typeNotClass().format({ type: this.printType(subtype) })
                    );
                }
            });
        }

        this.addDiagnostic(
            fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
            DiagnosticRule.reportGeneralTypeIssues,
            Localizer.Diagnostic.typeExpectedClass().format({ type: this.printType(type) }) + diag.getString(),
            node
        );
    }

    assignTypeToNameNode(
        nameNode: NameNode,
        type: Type,
        isTypeIncomplete: boolean,
        ignoreEmptyContainers: boolean,
        srcExpression?: ParseNode,
        allowAssignmentToFinalVar = false,
        expectedTypeDiagAddendum?: DiagnosticAddendum
    ) {
        const nameValue = nameNode.value;

        const symbolWithScope = this.lookUpSymbolRecursive(nameNode, nameValue, /* honorCodeFlow */ false);
        if (!symbolWithScope) {
            // This can happen when we are evaluating a piece of code that was
            // determined to be unreachable by the binder.
            return;
        }

        const declarations = symbolWithScope.symbol.getDeclarations();
        let declaredType = this.getDeclaredTypeOfSymbol(symbolWithScope.symbol);
        const fileInfo = AnalyzerNodeInfo.getFileInfo(nameNode);

        // If this is a class scope and there is no type declared for this class variable,
        // see if a parent class has a type declared.
        if (declaredType === undefined && symbolWithScope.scope.type === ScopeType.Class) {
            const containingClass = ParseTreeUtils.getEnclosingClass(nameNode);
            if (containingClass) {
                const classType = this.getTypeOfClass(containingClass);
                if (classType) {
                    const memberInfo = lookUpClassMember(
                        classType.classType,
                        nameNode.value,
                        ClassMemberLookupFlags.SkipOriginalClass
                    );
                    if (memberInfo?.isTypeDeclared) {
                        declaredType = this.getTypeOfMember(memberInfo);
                    }
                }
            }
        }

        // We found an existing declared type. Make sure the type is assignable.
        let destType = type;
        if (declaredType) {
            let diagAddendum = new DiagnosticAddendum();

            if (!this.assignType(declaredType, type, diagAddendum)) {
                // If there was an expected type mismatch, use that diagnostic
                // addendum because it will be more informative.
                if (expectedTypeDiagAddendum) {
                    diagAddendum = expectedTypeDiagAddendum;
                }

                this.addDiagnostic(
                    fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                    DiagnosticRule.reportGeneralTypeIssues,
                    Localizer.Diagnostic.typeAssignmentMismatch().format({
                        sourceType: this.printType(type),
                        destType: this.printType(declaredType),
                    }) + diagAddendum.getString(),
                    srcExpression ?? nameNode,
                    diagAddendum.getEffectiveTextRange() ?? srcExpression ?? nameNode
                );

                // Replace the assigned type with the (unnarrowed) declared type.
                destType = declaredType;
            } else {
                // Constrain the resulting type to match the declared type.
                destType = this.narrowTypeBasedOnAssignment(declaredType, type);
            }
        } else {
            // If this is a member name (within a class scope) and the member name
            // appears to be a constant, use the strict source type. If it's a member
            // variable that can be overridden by a child class, use the more general
            // version by stripping off the literal.
            const scope = ScopeUtils.getScopeForNode(nameNode);
            if (scope?.type === ScopeType.Class) {
                if (
                    TypeBase.isInstance(destType) &&
                    !isConstantName(nameValue) &&
                    !isFinalVariable(symbolWithScope.symbol)
                ) {
                    destType = this.stripLiteralValue(destType);
                }
            }
        }

        const varDecl: Declaration | undefined = declarations.find((decl) => decl.type === DeclarationType.Variable);

        if (varDecl && varDecl.type === DeclarationType.Variable) {
            if (varDecl.isConstant) {
                // A constant variable can be assigned only once. If this
                // isn't the first assignment, generate an error.
                if (nameNode !== getNameNodeForDeclaration(declarations[0])) {
                    this.addDiagnostic(
                        fileInfo.diagnosticRuleSet.reportConstantRedefinition,
                        DiagnosticRule.reportConstantRedefinition,
                        Localizer.Diagnostic.constantRedefinition().format({ name: nameValue }),
                        nameNode
                    );
                }
            } else if (varDecl.isFinal && !allowAssignmentToFinalVar) {
                this.addDiagnostic(
                    fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                    DiagnosticRule.reportGeneralTypeIssues,
                    Localizer.Diagnostic.finalReassigned().format({ name: nameValue }),
                    nameNode
                );
            }
        }

        if (!isTypeIncomplete) {
            this.reportPossibleUnknownAssignment(
                fileInfo.diagnosticRuleSet.reportUnknownVariableType,
                DiagnosticRule.reportUnknownVariableType,
                nameNode,
                destType,
                nameNode,
                ignoreEmptyContainers
            );
        }

        this.writeTypeCache(nameNode, destType, EvaluatorFlags.None, isTypeIncomplete);
    }

    assignTypeToMemberAccessNode(
        target: MemberAccessNode,
        type: Type,
        isTypeIncomplete: boolean,
        srcExpr?: ExpressionNode,
        expectedTypeDiagAddendum?: DiagnosticAddendum
    ) {
        const baseTypeResult = this.getTypeOfExpression(target.leftExpression, EvaluatorFlags.DoNotSpecialize);
        const baseType = this.makeTopLevelTypeVarsConcrete(baseTypeResult.type);

        // Handle member accesses (e.g. self.x or cls.y).
        if (target.leftExpression.nodeType === ParseNodeType.Name) {
            // Determine whether we're writing to a class or instance member.
            const enclosingClassNode = ParseTreeUtils.getEnclosingClass(target);

            if (enclosingClassNode) {
                const classTypeResults = this.getTypeOfClass(enclosingClassNode);

                if (classTypeResults && isInstantiableClass(classTypeResults.classType)) {
                    if (isClassInstance(baseType)) {
                        if (ClassType.isSameGenericClass(baseType, classTypeResults.classType)) {
                            this.assignTypeToMemberVariable(
                                target,
                                type,
                                isTypeIncomplete,
                                /* isInstanceMember */ true,
                                srcExpr
                            );
                        }
                    } else if (isInstantiableClass(baseType)) {
                        if (ClassType.isSameGenericClass(baseType, classTypeResults.classType)) {
                            this.assignTypeToMemberVariable(
                                target,
                                type,
                                isTypeIncomplete,
                                /* isInstanceMember */ false,
                                srcExpr
                            );
                        }
                    }

                    // Assignments to instance or class variables through "self" or "cls" is not
                    // allowed for protocol classes unless it is also declared within the class.
                    if (ClassType.isProtocolClass(classTypeResults.classType)) {
                        const memberSymbol = classTypeResults.classType.details.fields.get(target.memberName.value);
                        if (memberSymbol) {
                            const classLevelDecls = memberSymbol.getDeclarations().filter((decl) => {
                                return !ParseTreeUtils.getEnclosingFunction(decl.node);
                            });
                            if (classLevelDecls.length === 0) {
                                this.addError(Localizer.Diagnostic.assignmentInProtocol(), target.memberName);
                            }
                        }
                    }
                }
            }
        }

        const setTypeResult = this.getTypeOfMemberAccessWithBaseType(
            target,
            baseTypeResult,
            { method: 'set', setType: type, setErrorNode: srcExpr, setExpectedTypeDiag: expectedTypeDiagAddendum },
            EvaluatorFlags.None
        );

        if (setTypeResult.isAsymmetricDescriptor) {
            this.setAsymmetricDescriptorAssignment(target);
        }

        this.writeTypeCache(target.memberName, type, EvaluatorFlags.None, isTypeIncomplete);
        this.writeTypeCache(target, type, EvaluatorFlags.None, isTypeIncomplete);
    }

    assignTypeToMemberVariable(
        node: MemberAccessNode,
        srcType: Type,
        isTypeIncomplete: boolean,
        isInstanceMember: boolean,
        srcExprNode?: ExpressionNode
    ) {
        const memberName = node.memberName.value;
        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);

        const classDef = ParseTreeUtils.getEnclosingClass(node);
        if (!classDef) {
            return;
        }

        const classTypeInfo = this.getTypeOfClass(classDef);
        if (classTypeInfo && isInstantiableClass(classTypeInfo.classType)) {
            let memberInfo = lookUpClassMember(
                classTypeInfo.classType,
                memberName,
                isInstanceMember ? ClassMemberLookupFlags.Default : ClassMemberLookupFlags.SkipInstanceVariables
            );

            const memberFields = classTypeInfo.classType.details.fields;
            if (memberInfo) {
                // Are we accessing an existing member on this class, or is
                // it a member on a parent class?
                const memberClass = isInstantiableClass(memberInfo.classType) ? memberInfo.classType : undefined;
                const isThisClass = memberClass && ClassType.isSameGenericClass(classTypeInfo.classType, memberClass);

                // Check for an attempt to write to an instance variable that is
                // not defined by __slots__.
                if (isThisClass && isInstanceMember) {
                    if (memberClass?.details.inheritedSlotsNames && memberClass.details.localSlotsNames) {
                        // Skip this check if the local slots is specified but empty because this pattern
                        // is used in a legitimate manner for mix-in classes.
                        if (
                            memberClass.details.localSlotsNames.length > 0 &&
                            !memberClass.details.inheritedSlotsNames.some((name) => name === memberName)
                        ) {
                            // Determine whether the assignment corresponds to a descriptor
                            // that was assigned as a class variable. If so, then slots will not
                            // apply in this case.
                            const classMemberDetails = lookUpClassMember(
                                memberClass,
                                memberName,
                                ClassMemberLookupFlags.SkipInstanceVariables
                            );
                            let isPotentiallyDescriptor = false;

                            if (classMemberDetails) {
                                const classMemberSymbolType = this.getEffectiveTypeOfSymbol(classMemberDetails.symbol);
                                if (
                                    isAnyOrUnknown(classMemberSymbolType) ||
                                    isUnbound(classMemberSymbolType) ||
                                    isMaybeDescriptorInstance(classMemberSymbolType)
                                ) {
                                    isPotentiallyDescriptor = true;
                                }
                            }

                            if (!isPotentiallyDescriptor) {
                                this.addDiagnostic(
                                    fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                                    DiagnosticRule.reportGeneralTypeIssues,
                                    Localizer.Diagnostic.slotsAttributeError().format({ name: memberName }),
                                    node.memberName
                                );
                            }
                        }
                    }
                }

                if (isThisClass && memberInfo.isInstanceMember === isInstanceMember) {
                    const symbol = memberFields.get(memberName)!;
                    assert(symbol !== undefined);

                    const typedDecls = symbol.getDeclarations();

                    // Check for an attempt to overwrite a constant member variable.
                    if (
                        typedDecls.length > 0 &&
                        typedDecls[0].type === DeclarationType.Variable &&
                        srcExprNode &&
                        node.memberName !== typedDecls[0].node
                    ) {
                        if (typedDecls[0].isConstant) {
                            this.addDiagnostic(
                                fileInfo.diagnosticRuleSet.reportConstantRedefinition,
                                DiagnosticRule.reportConstantRedefinition,
                                Localizer.Diagnostic.constantRedefinition().format({ name: node.memberName.value }),
                                node.memberName
                            );
                        }
                    }
                } else {
                    // Is the target a property?
                    const declaredType = this.getDeclaredTypeOfSymbol(memberInfo.symbol);
                    if (declaredType && !isProperty(declaredType)) {
                        // Handle the case where there is a class variable defined with the same
                        // name, but there's also now an instance variable introduced. Combine the
                        // type of the class variable with that of the new instance variable.
                        if (!memberInfo.isInstanceMember && isInstanceMember) {
                            // The class variable is accessed in this case.
                            this.setSymbolAccessed(fileInfo, memberInfo.symbol, node.memberName);
                            const memberType = this.getTypeOfMember(memberInfo);
                            srcType = combineTypes([srcType, memberType]);
                        }
                    }
                }
            }

            // Look up the member info again, now that we've potentially updated it.
            memberInfo = lookUpClassMember(
                classTypeInfo.classType,
                memberName,
                ClassMemberLookupFlags.DeclaredTypesOnly
            );

            if (!memberInfo && srcExprNode && !isTypeIncomplete) {
                this.reportPossibleUnknownAssignment(
                    fileInfo.diagnosticRuleSet.reportUnknownMemberType,
                    DiagnosticRule.reportUnknownMemberType,
                    node.memberName,
                    srcType,
                    node,
                    /* ignoreEmptyContainers */ true
                );
            }
        }
    }

    assignTypeToTupleOrListNode(
        target: TupleNode | ListNode,
        type: Type,
        isTypeIncomplete: boolean,
        srcExpr: ExpressionNode
    ) {
        const targetExpressions = target.nodeType === ParseNodeType.List ? target.entries : target.expressions;

        // Initialize the array of target types, one for each target.
        const targetTypes: Type[][] = new Array(targetExpressions.length);
        for (let i = 0; i < targetExpressions.length; i++) {
            targetTypes[i] = [];
        }
        const targetUnpackIndex = targetExpressions.findIndex((expr) => expr.nodeType === ParseNodeType.Unpack);

        // Do any of the targets use an unpack operator? If so, it will consume all of the
        // entries at that location.
        const unpackIndex = targetExpressions.findIndex((expr) => expr.nodeType === ParseNodeType.Unpack);

        type = this.makeTopLevelTypeVarsConcrete(type);

        const diagAddendum = new DiagnosticAddendum();

        doForEachSubtype(type, (subtype) => {
            // Is this subtype a tuple?
            const tupleType = getSpecializedTupleType(subtype);
            if (tupleType && tupleType.tupleTypeArguments) {
                const sourceEntryTypes = tupleType.tupleTypeArguments.map((t) =>
                    addConditionToType(t.type, getTypeCondition(subtype))
                );

                const unboundedIndex = tupleType.tupleTypeArguments.findIndex((t) => t.isUnbounded);

                if (unboundedIndex >= 0) {
                    if (sourceEntryTypes.length > targetTypes.length) {
                        // Splice out the unbounded since it might be zero length.
                        sourceEntryTypes.splice(unboundedIndex, 1);
                    } else if (sourceEntryTypes.length < targetTypes.length) {
                        const typeToReplicate =
                            sourceEntryTypes.length > 0 ? sourceEntryTypes[unboundedIndex] : AnyType.create();

                        // Add elements to make the count match the target count.
                        while (sourceEntryTypes.length < targetTypes.length) {
                            sourceEntryTypes.splice(unboundedIndex, 0, typeToReplicate);
                        }
                    }
                }

                // If there's an unpack operator in the target and we have too many source elements,
                // combine them to assign to the unpacked target.
                if (targetUnpackIndex >= 0) {
                    if (sourceEntryTypes.length > targetTypes.length) {
                        const removedEntries = sourceEntryTypes.splice(
                            targetUnpackIndex,
                            sourceEntryTypes.length - targetTypes.length + 1
                        );
                        let combinedTypes = combineTypes(removedEntries);
                        if (target.nodeType === ParseNodeType.List) {
                            combinedTypes = this.stripLiteralValue(combinedTypes);
                        }
                        sourceEntryTypes.splice(targetUnpackIndex, 0, combinedTypes);
                    } else if (sourceEntryTypes.length === targetTypes.length - 1) {
                        sourceEntryTypes.splice(targetUnpackIndex, 0, NeverType.createNever());
                    }
                }

                sourceEntryTypes.forEach((type, targetIndex) => {
                    if (targetIndex < targetTypes.length) {
                        targetTypes[targetIndex].push(type);
                    }
                });

                // Have we accounted for all of the targets and sources? If not, we have a size mismatch.
                if (sourceEntryTypes.length !== targetExpressions.length) {
                    const expectedEntryCount =
                        unpackIndex >= 0 ? targetExpressions.length - 1 : targetExpressions.length;
                    const subDiag = diagAddendum.createAddendum();
                    subDiag.addMessage(
                        (target.nodeType === ParseNodeType.List
                            ? Localizer.DiagnosticAddendum.listAssignmentMismatch()
                            : Localizer.DiagnosticAddendum.tupleAssignmentMismatch()
                        ).format({
                            type: this.printType(subtype),
                        })
                    );
                    subDiag.createAddendum().addMessage(
                        Localizer.DiagnosticAddendum.tupleSizeMismatch().format({
                            expected: expectedEntryCount,
                            received: sourceEntryTypes.length,
                        })
                    );
                }
            } else {
                // The assigned expression isn't a tuple, so it had better
                // be some iterable type.
                const iterableType =
                    this.getTypeOfIterator(
                        { type: subtype, isIncomplete: isTypeIncomplete },
                        /* isAsync */ false,
                        srcExpr
                    )?.type ?? UnknownType.create();
                for (let index = 0; index < targetExpressions.length; index++) {
                    targetTypes[index].push(addConditionToType(iterableType, getTypeCondition(subtype)));
                }
            }
        });

        if (!diagAddendum.isEmpty()) {
            const fileInfo = AnalyzerNodeInfo.getFileInfo(target);
            this.addDiagnostic(
                fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                DiagnosticRule.reportGeneralTypeIssues,
                (target.nodeType === ParseNodeType.List
                    ? Localizer.Diagnostic.listAssignmentMismatch()
                    : Localizer.Diagnostic.tupleAssignmentMismatch()
                ).format({
                    type: this.printType(type),
                }) + diagAddendum.getString(),
                target
            );
        }

        // Assign the resulting types to the individual names in the tuple
        // or list target expression.
        targetExpressions.forEach((expr, index) => {
            const typeList = targetTypes[index];
            const targetType = typeList.length === 0 ? UnknownType.create() : combineTypes(typeList);

            this.assignTypeToExpression(expr, targetType, isTypeIncomplete, srcExpr, /* ignoreEmptyContainers */ true);
        });

        this.writeTypeCache(target, type, EvaluatorFlags.None, isTypeIncomplete);
    }

    // Replaces all of the top-level TypeVars (as opposed to TypeVars
    // used as type arguments in other types) with their concrete form.
    // If conditionFilter is specified and the TypeVar is a constrained
    // TypeVar, only the conditions that match the filter will be included.
    makeTopLevelTypeVarsConcrete(type: Type, conditionFilter?: TypeCondition[]): Type {
        return mapSubtypes(type, (subtype) => {
            if (isParamSpec(subtype)) {
                if (subtype.paramSpecAccess === 'args') {
                    if (
                        this._tupleClassType &&
                        isInstantiableClass(this._tupleClassType) &&
                        this._objectType &&
                        isClassInstance(this._objectType)
                    ) {
                        return ClassType.cloneAsInstance(
                            specializeTupleClass(this._tupleClassType, [{ type: this._objectType, isUnbounded: true }])
                        );
                    }

                    return UnknownType.create();
                } else if (subtype.paramSpecAccess === 'kwargs') {
                    if (
                        this._dictClassType &&
                        isInstantiableClass(this._dictClassType) &&
                        this._strClassType &&
                        isInstantiableClass(this._strClassType) &&
                        this._objectType &&
                        isClassInstance(this._objectType)
                    ) {
                        return ClassType.cloneAsInstance(
                            ClassType.cloneForSpecialization(
                                this._dictClassType,
                                [convertToInstance(this._strClassType), this._objectType],
                                /* isTypeArgumentExplicit */ true
                            )
                        );
                    }

                    return UnknownType.create();
                }
            }

            // If this is a TypeVarTuple *Ts, convert it to an unpacked tuple
            // *tuple[*Ts].
            if (isVariadicTypeVar(subtype)) {
                if (this._tupleClassType && isInstantiableClass(this._tupleClassType)) {
                    return convertToInstance(
                        specializeTupleClass(
                            this._tupleClassType,
                            [{ type: subtype, isUnbounded: false }],
                            /* isTypeArgumentExplicit */ true,
                            /* isUnpackedTuple */ true
                        )
                    );
                }
            }

            if (isTypeVar(subtype) && !subtype.details.recursiveTypeAliasName) {
                if (subtype.details.boundType) {
                    const boundType = TypeBase.isInstantiable(subtype)
                        ? convertToInstantiable(subtype.details.boundType)
                        : subtype.details.boundType;

                    return subtype.details.isSynthesized
                        ? boundType
                        : addConditionToType(boundType, [
                              {
                                  typeVarName: TypeVarType.getNameWithScope(subtype),
                                  constraintIndex: 0,
                                  isConstrainedTypeVar: false,
                              },
                          ]);
                }

                // If this is a recursive type alias placeholder
                // that hasn't yet been resolved, return it as is.
                if (subtype.details.recursiveTypeAliasName) {
                    return subtype;
                }

                if (subtype.details.constraints.length > 0) {
                    const typesToCombine: Type[] = [];

                    // Expand the list of constrained subtypes, filtering out any that are
                    // disallowed by the conditionFilter.
                    subtype.details.constraints.forEach((constraintType, constraintIndex) => {
                        if (conditionFilter) {
                            const typeVarName = TypeVarType.getNameWithScope(subtype);
                            const applicableConstraint = conditionFilter.find(
                                (filter) => filter.typeVarName === typeVarName
                            );

                            // If this type variable is being constrained to a single index,
                            // don't include the other indices.
                            if (applicableConstraint && applicableConstraint.constraintIndex !== constraintIndex) {
                                return;
                            }
                        }

                        if (TypeBase.isInstantiable(subtype)) {
                            constraintType = convertToInstantiable(constraintType);
                        }

                        typesToCombine.push(
                            addConditionToType(constraintType, [
                                {
                                    typeVarName: TypeVarType.getNameWithScope(subtype),
                                    constraintIndex,
                                    isConstrainedTypeVar: true,
                                },
                            ])
                        );
                    });

                    return combineTypes(typesToCombine);
                }

                if (subtype.details.isExemptFromBoundCheck) {
                    return AnyType.create();
                }

                // Convert to an "object" or "type" instance depending on whether
                // it's instantiable.
                if (TypeBase.isInstantiable(subtype)) {
                    if (this._typeClassType && isInstantiableClass(this._typeClassType)) {
                        return subtype.details.isSynthesized
                            ? this._typeClassType
                            : addConditionToType(ClassType.cloneAsInstance(this._typeClassType), [
                                  {
                                      typeVarName: TypeVarType.getNameWithScope(subtype),
                                      constraintIndex: 0,
                                      isConstrainedTypeVar: false,
                                  },
                              ]);
                    }
                } else if (this._objectType) {
                    return subtype.details.isSynthesized
                        ? this._objectType
                        : addConditionToType(this._objectType, [
                              {
                                  typeVarName: TypeVarType.getNameWithScope(subtype),
                                  constraintIndex: 0,
                                  isConstrainedTypeVar: false,
                              },
                          ]);
                }

                return AnyType.create();
            }

            return subtype;
        });
    }

    // Creates a new type by mapping an existing type (which could be a union)
    // to another type or types. The callback is called for each subtype.
    // Top-level TypeVars are expanded (e.g. a bound TypeVar is expanded to
    // its bound type and a constrained TypeVar is expanded to its individual
    // constrained types). If conditionFilter is specified, conditions that
    // do not match will be ignored.
    mapSubtypesExpandTypeVars(
        type: Type,
        conditionFilter: TypeCondition[] | undefined,
        callback: (expandedSubtype: Type, unexpandedSubtype: Type) => Type | undefined
    ): Type {
        const newSubtypes: Type[] = [];
        let typeChanged = false;

        const expandSubtype = (unexpandedType: Type) => {
            let expandedType = isUnion(unexpandedType)
                ? unexpandedType
                : this.makeTopLevelTypeVarsConcrete(unexpandedType);

            expandedType = transformPossibleRecursiveTypeAlias(expandedType);

            doForEachSubtype(expandedType, (subtype) => {
                if (conditionFilter) {
                    if (!TypeCondition.isCompatible(getTypeCondition(subtype), conditionFilter)) {
                        return undefined;
                    }
                }

                let transformedType = callback(subtype, unexpandedType);
                if (transformedType !== unexpandedType) {
                    typeChanged = true;
                }
                if (transformedType) {
                    // Apply the type condition if it's associated with a constrained TypeVar.
                    const typeCondition = getTypeCondition(subtype)?.filter(
                        (condition) => condition.isConstrainedTypeVar
                    );
                    if (typeCondition && typeCondition.length > 0) {
                        transformedType = addConditionToType(transformedType, typeCondition);
                    }

                    newSubtypes.push(transformedType);
                }
                return undefined;
            });
        };

        if (isUnion(type)) {
            type.subtypes.forEach((subtype) => {
                expandSubtype(subtype);
            });
        } else {
            expandSubtype(type);
        }

        if (!typeChanged) {
            return type;
        }

        const newType = combineTypes(newSubtypes);

        // Do our best to retain type aliases.
        if (newType.category === TypeCategory.Union) {
            UnionType.addTypeAliasSource(newType, type);
        }
        return newType;
    }

    markNamesAccessed(node: ParseNode, names: string[]) {
        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
        const scope = ScopeUtils.getScopeForNode(node);

        if (scope) {
            names.forEach((symbolName) => {
                const symbolInScope = scope.lookUpSymbolRecursive(symbolName);
                if (symbolInScope) {
                    this.setSymbolAccessed(fileInfo, symbolInScope.symbol, node);
                }
            });
        }
    }

    assignTypeToExpression(
        target: ExpressionNode,
        type: Type,
        isTypeIncomplete: boolean,
        srcExpr: ExpressionNode,
        ignoreEmptyContainers = false,
        allowAssignmentToFinalVar = false,
        expectedTypeDiagAddendum?: DiagnosticAddendum
    ) {
        // Is the source expression a TypeVar() call?
        if (isTypeVar(type)) {
            if (srcExpr && srcExpr.nodeType === ParseNodeType.Call) {
                const callType = this.getTypeOfExpression(srcExpr.leftExpression, EvaluatorFlags.DoNotSpecialize).type;
                if (
                    isInstantiableClass(callType) &&
                    (ClassType.isBuiltIn(callType, 'TypeVar') ||
                        ClassType.isBuiltIn(callType, 'TypeVarTuple') ||
                        ClassType.isBuiltIn(callType, 'ParamSpec'))
                ) {
                    if (target.nodeType !== ParseNodeType.Name || target.value !== type.details.name) {
                        this.addError(
                            type.details.isParamSpec
                                ? Localizer.Diagnostic.paramSpecAssignedName().format({
                                      name: TypeVarType.getReadableName(type),
                                  })
                                : Localizer.Diagnostic.typeVarAssignedName().format({
                                      name: TypeVarType.getReadableName(type),
                                  }),
                            target
                        );
                    }
                }
            }
        }

        // If the type was partially unbound, an error will have already been logged.
        // Remove the unbound before assigning to the target expression so the unbound
        // error doesn't propagate.
        type = removeUnbound(type);

        switch (target.nodeType) {
            case ParseNodeType.Name: {
                this.assignTypeToNameNode(
                    target,
                    type,
                    isTypeIncomplete,
                    ignoreEmptyContainers,
                    srcExpr,
                    allowAssignmentToFinalVar,
                    expectedTypeDiagAddendum
                );
                break;
            }

            case ParseNodeType.MemberAccess: {
                this.assignTypeToMemberAccessNode(target, type, isTypeIncomplete, srcExpr, expectedTypeDiagAddendum);
                break;
            }

            case ParseNodeType.Index: {
                const baseTypeResult = this.getTypeOfExpression(target.baseExpression, EvaluatorFlags.DoNotSpecialize);

                this.getTypeOfIndexWithBaseType(
                    target,
                    baseTypeResult,
                    {
                        method: 'set',
                        setType: type,
                        setErrorNode: srcExpr,
                        setExpectedTypeDiag: expectedTypeDiagAddendum,
                    },
                    EvaluatorFlags.None
                );

                this.writeTypeCache(target, type, EvaluatorFlags.None, isTypeIncomplete);
                break;
            }

            case ParseNodeType.List:
            case ParseNodeType.Tuple: {
                this.assignTypeToTupleOrListNode(target, type, isTypeIncomplete, srcExpr);
                break;
            }

            case ParseNodeType.TypeAnnotation: {
                const annotationType: Type | undefined = this.getTypeOfAnnotation(target.typeAnnotation, {
                    isVariableAnnotation: true,
                    allowFinal: ParseTreeUtils.isFinalAllowedForAssignmentTarget(target.valueExpression),
                    allowClassVar: ParseTreeUtils.isClassVarAllowedForAssignmentTarget(target.valueExpression),
                });

                // Handle a bare "Final" or "ClassVar" in a special manner.
                const isBareFinalOrClassVar =
                    isClassInstance(annotationType) &&
                    (ClassType.isBuiltIn(annotationType, 'Final') || ClassType.isBuiltIn(annotationType, 'ClassVar'));

                if (!isBareFinalOrClassVar) {
                    const isTypeAliasAnnotation =
                        isClassInstance(annotationType) && ClassType.isBuiltIn(annotationType, 'TypeAlias');

                    if (!isTypeAliasAnnotation) {
                        if (this.assignType(annotationType, type)) {
                            // Don't attempt to narrow based on the annotated type if the type
                            // is a enum because the annotated type in an enum doesn't reflect
                            // the type of the symbol.
                            if (!isClassInstance(type) || !ClassType.isEnumClass(type)) {
                                type = this.narrowTypeBasedOnAssignment(annotationType, type);
                            }
                        }
                    }
                }

                this.assignTypeToExpression(
                    target.valueExpression,
                    type,
                    /* isIncomplete */ false,
                    srcExpr,
                    ignoreEmptyContainers,
                    allowAssignmentToFinalVar,
                    expectedTypeDiagAddendum
                );
                break;
            }

            case ParseNodeType.Unpack: {
                if (target.expression.nodeType === ParseNodeType.Name) {
                    this.assignTypeToNameNode(
                        target.expression,
                        this.getBuiltInObject(target.expression, 'list', [type]),
                        /* isIncomplete */ false,
                        ignoreEmptyContainers,
                        srcExpr
                    );
                }
                break;
            }

            case ParseNodeType.Error: {
                // Evaluate the child expression as best we can so the
                // type information is cached for the completion handler.
                if (target.child) {
                    this.suppressDiagnostics(target.child, () => {
                        this.getTypeOfExpression(target.child!);
                    });
                }
                break;
            }

            default: {
                this.addError(Localizer.Diagnostic.assignmentTargetExpr(), target);
                break;
            }
        }
    }

    verifyRaiseExceptionType(node: RaiseNode) {
        const baseExceptionType = this.getBuiltInType(node, 'BaseException');

        if (node.typeExpression) {
            const exceptionType = this.getTypeOfExpression(node.typeExpression).type;

            // Validate that the argument of "raise" is an exception object or class.
            // If it is a class, validate that the class's constructor accepts zero
            // arguments.
            if (exceptionType && baseExceptionType && isInstantiableClass(baseExceptionType)) {
                const diagAddendum = new DiagnosticAddendum();

                doForEachSubtype(exceptionType, (subtype) => {
                    const concreteSubtype = this.makeTopLevelTypeVarsConcrete(subtype);

                    if (!isAnyOrUnknown(concreteSubtype)) {
                        if (isInstantiableClass(concreteSubtype) && concreteSubtype.literalValue === undefined) {
                            if (
                                !derivesFromClassRecursive(
                                    concreteSubtype,
                                    baseExceptionType,
                                    /* ignoreUnknown */ false
                                )
                            ) {
                                diagAddendum.addMessage(
                                    Localizer.Diagnostic.exceptionTypeIncorrect().format({
                                        type: this.printType(subtype),
                                    })
                                );
                            } else {
                                let callResult: CallResult | undefined;
                                this.suppressDiagnostics(node.typeExpression!, () => {
                                    callResult = this.validateConstructorArguments(
                                        node.typeExpression!,
                                        [],
                                        concreteSubtype,
                                        /* skipUnknownArgCheck */ false,
                                        /* expectedType */ undefined
                                    );
                                });

                                if (callResult && callResult.argumentErrors) {
                                    diagAddendum.addMessage(
                                        Localizer.Diagnostic.exceptionTypeNotInstantiable().format({
                                            type: this.printType(subtype),
                                        })
                                    );
                                }
                            }
                        } else if (isClassInstance(concreteSubtype)) {
                            if (
                                !derivesFromClassRecursive(
                                    ClassType.cloneAsInstantiable(concreteSubtype),
                                    baseExceptionType,
                                    /* ignoreUnknown */ false
                                )
                            ) {
                                diagAddendum.addMessage(
                                    Localizer.Diagnostic.exceptionTypeIncorrect().format({
                                        type: this.printType(subtype),
                                    })
                                );
                            }
                        } else {
                            diagAddendum.addMessage(
                                Localizer.Diagnostic.exceptionTypeIncorrect().format({
                                    type: this.printType(subtype),
                                })
                            );
                        }
                    }
                });

                if (!diagAddendum.isEmpty()) {
                    const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
                    this.addDiagnostic(
                        fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                        DiagnosticRule.reportGeneralTypeIssues,
                        Localizer.Diagnostic.expectedExceptionClass() + diagAddendum.getString(),
                        node.typeExpression
                    );
                }
            }
        }
    }

    verifyDeleteExpression(node: ExpressionNode) {
        switch (node.nodeType) {
            case ParseNodeType.Name: {
                // Get the type to evaluate whether it's bound
                // and to mark it accessed.
                this.getTypeOfExpression(node);
                break;
            }

            case ParseNodeType.MemberAccess: {
                const baseTypeResult = this.getTypeOfExpression(node.leftExpression, EvaluatorFlags.DoNotSpecialize);
                const memberType = this.getTypeOfMemberAccessWithBaseType(
                    node,
                    baseTypeResult,
                    { method: 'del' },
                    EvaluatorFlags.None
                );
                this.writeTypeCache(node.memberName, memberType.type, EvaluatorFlags.None, /* isIncomplete */ false);
                this.writeTypeCache(node, memberType.type, EvaluatorFlags.None, /* isIncomplete */ false);
                break;
            }

            case ParseNodeType.Index: {
                const baseTypeResult = this.getTypeOfExpression(node.baseExpression, EvaluatorFlags.DoNotSpecialize);
                this.getTypeOfIndexWithBaseType(node, baseTypeResult, { method: 'del' }, EvaluatorFlags.None);
                this.writeTypeCache(node, UnboundType.create(), EvaluatorFlags.None, /* isIncomplete */ false);
                break;
            }

            case ParseNodeType.Tuple: {
                node.expressions.forEach((expr) => {
                    this.verifyDeleteExpression(expr);
                });
                break;
            }

            case ParseNodeType.Error: {
                // Evaluate the child expression as best we can so the
                // type information is cached for the completion handler.
                if (node.child) {
                    this.suppressDiagnostics(node.child, () => {
                        this.getTypeOfExpression(node.child!);
                    });
                }
                break;
            }

            default: {
                const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
                this.addDiagnostic(
                    fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                    DiagnosticRule.reportGeneralTypeIssues,
                    Localizer.Diagnostic.delTargetExpr(),
                    node
                );
                break;
            }
        }
    }

    setSymbolAccessed(fileInfo: AnalyzerFileInfo, symbol: Symbol, node: ParseNode) {
        if (!this._speculativeTypeTracker.isSpeculative(node)) {
            fileInfo.accessedSymbolSet.add(symbol.id);
        }
    }

    getReturnTypeFromGenerator(type: Type): Type | undefined {
        if (isAnyOrUnknown(type)) {
            return type;
        }

        if (isClassInstance(type)) {
            // Is this a Generator? If so, return the third
            // type argument, which is the await response type.
            if (ClassType.isBuiltIn(type, 'Generator')) {
                const typeArgs = type.typeArguments;
                if (typeArgs && typeArgs.length >= 3) {
                    return typeArgs[2];
                }
            }
        }

        return undefined;
    }

    getSpecializedReturnType(
        objType: ClassType,
        memberName: string,
        argList: FunctionArgument[],
        errorNode: ExpressionNode | undefined,
        bindToClass?: ClassType
    ) {
        const classMember = lookUpObjectMember(objType, memberName, ClassMemberLookupFlags.SkipInstanceVariables);
        if (!classMember) {
            return undefined;
        }

        const memberTypeResult = this.getTypeOfMemberInternal(classMember, objType);
        if (!memberTypeResult) {
            return undefined;
        }

        const memberType = memberTypeResult.type;
        if (isAnyOrUnknown(memberType)) {
            return memberType;
        }

        if (isFunction(memberType) || isOverloadedFunction(memberType)) {
            const methodType = this.bindFunctionToClassOrObject(
                bindToClass || objType,
                memberType,
                classMember && isInstantiableClass(classMember.classType) ? classMember.classType : undefined,
                errorNode,
                /* recursionCount */ undefined,
                /* treatConstructorAsClassMember */ false,
                /* firstParamType */ bindToClass
            );
            if (methodType) {
                if (isOverloadedFunction(methodType)) {
                    if (errorNode) {
                        const bestOverload = this.getBestOverloadForArguments(errorNode, methodType, argList);
                        if (bestOverload) {
                            return this.getFunctionEffectiveReturnType(bestOverload);
                        }
                    }
                } else {
                    return this.getFunctionEffectiveReturnType(methodType);
                }
            }
        }

        return undefined;
    }

    getTypeOfName(node: NameNode, flags: EvaluatorFlags): TypeResult {
        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
        const name = node.value;
        let symbol: Symbol | undefined;
        let type: Type | undefined;
        let isIncomplete = false;
        const allowForwardReferences = (flags & EvaluatorFlags.AllowForwardReferences) !== 0 || fileInfo.isStubFile;

        // Does this name refer to a PEP 695-style type parameter?
        const typeParamSymbol = AnalyzerNodeInfo.getTypeParameterSymbol(node);
        if (typeParamSymbol) {
            symbol = typeParamSymbol;
            type = this.getDeclaredTypeOfSymbol(typeParamSymbol) ?? UnknownType.create();
            this.setSymbolAccessed(fileInfo, symbol, node);
        } else {
            // Look for the scope that contains the value definition and
            // see if it has a declared type.
            let symbolWithScope = this.lookUpSymbolRecursive(
                node,
                name,
                !allowForwardReferences,
                allowForwardReferences && (flags & EvaluatorFlags.ExpectingTypeAnnotation) !== 0
            );

            if (!symbolWithScope) {
                // If the node is part of a "from X import Y as Z" statement and the node
                // is the "Y" (non-aliased) name, we need to look up the alias symbol
                // since the non-aliased name is not in the symbol table.
                const alias = this.getAliasFromImport(node);
                if (alias) {
                    symbolWithScope = this.lookUpSymbolRecursive(
                        alias,
                        alias.value,
                        !allowForwardReferences,
                        allowForwardReferences && (flags & EvaluatorFlags.ExpectingTypeAnnotation) !== 0
                    );
                }
            }
            if (symbolWithScope) {
                let useCodeFlowAnalysis = !allowForwardReferences;

                // If the symbol is implicitly imported from the builtin
                // scope, there's no need to use code flow analysis.
                if (symbolWithScope.scope.type === ScopeType.Builtin) {
                    useCodeFlowAnalysis = false;
                }

                symbol = symbolWithScope.symbol;
                this.setSymbolAccessed(fileInfo, symbol, node);

                // If we're not supposed to be analyzing this function, skip the remaining work
                // to determine the name's type. Simply evaluate its type as Any.
                if (!fileInfo.diagnosticRuleSet.analyzeUnannotatedFunctions) {
                    const containingFunction = ParseTreeUtils.getEnclosingFunction(node);
                    if (containingFunction && ParseTreeUtils.isUnannotatedFunction(containingFunction)) {
                        return {
                            type: AnyType.create(),
                            isIncomplete: false,
                        };
                    }
                }

                // Get the effective type (either the declared type or the inferred type).
                // If we're using code flow analysis, pass the usage node so we consider
                // only the assignment nodes that are reachable from this usage.
                const effectiveTypeInfo = this.getEffectiveTypeOfSymbolForUsage(
                    symbol,
                    useCodeFlowAnalysis ? node : undefined
                );
                let effectiveType = transformPossibleRecursiveTypeAlias(effectiveTypeInfo.type);

                if (effectiveTypeInfo.isIncomplete) {
                    if (isUnbound(effectiveType)) {
                        effectiveType = UnknownType.create(/* isIncomplete */ true);
                    }
                    isIncomplete = true;
                }

                if (effectiveTypeInfo.isRecursiveDefinition && this.isNodeReachable(node)) {
                    this.addDiagnostic(
                        AnalyzerNodeInfo.getFileInfo(node).diagnosticRuleSet.reportGeneralTypeIssues,
                        DiagnosticRule.reportGeneralTypeIssues,
                        Localizer.Diagnostic.recursiveDefinition().format({ name }),
                        node
                    );
                }

                const isSpecialBuiltIn =
                    !!effectiveType && isInstantiableClass(effectiveType) && ClassType.isSpecialBuiltIn(effectiveType);

                type = effectiveType;
                if (useCodeFlowAnalysis && !isSpecialBuiltIn) {
                    // See if code flow analysis can tell us anything more about the type.
                    // If the symbol is declared outside of our execution scope, use its effective
                    // type. If it's declared inside our execution scope, it generally starts
                    // as unbound at the start of the code flow.
                    let typeAtStart = effectiveType;
                    if (!symbolWithScope.isBeyondExecutionScope && symbol.isInitiallyUnbound()) {
                        typeAtStart = UnboundType.create();

                        // Is this a module-level scope? If so, see if it's an alias of a builtin.
                        if (symbolWithScope.scope.type === ScopeType.Module) {
                            assert(symbolWithScope.scope.parent);
                            const builtInSymbol = symbolWithScope.scope.parent.lookUpSymbol(name);
                            if (builtInSymbol) {
                                const builtInEffectiveType = this.getEffectiveTypeOfSymbolForUsage(builtInSymbol);
                                typeAtStart = builtInEffectiveType.type;
                            }
                        }
                    }

                    const codeFlowTypeResult = this.getFlowTypeOfReference(
                        node,
                        symbol.id,
                        typeAtStart,
                        /* startNode */ undefined,
                        {
                            skipConditionalNarrowing: (flags & EvaluatorFlags.ExpectingTypeAnnotation) !== 0,
                        }
                    );
                    if (codeFlowTypeResult.type) {
                        type = codeFlowTypeResult.type;
                    }

                    if (codeFlowTypeResult.isIncomplete) {
                        isIncomplete = true;
                    }

                    if (!codeFlowTypeResult.type && symbolWithScope.isBeyondExecutionScope) {
                        const outerScopeTypeResult = this.getCodeFlowTypeForCapturedVariable(
                            node,
                            symbolWithScope,
                            effectiveType
                        );

                        if (outerScopeTypeResult?.type) {
                            type = outerScopeTypeResult.type;
                        }

                        if (outerScopeTypeResult?.isIncomplete) {
                            isIncomplete = true;
                        }
                    }
                }

                // Detect, report, and fill in missing type arguments if appropriate.
                type = this.reportMissingTypeArguments(node, type, flags);

                if ((flags & EvaluatorFlags.ExpectingTypeAnnotation) !== 0) {
                    // Verify that the name does not refer to a (non type alias) variable.
                    if (effectiveTypeInfo.includesVariableDecl && !type.typeAliasInfo) {
                        let isAllowedTypeForVariable = isTypeVar(type) || isTypeAliasPlaceholder(type);
                        if (isClass(type) && !type.includeSubclasses) {
                            // This check exempts class types that are created by calling
                            // NewType, NamedTuple, and by invoking a metaclass directly.
                            isAllowedTypeForVariable = true;
                        }

                        // Disable for assignments in the typings.pyi file, since it defines special forms.
                        if (!isAllowedTypeForVariable && !fileInfo.isTypingStubFile) {
                            // This might be a union that was previously a type alias
                            // but was reconstituted in such a way that we lost the
                            // typeAliasInfo. Avoid the false positive error by suppressing
                            // the error when it looks like a plausible type alias type.
                            if (
                                effectiveTypeInfo.includesIllegalTypeAliasDecl ||
                                !TypeBase.isInstantiable(type) ||
                                (flags & EvaluatorFlags.DoNotSpecialize) !== 0
                            ) {
                                this.addDiagnostic(
                                    fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                                    DiagnosticRule.reportGeneralTypeIssues,
                                    Localizer.Diagnostic.typeAnnotationVariable(),
                                    node
                                );
                                type = UnknownType.create();
                            }
                        }
                    }
                }
            } else {
                // Handle the special case of "reveal_type" and "reveal_locals".
                if (name === 'reveal_type' || name === 'reveal_locals') {
                    type = AnyType.create();
                } else {
                    this.addDiagnostic(
                        fileInfo.diagnosticRuleSet.reportUndefinedVariable,
                        DiagnosticRule.reportUndefinedVariable,
                        Localizer.Diagnostic.symbolIsUndefined().format({ name }),
                        node
                    );

                    type = UnknownType.create();
                }
            }
        }

        if (isParamSpec(type)) {
            if (flags & EvaluatorFlags.ParamSpecDisallowed) {
                this.addError(Localizer.Diagnostic.paramSpecContext(), node);
                type = UnknownType.create();
            }
        }

        if (
            isTypeVar(type) &&
            !type.details.isParamSpec &&
            !type.isVariadicInUnion &&
            (flags & EvaluatorFlags.ExpectingType) === 0 &&
            type.details.name === name
        ) {
            // Handle the special case of a PEP 604 union. These can appear within
            // an implied type alias where we are not expecting a type.
            const isPep604Union =
                node.parent?.nodeType === ParseNodeType.BinaryOperation &&
                node.parent.operator === OperatorType.BitwiseOr;

            if (!isPep604Union) {
                // A TypeVar in contexts where we're not expecting a type is
                // simply a TypeVar or TypeVarTuple object.
                const typeVarType = type.details.isVariadic
                    ? this.getTypingType(node, 'TypeVarTuple')
                    : this.getTypingType(node, 'TypeVar');
                if (typeVarType && isInstantiableClass(typeVarType)) {
                    type = ClassType.cloneAsInstance(typeVarType);
                } else {
                    type = UnknownType.create();
                }
            }
        }

        if ((flags & EvaluatorFlags.ExpectingType) !== 0) {
            if ((flags & EvaluatorFlags.AllowGenericClassType) === 0) {
                if (isInstantiableClass(type) && ClassType.isBuiltIn(type, 'Generic')) {
                    this.addDiagnostic(
                        AnalyzerNodeInfo.getFileInfo(node).diagnosticRuleSet.reportGeneralTypeIssues,
                        DiagnosticRule.reportGeneralTypeIssues,
                        Localizer.Diagnostic.genericNotAllowed(),
                        node
                    );
                }
            }
        }

        if (isTypeVar(type) && !type.details.isSynthesized) {
            type = this.validateTypeVarUsage(node, type, flags);
        }

        return { type, isIncomplete };
    }

    // Handles the case where a variable or parameter is defined in an outer
    // scope and captured by an inner scope (either a function or a lambda).
    getCodeFlowTypeForCapturedVariable(
        node: NameNode,
        symbolWithScope: SymbolWithScope,
        effectiveType: Type
    ): FlowNodeTypeResult | undefined {
        // This function applies only to variables and parameters, not to other
        // types of symbols.
        if (
            !symbolWithScope.symbol
                .getDeclarations()
                .every((decl) => decl.type === DeclarationType.Variable || decl.type === DeclarationType.Parameter)
        ) {
            return undefined;
        }

        // If the symbol is a variable captured by an inner function
        // or lambda, see if we can infer the type from the outer scope.
        const scopeHierarchy = ScopeUtils.getScopeHierarchy(node, symbolWithScope.scope);

        // Handle the case where all of the nested scopes are functions,
        // lambdas and modules. Don't allow other types of scopes.
        if (
            scopeHierarchy &&
            scopeHierarchy.length >= 2 &&
            scopeHierarchy.every((s) => s.type === ScopeType.Function || s.type === ScopeType.Module)
        ) {
            // Find the parse node associated with the scope that is just inside of the
            // scope that declares the captured variable.
            const innerScopeNode = ScopeUtils.findTopNodeInScope(node, scopeHierarchy[scopeHierarchy.length - 2]);
            if (
                innerScopeNode &&
                (innerScopeNode.nodeType === ParseNodeType.Function || innerScopeNode.nodeType === ParseNodeType.Lambda)
            ) {
                const innerScopeCodeFlowNode = AnalyzerNodeInfo.getFlowNode(innerScopeNode);
                if (innerScopeCodeFlowNode) {
                    // See if any of the assignments of the symbol are reachable
                    // from this node. If so, we cannot apply any narrowing because
                    // the type could change after the capture.
                    if (
                        symbolWithScope.symbol.getDeclarations().every((decl) => {
                            // Parameter declarations always start life at the beginning
                            // of the execution scope, so they are always safe to narrow.
                            if (decl.type === DeclarationType.Parameter) {
                                return true;
                            }

                            const declCodeFlowNode = AnalyzerNodeInfo.getFlowNode(decl.node);
                            if (!declCodeFlowNode) {
                                return false;
                            }

                            return !this._codeFlowEngine.isFlowNodeReachable(
                                declCodeFlowNode,
                                innerScopeCodeFlowNode,
                                /* ignoreNoReturn */ true
                            );
                        })
                    ) {
                        return this.getFlowTypeOfReference(
                            node,
                            symbolWithScope.symbol.id,
                            effectiveType,
                            innerScopeNode
                        );
                    }
                }
            }
        }

        return undefined;
    }

    // Validates that a TypeVar is valid in this context. If so, it clones it
    // and provides a scope ID defined by its containing scope (class, function
    // or type alias). If not, it emits errors indicating why the TypeVar
    // cannot be used in this location.
    validateTypeVarUsage(node: ExpressionNode, type: TypeVarType, flags: EvaluatorFlags) {
        if (TypeBase.isInstantiable(type) && !type.scopeId && !isTypeAliasPlaceholder(type)) {
            const scopedTypeVarInfo = this.findScopedTypeVar(node, type);
            type = scopedTypeVarInfo.type;

            if ((flags & EvaluatorFlags.DisallowTypeVarsWithScopeId) !== 0 && type.scopeId !== undefined) {
                if (!type.details.isSynthesized && !type.details.isParamSpec) {
                    // This TypeVar already has a scope ID assigned to it. See if it
                    // originates from type parameter syntax. If so, allow it.
                    if (type.details.isTypeParamSyntax) {
                        return type;
                    }

                    // If this type variable expression is used within a generic class,
                    // function, or type alias that uses type parameter syntax, there is
                    // no need to report an error here.
                    const typeVarScopeNode = ParseTreeUtils.getTypeVarScopeNode(node);
                    if (
                        typeVarScopeNode &&
                        typeVarScopeNode.typeParameters &&
                        !typeVarScopeNode.typeParameters.parameters.some((t) => t.name === node)
                    ) {
                        return type;
                    }

                    this.addDiagnostic(
                        AnalyzerNodeInfo.getFileInfo(node).diagnosticRuleSet.reportGeneralTypeIssues,
                        DiagnosticRule.reportGeneralTypeIssues,
                        Localizer.Diagnostic.typeVarUsedByOuterScope().format({ name: type.details.name }),
                        node
                    );
                }
            } else if ((flags & EvaluatorFlags.AssociateTypeVarsWithCurrentScope) !== 0) {
                if (type.scopeId === undefined) {
                    if (!scopedTypeVarInfo.foundInterveningClass) {
                        let enclosingScope = ParseTreeUtils.getEnclosingClassOrFunction(node);

                        // Handle P.args and P.kwargs as a special case for inner functions.
                        if (
                            enclosingScope &&
                            node.parent?.nodeType === ParseNodeType.MemberAccess &&
                            node.parent.leftExpression === node
                        ) {
                            const memberName = node.parent.memberName.value;
                            if (memberName === 'args' || memberName === 'kwargs') {
                                const outerFunctionScope = ParseTreeUtils.getEnclosingClassOrFunction(enclosingScope);

                                if (outerFunctionScope?.nodeType === ParseNodeType.Function) {
                                    enclosingScope = outerFunctionScope;
                                } else if (!scopedTypeVarInfo.type.scopeId) {
                                    this.addDiagnostic(
                                        AnalyzerNodeInfo.getFileInfo(node).diagnosticRuleSet.reportGeneralTypeIssues,
                                        DiagnosticRule.reportGeneralTypeIssues,
                                        Localizer.Diagnostic.paramSpecNotUsedByOuterScope().format({
                                            name: type.details.name,
                                        }),
                                        node
                                    );
                                }
                            }
                        }

                        if (enclosingScope) {
                            // If the enclosing scope is using type parameter syntax, traditional
                            // type variables can't be used in this context.
                            if (enclosingScope.typeParameters) {
                                this.addDiagnostic(
                                    AnalyzerNodeInfo.getFileInfo(node).diagnosticRuleSet.reportGeneralTypeIssues,
                                    DiagnosticRule.reportGeneralTypeIssues,
                                    Localizer.Diagnostic.typeParameterNotDeclared().format({
                                        name: type.details.name,
                                        container: enclosingScope.name.value,
                                    }),
                                    node
                                );
                            }

                            type = TypeVarType.cloneForScopeId(
                                type,
                                this.getScopeIdForNode(enclosingScope),
                                enclosingScope.name.value,
                                enclosingScope.nodeType === ParseNodeType.Function
                                    ? TypeVarScopeType.Function
                                    : TypeVarScopeType.Class
                            );
                        } else {
                            fail('AssociateTypeVarsWithCurrentScope flag was set but enclosing scope not found');
                        }
                    } else {
                        this.addDiagnostic(
                            AnalyzerNodeInfo.getFileInfo(node).diagnosticRuleSet.reportGeneralTypeIssues,
                            DiagnosticRule.reportGeneralTypeIssues,
                            Localizer.Diagnostic.typeVarUsedByOuterScope().format({ name: type.details.name }),
                            node
                        );
                    }
                }
            } else if ((flags & EvaluatorFlags.DisallowTypeVarsWithoutScopeId) !== 0) {
                if (
                    (type.scopeId === undefined || scopedTypeVarInfo.foundInterveningClass) &&
                    !type.details.isSynthesized
                ) {
                    const message = isParamSpec(type)
                        ? Localizer.Diagnostic.paramSpecNotUsedByOuterScope()
                        : Localizer.Diagnostic.typeVarNotUsedByOuterScope();
                    this.addDiagnostic(
                        AnalyzerNodeInfo.getFileInfo(node).diagnosticRuleSet.reportGeneralTypeIssues,
                        DiagnosticRule.reportGeneralTypeIssues,
                        message.format({ name: type.details.name }),
                        node
                    );
                }
            }
        }

        // If this type var is variadic, the name refers to the packed form. It
        // must be unpacked in most contexts.
        if (isUnpackedVariadicTypeVar(type)) {
            type = TypeVarType.cloneForPacked(type);
        }

        return type;
    }

    // Determines if the type is a generic class or type alias with missing
    // type arguments. If so, it fills in these type arguments with Unknown
    // and optionally reports an error.
    reportMissingTypeArguments(node: ExpressionNode, type: Type, flags: EvaluatorFlags): Type {
        if ((flags & EvaluatorFlags.DoNotSpecialize) === 0) {
            if (isInstantiableClass(type)) {
                if ((flags & EvaluatorFlags.ExpectingType) !== 0) {
                    if (requiresTypeArguments(type) && !type.typeArguments) {
                        this.addDiagnostic(
                            AnalyzerNodeInfo.getFileInfo(node).diagnosticRuleSet.reportMissingTypeArgument,
                            DiagnosticRule.reportMissingTypeArgument,
                            Localizer.Diagnostic.typeArgsMissingForClass().format({
                                name: type.aliasName || type.details.name,
                            }),
                            node
                        );
                    }
                }
                if (!type.typeArguments) {
                    type = this.createSpecializedClassType(type, /* typeArgs */ undefined, flags, node);
                }
            }

            if (
                (flags & EvaluatorFlags.ExpectingType) !== 0 &&
                type.typeAliasInfo &&
                type.typeAliasInfo.typeParameters &&
                type.typeAliasInfo.typeParameters.length > 0 &&
                !type.typeAliasInfo.typeArguments
            ) {
                let reportMissingTypeArguments = false;
                const defaultTypeArgs: Type[] = [];

                type.typeAliasInfo.typeParameters.forEach((param) => {
                    if (param.details.defaultType) {
                        defaultTypeArgs.push(param.details.defaultType);
                    } else {
                        defaultTypeArgs.push(UnknownType.create());
                        reportMissingTypeArguments = true;
                    }
                });

                const typeVarContext = buildTypeVarContext(
                    type.typeAliasInfo.typeParameters,
                    defaultTypeArgs,
                    type.typeAliasInfo.typeVarScopeId
                );

                if (reportMissingTypeArguments) {
                    this.addDiagnostic(
                        AnalyzerNodeInfo.getFileInfo(node).diagnosticRuleSet.reportMissingTypeArgument,
                        DiagnosticRule.reportMissingTypeArgument,
                        Localizer.Diagnostic.typeArgsMissingForAlias().format({
                            name: type.typeAliasInfo.name,
                        }),
                        node
                    );
                }

                type = TypeBase.cloneForTypeAlias(
                    applySolvedTypeVars(type, typeVarContext, /* unknownIfNotFound */ true),
                    type.typeAliasInfo.name,
                    type.typeAliasInfo.fullName,
                    type.typeAliasInfo.typeVarScopeId,
                    type.typeAliasInfo.typeParameters,
                    defaultTypeArgs
                );
            }
        }

        return type;
    }

    // Creates an ID that identifies this parse node in a way that will
    // not change each time the file is parsed (unless, of course, the
    // file contents change).
    getScopeIdForNode(node: ParseNode): string {
        let name = '';
        if (node.nodeType === ParseNodeType.Class) {
            name = node.name.value;
        } else if (node.nodeType === ParseNodeType.Function) {
            name = node.name.value;
        }

        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
        return `${fileInfo.filePath}.${node.start.toString()}-${name}`;
    }

    // Walks up the parse tree and finds all scopes that can provide
    // a context for a TypeVar and returns the scope ID for each.
    getTypeVarScopesForNode(node: ParseNode): TypeVarScopeId[] {
        const scopeIds: TypeVarScopeId[] = [];

        let curNode: ParseNode | undefined = node;
        while (curNode) {
            curNode = ParseTreeUtils.getTypeVarScopeNode(curNode);
            if (!curNode) {
                break;
            }

            scopeIds.push(this.getScopeIdForNode(curNode));
            curNode = curNode.parent;
        }

        return scopeIds;
    }

    // Walks up the parse tree to find a function, class, or type alias
    // assignment that provides the context for a type variable.
    findScopedTypeVar(node: ExpressionNode, type: TypeVarType): { type: TypeVarType; foundInterveningClass: boolean } {
        let curNode: ParseNode | undefined = node;
        let nestedClassCount = 0;

        assert(TypeBase.isInstantiable(type));

        while (curNode) {
            curNode = ParseTreeUtils.getTypeVarScopeNode(curNode);
            if (!curNode) {
                break;
            }

            let typeParametersForScope: TypeVarType[] | undefined;
            let scopeUsesTypeParameterSyntax = false;

            if (curNode.nodeType === ParseNodeType.Class) {
                const classTypeInfo = this.getTypeOfClass(curNode);
                if (classTypeInfo && !ClassType.isPartiallyEvaluated(classTypeInfo.classType)) {
                    typeParametersForScope = classTypeInfo.classType.details.typeParameters;
                }

                scopeUsesTypeParameterSyntax = !!curNode.typeParameters;
                nestedClassCount++;
            } else if (curNode.nodeType === ParseNodeType.Function) {
                const functionTypeInfo = this.getTypeOfFunction(curNode);
                if (functionTypeInfo) {
                    typeParametersForScope = [];
                    functionTypeInfo.functionType.details.parameters.forEach((param) => {
                        if (param.hasDeclaredType) {
                            addTypeVarsToListIfUnique(
                                typeParametersForScope!,
                                getTypeVarArgumentsRecursive(param.type)
                            );
                        }
                    });
                    if (functionTypeInfo.functionType.details.declaredReturnType) {
                        addTypeVarsToListIfUnique(
                            typeParametersForScope!,
                            getTypeVarArgumentsRecursive(functionTypeInfo.functionType.details.declaredReturnType)
                        );
                    }
                }

                scopeUsesTypeParameterSyntax = !!curNode.typeParameters;
            } else if (curNode.nodeType === ParseNodeType.TypeAlias) {
                scopeUsesTypeParameterSyntax = !!curNode.typeParameters;
            }

            if (typeParametersForScope) {
                const match = typeParametersForScope.find((typeVar) => typeVar.details.name === type.details.name);

                if (match?.scopeId) {
                    // Use the scoped version of the TypeVar rather than the (unscoped) original type.
                    type = TypeVarType.cloneForScopeId(type, match.scopeId, match.scopeName!, match.scopeType!);
                    return { type, foundInterveningClass: nestedClassCount > 1 && !scopeUsesTypeParameterSyntax };
                }
            }

            curNode = curNode.parent;
        }

        // See if this is part of an assignment statement that is defining a type alias.
        curNode = node;
        while (curNode) {
            let leftType: Type | undefined;
            let typeAliasNode: TypeAliasNode | undefined = undefined;

            if (curNode.nodeType === ParseNodeType.TypeAlias) {
                leftType = this.readTypeCache(curNode.name, EvaluatorFlags.None);
                typeAliasNode = curNode;
            } else if (curNode.nodeType === ParseNodeType.Assignment) {
                leftType = this.readTypeCache(curNode.leftExpression, EvaluatorFlags.None);
            }

            if (leftType) {
                // Is this a placeholder that was temporarily written to the cache for
                // purposes of resolving type aliases?
                if (
                    leftType &&
                    isTypeVar(leftType) &&
                    leftType.details.recursiveTypeAliasScopeId &&
                    leftType.details.recursiveTypeAliasName
                ) {
                    // Type alias statements cannot be used with old-style type variables.
                    if (typeAliasNode && !type.details.isTypeParamSyntax) {
                        this.addDiagnostic(
                            AnalyzerNodeInfo.getFileInfo(node).diagnosticRuleSet.reportGeneralTypeIssues,
                            DiagnosticRule.reportGeneralTypeIssues,
                            Localizer.Diagnostic.typeParameterNotDeclared().format({
                                name: type.details.name,
                                container: typeAliasNode.name.value,
                            }),
                            node
                        );
                    }

                    return {
                        type: TypeVarType.cloneForScopeId(
                            type,
                            leftType.details.recursiveTypeAliasScopeId,
                            leftType.details.recursiveTypeAliasName,
                            TypeVarScopeType.TypeAlias
                        ),
                        foundInterveningClass: false,
                    };
                }
            }

            curNode = curNode.parent;
        }

        // Return the original type.
        return { type, foundInterveningClass: false };
    }

    getTypeOfMemberAccess(node: MemberAccessNode, flags: EvaluatorFlags): TypeResult {
        const baseTypeFlags =
            EvaluatorFlags.DoNotSpecialize |
            (flags &
                (EvaluatorFlags.ExpectingTypeAnnotation |
                    EvaluatorFlags.VariableTypeAnnotation |
                    EvaluatorFlags.AllowForwardReferences |
                    EvaluatorFlags.NotParsedByInterpreter |
                    EvaluatorFlags.DisallowTypeVarsWithScopeId |
                    EvaluatorFlags.DisallowTypeVarsWithoutScopeId |
                    EvaluatorFlags.AssociateTypeVarsWithCurrentScope));
        const baseTypeResult = this.getTypeOfExpression(node.leftExpression, baseTypeFlags);

        if (isTypeAliasPlaceholder(baseTypeResult.type)) {
            return {
                type: UnknownType.create(/* isIncomplete */ true),
                isIncomplete: true,
            };
        }

        const typeResult = this.getTypeOfMemberAccessWithBaseType(
            node,
            baseTypeResult,
            { method: 'get' },
            flags | EvaluatorFlags.DoNotSpecialize
        );

        if (isCodeFlowSupportedForReference(node)) {
            // Before performing code flow analysis, update the cache to prevent recursion.
            this.writeTypeCache(node, typeResult.type, flags, /* isIncomplete */ true);
            this.writeTypeCache(node.memberName, typeResult.type, flags, /* isIncomplete */ true);

            // If the type is initially unbound, see if there's a parent class that
            // potentially initialized the value.
            let typeAtStart = typeResult.type;
            let isTypeAtStartIncomplete = !!typeResult.isIncomplete;
            if (isUnbound(typeAtStart)) {
                const baseType = this.makeTopLevelTypeVarsConcrete(baseTypeResult.type);

                let classMemberInfo: ClassMember | undefined;
                if (isInstantiableClass(baseType)) {
                    classMemberInfo = lookUpClassMember(
                        baseType,
                        node.memberName.value,
                        ClassMemberLookupFlags.SkipOriginalClass
                    );
                } else if (isClassInstance(baseType)) {
                    classMemberInfo = lookUpObjectMember(
                        baseType,
                        node.memberName.value,
                        ClassMemberLookupFlags.SkipOriginalClass
                    );
                }

                if (classMemberInfo) {
                    typeAtStart = this.getTypeOfMember(classMemberInfo);
                    isTypeAtStartIncomplete = false;
                }
            }

            // See if we can refine the type based on code flow analysis.
            const codeFlowTypeResult = this.getFlowTypeOfReference(
                node,
                indeterminateSymbolId,
                typeAtStart,
                /* startNode */ undefined,
                {
                    isTypeAtStartIncomplete,
                    skipConditionalNarrowing: (flags & EvaluatorFlags.ExpectingTypeAnnotation) !== 0,
                }
            );

            if (codeFlowTypeResult.type) {
                typeResult.type = codeFlowTypeResult.type;
            }

            if (codeFlowTypeResult.isIncomplete) {
                typeResult.isIncomplete = true;
            }

            // Detect, report, and fill in missing type arguments if appropriate.
            typeResult.type = this.reportMissingTypeArguments(node, typeResult.type, flags);

            this.deleteTypeCacheEntry(node);
            this.deleteTypeCacheEntry(node.memberName);
        }

        if (baseTypeResult.isIncomplete) {
            typeResult.isIncomplete = true;
        }

        // Cache the type information in the member name node.
        this.writeTypeCache(node.memberName, typeResult.type, flags, !!typeResult.isIncomplete);

        return typeResult;
    }

    getTypeOfMemberAccessWithBaseType(
        node: MemberAccessNode,
        baseTypeResult: TypeResult,
        usage: EvaluatorUsage,
        flags: EvaluatorFlags
    ): TypeResult {
        let baseType = baseTypeResult.type;
        const memberName = node.memberName.value;
        let diag = new DiagnosticAddendum();
        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
        let type: Type | undefined;
        let isIncomplete = !!baseTypeResult.isIncomplete;
        let isAsymmetricDescriptor: boolean | undefined;

        // If the base type was incomplete and unbound, don't proceed
        // because false positive errors will be generated.
        if (baseTypeResult.isIncomplete && isUnbound(baseTypeResult.type)) {
            return { type: UnknownType.create(/* isIncomplete */ true), isIncomplete: true };
        }

        // Handle the special case where the expression is an actual
        // UnionType special form.
        if (isUnion(baseType) && TypeBase.isSpecialForm(baseType)) {
            if (this._objectType) {
                baseType = this._objectType;
            }
        }

        const getTypeOfNoneBase = (subtype: NoneType) => {
            if (this._noneType && isInstantiableClass(this._noneType)) {
                if (TypeBase.isInstance(subtype)) {
                    return this.getTypeOfObjectMember(node.memberName, this._noneType, memberName, usage, diag);
                } else {
                    return this.getTypeOfClassMember(node.memberName, this._noneType, memberName, usage, diag);
                }
            }
            return undefined;
        };

        if (isParamSpec(baseType) && baseType.paramSpecAccess) {
            baseType = this.makeTopLevelTypeVarsConcrete(baseType);
        }

        switch (baseType.category) {
            case TypeCategory.Any:
            case TypeCategory.Unknown:
            case TypeCategory.Never: {
                type = baseType;
                break;
            }

            case TypeCategory.TypeVar: {
                if (baseType.details.isParamSpec) {
                    if (memberName === 'args') {
                        const paramNode = ParseTreeUtils.getEnclosingParameter(node);
                        if (!paramNode || paramNode.category !== ParameterCategory.VarArgList) {
                            this.addError(Localizer.Diagnostic.paramSpecArgsUsage(), node);
                            return { type: UnknownType.create(isIncomplete), isIncomplete };
                        }
                        return { type: TypeVarType.cloneForParamSpecAccess(baseType, 'args'), isIncomplete };
                    }

                    if (memberName === 'kwargs') {
                        const paramNode = ParseTreeUtils.getEnclosingParameter(node);
                        if (!paramNode || paramNode.category !== ParameterCategory.VarArgDictionary) {
                            this.addError(Localizer.Diagnostic.paramSpecKwargsUsage(), node);
                            return { type: UnknownType.create(isIncomplete), isIncomplete };
                        }
                        return { type: TypeVarType.cloneForParamSpecAccess(baseType, 'kwargs'), isIncomplete };
                    }

                    if (!isIncomplete) {
                        this.addDiagnostic(
                            fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                            DiagnosticRule.reportGeneralTypeIssues,
                            Localizer.Diagnostic.paramSpecUnknownMember().format({ name: memberName }),
                            node
                        );
                    }
                    return { type: UnknownType.create(isIncomplete), isIncomplete };
                }

                if (flags & EvaluatorFlags.ExpectingType) {
                    if (!isIncomplete) {
                        this.addDiagnostic(
                            AnalyzerNodeInfo.getFileInfo(node).diagnosticRuleSet.reportGeneralTypeIssues,
                            DiagnosticRule.reportGeneralTypeIssues,
                            Localizer.Diagnostic.typeVarNoMember().format({
                                type: this.printType(baseType),
                                name: memberName,
                            }),
                            node.leftExpression
                        );
                    }

                    return { type: UnknownType.create(isIncomplete), isIncomplete };
                }

                if (baseType.details.recursiveTypeAliasName) {
                    return { type: UnknownType.create(/* isIncomplete */ true), isIncomplete: true };
                }

                return this.getTypeOfMemberAccessWithBaseType(
                    node,
                    {
                        type: this.makeTopLevelTypeVarsConcrete(baseType),
                        bindToType: baseType,
                        isIncomplete,
                    },
                    usage,
                    EvaluatorFlags.None
                );
            }

            case TypeCategory.Class: {
                if (TypeBase.isInstantiable(baseType)) {
                    const typeResult = this.getTypeOfClassMember(
                        node.memberName,
                        baseType,
                        memberName,
                        usage,
                        diag,
                        MemberAccessFlags.None,
                        baseTypeResult.bindToType
                    );

                    type = typeResult?.type;
                    if (typeResult?.isIncomplete) {
                        isIncomplete = true;
                    }

                    if (typeResult?.isAsymmetricDescriptor) {
                        isAsymmetricDescriptor = true;
                    }
                } else {
                    // Handle the special case of 'name' and 'value' members within an enum.
                    const enumMemberResult = getTypeOfEnumMember(this, node, baseType, memberName, isIncomplete);
                    if (enumMemberResult) {
                        return enumMemberResult;
                    }

                    const typeResult = this.getTypeOfObjectMember(
                        node.memberName,
                        baseType,
                        memberName,
                        usage,
                        diag,
                        /* memberAccessFlags */ undefined,
                        baseTypeResult.bindToType
                    );

                    if (typeResult) {
                        type = addConditionToType(typeResult.type, getTypeCondition(baseType));
                    }

                    if (typeResult?.isIncomplete) {
                        isIncomplete = true;
                    }

                    if (typeResult?.isAsymmetricDescriptor) {
                        isAsymmetricDescriptor = true;
                    }
                }
                break;
            }

            case TypeCategory.Module: {
                const symbol = ModuleType.getField(baseType, memberName);
                if (symbol && !symbol.isExternallyHidden()) {
                    if (usage.method === 'get') {
                        this.setSymbolAccessed(AnalyzerNodeInfo.getFileInfo(node), symbol, node.memberName);
                    }

                    type = this.getEffectiveTypeOfSymbolForUsage(
                        symbol,
                        /* usageNode */ undefined,
                        /* useLastDecl */ true
                    ).type;

                    if (isTypeVar(type)) {
                        type = this.validateTypeVarUsage(node, type, flags);
                    }

                    // If the type resolved to "unbound", treat it as "unknown" in
                    // the case of a module reference because if it's truly unbound,
                    // that error will be reported within the module and should not
                    // leak into other modules that import it.
                    if (isUnbound(type)) {
                        type = UnknownType.create(/* isIncomplete */ true);
                    }

                    if (symbol.isPrivateMember()) {
                        this.addDiagnostic(
                            AnalyzerNodeInfo.getFileInfo(node).diagnosticRuleSet.reportPrivateUsage,
                            DiagnosticRule.reportPrivateUsage,
                            Localizer.Diagnostic.privateUsedOutsideOfModule().format({
                                name: memberName,
                            }),
                            node.memberName
                        );
                    }

                    if (symbol.isPrivatePyTypedImport()) {
                        this.addDiagnostic(
                            AnalyzerNodeInfo.getFileInfo(node).diagnosticRuleSet.reportPrivateImportUsage,
                            DiagnosticRule.reportPrivateImportUsage,
                            Localizer.Diagnostic.privateImportFromPyTypedModule().format({
                                name: memberName,
                                module: baseType.moduleName,
                            }),
                            node.memberName
                        );
                    }
                } else {
                    // Does the module export a top-level __getattr__ function?
                    if (usage.method === 'get') {
                        const getAttrSymbol = ModuleType.getField(baseType, '__getattr__');
                        if (getAttrSymbol) {
                            const isModuleGetAttrSupported =
                                fileInfo.executionEnvironment.pythonVersion >= PythonVersion.V3_7 ||
                                getAttrSymbol
                                    .getDeclarations()
                                    .some((decl) => decl.path.toLowerCase().endsWith('.pyi'));

                            if (isModuleGetAttrSupported) {
                                const getAttrTypeResult = this.getEffectiveTypeOfSymbolForUsage(getAttrSymbol);
                                if (isFunction(getAttrTypeResult.type)) {
                                    type = this.getFunctionEffectiveReturnType(getAttrTypeResult.type);
                                    if (getAttrTypeResult.isIncomplete) {
                                        isIncomplete = true;
                                    }
                                }
                            }
                        }
                    }

                    if (!type) {
                        if (!isIncomplete) {
                            this.addDiagnostic(
                                fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                                DiagnosticRule.reportGeneralTypeIssues,
                                Localizer.Diagnostic.moduleUnknownMember().format({ name: memberName }),
                                node.memberName
                            );
                        }
                        type = this._evaluatorOptions.evaluateUnknownImportsAsAny
                            ? AnyType.create()
                            : UnknownType.create();
                    }
                }
                break;
            }

            case TypeCategory.Union: {
                type = mapSubtypes(baseType, (subtype) => {
                    if (isNoneInstance(subtype)) {
                        const typeResult = getTypeOfNoneBase(subtype);
                        if (typeResult) {
                            type = addConditionToType(typeResult.type, getTypeCondition(baseType));
                            if (typeResult.isIncomplete) {
                                isIncomplete = true;
                            }
                            return type;
                        } else {
                            if (!isIncomplete) {
                                this.addDiagnostic(
                                    AnalyzerNodeInfo.getFileInfo(node).diagnosticRuleSet.reportOptionalMemberAccess,
                                    DiagnosticRule.reportOptionalMemberAccess,
                                    Localizer.Diagnostic.noneUnknownMember().format({ name: memberName }),
                                    node.memberName
                                );
                            }
                            return undefined;
                        }
                    } else if (isUnbound(subtype)) {
                        // Don't do anything if it's unbound. The error will already
                        // be reported elsewhere.
                        return undefined;
                    } else {
                        const typeResult = this.getTypeOfMemberAccessWithBaseType(
                            node,
                            {
                                type: subtype,
                                isIncomplete: baseTypeResult.isIncomplete,
                            },
                            usage,
                            EvaluatorFlags.None
                        );
                        if (typeResult.isIncomplete) {
                            isIncomplete = true;
                        }
                        return typeResult.type;
                    }
                });
                break;
            }

            case TypeCategory.Function:
            case TypeCategory.OverloadedFunction: {
                if (memberName === '__defaults__') {
                    // The "__defaults__" member is not currently defined in the "function"
                    // class, so we'll special-case it here.
                    type = AnyType.create();
                } else if (memberName === '__self__') {
                    // The "__self__" member is not currently defined in the "function"
                    // class, so we'll special-case it here.
                    const functionType = isFunction(baseType) ? baseType : baseType.overloads[0];
                    if (
                        functionType.preBoundFlags !== undefined &&
                        (functionType.preBoundFlags & FunctionTypeFlags.StaticMethod) === 0
                    ) {
                        type = functionType.boundToType;
                    }
                } else {
                    if (!this._functionObj) {
                        type = AnyType.create();
                    } else {
                        type = this.getTypeOfMemberAccessWithBaseType(
                            node,
                            { type: this._functionObj },
                            usage,
                            flags
                        ).type;
                    }
                }
                break;
            }

            case TypeCategory.None: {
                const typeResult = getTypeOfNoneBase(baseType);
                if (typeResult) {
                    type = addConditionToType(typeResult.type, getTypeCondition(baseType));
                    if (typeResult.isIncomplete) {
                        isIncomplete = true;
                    }
                }
                break;
            }

            default:
                diag.addMessage(
                    Localizer.DiagnosticAddendum.typeUnsupported().format({ type: this.printType(baseType) })
                );
                break;
        }

        if (!type) {
            const isFunctionRule =
                isFunction(baseType) ||
                isOverloadedFunction(baseType) ||
                (isClassInstance(baseType) && ClassType.isBuiltIn(baseType, 'function'));

            if (!baseTypeResult.isIncomplete) {
                let diagMessage = Localizer.Diagnostic.memberAccess();
                if (usage.method === 'set') {
                    diagMessage = Localizer.Diagnostic.memberSet();
                } else if (usage.method === 'del') {
                    diagMessage = Localizer.Diagnostic.memberDelete();
                }

                // If there is an expected type diagnostic addendum (used for assignments),
                // use that rather than the local diagnostic addendum because it will be
                // more informative.
                if (usage.setExpectedTypeDiag) {
                    diag = usage.setExpectedTypeDiag;
                }

                const [ruleSet, rule] = isFunctionRule
                    ? [fileInfo.diagnosticRuleSet.reportFunctionMemberAccess, DiagnosticRule.reportFunctionMemberAccess]
                    : [fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, DiagnosticRule.reportGeneralTypeIssues];

                this.addDiagnostic(
                    ruleSet,
                    rule,
                    diagMessage.format({ name: memberName, type: this.printType(baseType) }) + diag.getString(),
                    node.memberName,
                    diag.getEffectiveTextRange() ?? node.memberName
                );
            }

            // If this is member access on a function, use "Any" so if the
            // reportFunctionMemberAccess rule is disabled, we don't trigger
            // additional reportUnknownMemberType diagnostics.
            type = isFunctionRule ? AnyType.create() : UnknownType.create();
        }

        // Should we specialize the class?
        if ((flags & EvaluatorFlags.DoNotSpecialize) === 0) {
            if (isInstantiableClass(type) && !type.typeArguments) {
                type = this.createSpecializedClassType(type, /* typeArgs */ undefined, flags, node);
            }
        }

        if (usage.method === 'get') {
            let skipPartialUnknownCheck = isIncomplete;

            // Don't report an error if the type is a partially-specialized
            // class being passed as an argument. This comes up frequently in
            // cases where a type is passed as an argument (e.g. "defaultdict(list)").
            // It can also come up in cases like "isinstance(x, (list, dict))".
            if (isInstantiableClass(type)) {
                const argNode = ParseTreeUtils.getParentNodeOfType(node, ParseNodeType.Argument);
                if (argNode && argNode?.parent?.nodeType === ParseNodeType.Call) {
                    skipPartialUnknownCheck = true;
                }
            }

            if (!skipPartialUnknownCheck) {
                this.reportPossibleUnknownAssignment(
                    fileInfo.diagnosticRuleSet.reportUnknownMemberType,
                    DiagnosticRule.reportUnknownMemberType,
                    node.memberName,
                    type,
                    node,
                    /* ignoreEmptyContainers */ false
                );
            }
        }

        return { type, isIncomplete, isAsymmetricDescriptor };
    }

    getTypeOfClassMemberName(
        errorNode: ExpressionNode,
        classType: ClassType,
        isAccessedThroughObject: boolean,
        memberName: string,
        usage: EvaluatorUsage,
        diag: DiagnosticAddendum | undefined,
        flags: MemberAccessFlags,
        bindToType?: ClassType | TypeVarType
    ): ClassMemberLookup | undefined {
        let classLookupFlags = ClassMemberLookupFlags.Default;
        if (flags & MemberAccessFlags.AccessClassMembersOnly) {
            classLookupFlags |= ClassMemberLookupFlags.SkipInstanceVariables;
        }
        if (flags & MemberAccessFlags.SkipBaseClasses) {
            classLookupFlags |= ClassMemberLookupFlags.SkipBaseClasses;
        }
        if (flags & MemberAccessFlags.SkipObjectBaseClass) {
            classLookupFlags |= ClassMemberLookupFlags.SkipObjectBaseClass;
        }
        if (flags & MemberAccessFlags.SkipTypeBaseClass) {
            classLookupFlags |= ClassMemberLookupFlags.SkipTypeBaseClass;
        }
        if (flags & MemberAccessFlags.SkipOriginalClass) {
            classLookupFlags |= ClassMemberLookupFlags.SkipOriginalClass;
        }

        // Always look for a member with a declared type first.
        let memberInfo = lookUpClassMember(
            classType,
            memberName,
            classLookupFlags | ClassMemberLookupFlags.DeclaredTypesOnly
        );

        // If we couldn't find a symbol with a declared type, use
        // a symbol with an inferred type.
        if (!memberInfo) {
            memberInfo = lookUpClassMember(classType, memberName, classLookupFlags);
        }

        if (memberInfo) {
            let type: Type | undefined;
            let isTypeIncomplete = false;

            if (memberInfo.symbol.isInitVar()) {
                diag?.addMessage(Localizer.DiagnosticAddendum.memberIsInitVar().format({ name: memberName }));
                return undefined;
            }

            if (usage.method !== 'get') {
                // If the usage indicates a 'set' or 'delete' and the access is within the
                // class definition itself, use only the declared type to avoid circular
                // type evaluation.
                const containingClass = ParseTreeUtils.getEnclosingClass(errorNode);
                if (containingClass) {
                    const containingClassType = this.getTypeOfClass(containingClass)?.classType;
                    if (
                        containingClassType &&
                        isInstantiableClass(containingClassType) &&
                        ClassType.isSameGenericClass(containingClassType, classType)
                    ) {
                        type = this.getDeclaredTypeOfSymbol(memberInfo.symbol) ?? UnknownType.create();
                        if (type && isInstantiableClass(memberInfo.classType)) {
                            type = partiallySpecializeType(type, memberInfo.classType);
                        }
                    }
                }
            }

            if (!type) {
                // Determine whether to replace Self variables with a specific
                // class. Avoid doing this if there's a "bindToType" specified
                // because that case is used for super() calls where we want
                // to leave the Self type generic (not specialized).
                const selfClass = bindToType ? undefined : classType;

                const typeResult = this.getTypeOfMemberInternal(memberInfo, selfClass);

                if (typeResult) {
                    type = typeResult.type;
                    if (typeResult.isIncomplete) {
                        isTypeIncomplete = true;
                    }
                } else {
                    type = UnknownType.create();
                }
            }

            // Don't include variables within typed dict classes.
            if (ClassType.isTypedDictClass(classType)) {
                const typedDecls = memberInfo.symbol.getTypedDeclarations();
                if (typedDecls.length > 0 && typedDecls[0].type === DeclarationType.Variable) {
                    diag?.addMessage(Localizer.DiagnosticAddendum.memberUnknown().format({ name: memberName }));
                    return undefined;
                }
            }

            if (usage.method === 'get') {
                // Mark the member accessed if it's not coming from a parent class.
                if (
                    isInstantiableClass(memberInfo.classType) &&
                    ClassType.isSameGenericClass(memberInfo.classType, classType)
                ) {
                    this.setSymbolAccessed(AnalyzerNodeInfo.getFileInfo(errorNode), memberInfo.symbol, errorNode);
                }
            }

            const descriptorResult = this.applyDescriptorAccessMethod(
                type,
                memberInfo,
                classType,
                bindToType,
                isAccessedThroughObject,
                flags,
                errorNode,
                memberName,
                usage,
                diag
            );

            if (!descriptorResult) {
                return undefined;
            }
            type = descriptorResult.type;

            if (usage.method === 'set' && usage.setType) {
                // Verify that the assigned type is compatible.
                if (!this.assignType(type, usage.setType, diag?.createAddendum())) {
                    diag?.addMessage(
                        Localizer.DiagnosticAddendum.memberAssignment().format({
                            type: this.printType(usage.setType),
                            name: memberName,
                            classType: this.printObjectTypeForClass(classType),
                        })
                    );
                    return undefined;
                }

                if (
                    isInstantiableClass(memberInfo.classType) &&
                    ClassType.isFrozenDataClass(memberInfo.classType) &&
                    isAccessedThroughObject
                ) {
                    diag?.addMessage(
                        Localizer.DiagnosticAddendum.dataClassFrozen().format({
                            name: this.printType(ClassType.cloneAsInstance(memberInfo.classType)),
                        })
                    );
                    return undefined;
                }
            }

            return {
                symbol: memberInfo.symbol,
                type,
                isTypeIncomplete,
                isClassMember: !memberInfo.isInstanceMember,
                isClassVar: memberInfo.isClassVar,
                classType: memberInfo.classType,
                isAsymmetricDescriptor: descriptorResult.isAsymmetricDescriptor,
            };
        }

        // No attribute of that name was found. If this is a member access
        // through an object, see if there's an attribute access override
        // method ("__getattr__", etc.).
        if (
            (flags & (MemberAccessFlags.AccessClassMembersOnly | MemberAccessFlags.SkipAttributeAccessOverride)) ===
            0
        ) {
            const generalAttrType = this.applyAttributeAccessOverride(classType, errorNode, usage, memberName);
            if (generalAttrType) {
                return {
                    symbol: undefined,
                    type: generalAttrType,
                    isTypeIncomplete: false,
                    isClassMember: false,
                    isClassVar: false,
                    isAsymmetricDescriptor: false,
                };
            }
        }

        diag?.addMessage(Localizer.DiagnosticAddendum.memberUnknown().format({ name: memberName }));

        return undefined;
    }

    // Applies descriptor access methods "__get__", "__set__", or "__delete__"
    // if they apply. Also binds methods to the class/object through which it
    // is accessed.
    applyDescriptorAccessMethod(
        type: Type,
        memberInfo: ClassMember | undefined,
        baseTypeClass: ClassType,
        bindToType: ClassType | TypeVarType | undefined,
        isAccessedThroughObject: boolean,
        flags: MemberAccessFlags,
        errorNode: ExpressionNode,
        memberName: string,
        usage: EvaluatorUsage,
        diag: DiagnosticAddendum | undefined
    ): DescriptorTypeResult | undefined {
        const treatConstructorAsClassMember = (flags & MemberAccessFlags.TreatConstructorAsClassMethod) !== 0;
        let isTypeValid = true;
        let isAsymmetricDescriptor = false;

        type = mapSubtypes(type, (subtype) => {
            const concreteSubtype = this.makeTopLevelTypeVarsConcrete(subtype);
            const isClassMember = !memberInfo || memberInfo.isClassMember;

            if (isClass(concreteSubtype) && isClassMember) {
                // If it's an object, use its class to lookup the descriptor. If it's a class,
                // use its metaclass instead.
                let lookupClass: ClassType | undefined = concreteSubtype;
                let isAccessedThroughMetaclass = false;
                if (TypeBase.isInstantiable(concreteSubtype)) {
                    if (
                        concreteSubtype.details.effectiveMetaclass &&
                        isInstantiableClass(concreteSubtype.details.effectiveMetaclass)
                    ) {
                        // When accessing a class member that is a class whose metaclass implements
                        // a descriptor protocol, only 'get' operations are allowed. If it's accessed
                        // through the object, all access methods are supported.
                        if (isAccessedThroughObject || usage.method === 'get') {
                            lookupClass = convertToInstance(concreteSubtype.details.effectiveMetaclass) as ClassType;
                            isAccessedThroughMetaclass = true;
                        } else {
                            lookupClass = undefined;
                        }
                    } else {
                        lookupClass = undefined;
                    }
                }

                if (lookupClass) {
                    let accessMethodName: string;

                    if (usage.method === 'get') {
                        accessMethodName = '__get__';
                    } else if (usage.method === 'set') {
                        accessMethodName = '__set__';
                    } else {
                        accessMethodName = '__delete__';
                    }

                    const accessMethod = lookUpClassMember(
                        lookupClass,
                        accessMethodName,
                        ClassMemberLookupFlags.SkipInstanceVariables
                    );

                    // Handle properties specially.
                    if (ClassType.isPropertyClass(lookupClass)) {
                        if (usage.method === 'set') {
                            if (!accessMethod) {
                                diag?.addMessage(
                                    Localizer.DiagnosticAddendum.propertyMissingSetter().format({
                                        name: memberName,
                                    })
                                );
                                isTypeValid = false;
                                return undefined;
                            }
                        } else if (usage.method === 'del') {
                            if (!accessMethod) {
                                diag?.addMessage(
                                    Localizer.DiagnosticAddendum.propertyMissingDeleter().format({
                                        name: memberName,
                                    })
                                );
                                isTypeValid = false;
                                return undefined;
                            }
                        }
                    }

                    if (accessMethod) {
                        let accessMethodType = this.getTypeOfMember(accessMethod);
                        const argList: FunctionArgument[] = [
                            {
                                // Provide "obj" argument.
                                argumentCategory: ArgumentCategory.Simple,
                                typeResult: {
                                    type: ClassType.isClassProperty(lookupClass)
                                        ? baseTypeClass
                                        : isAccessedThroughObject
                                        ? bindToType || ClassType.cloneAsInstance(baseTypeClass)
                                        : NoneType.createInstance(),
                                },
                            },
                        ];

                        if (usage.method === 'get') {
                            // Provide "objtype" argument.
                            argList.push({
                                argumentCategory: ArgumentCategory.Simple,
                                typeResult: { type: baseTypeClass },
                            });
                        } else if (usage.method === 'set') {
                            // Provide "value" argument.
                            argList.push({
                                argumentCategory: ArgumentCategory.Simple,
                                typeResult: { type: usage.setType ?? UnknownType.create() },
                            });
                        }

                        if (
                            ClassType.isPropertyClass(lookupClass) &&
                            memberInfo &&
                            isInstantiableClass(memberInfo!.classType)
                        ) {
                            // This specialization is required specifically for properties, which should be
                            // generic but are not defined that way. Because of this, we use type variables
                            // in the synthesized methods (e.g. __get__) for the property class that are
                            // defined in the class that declares the fget method.

                            // Infer return types before specializing. Otherwise a generic inferred
                            // return type won't be properly specialized.
                            this.inferReturnTypeIfNecessary(accessMethodType);

                            accessMethodType = partiallySpecializeType(accessMethodType, memberInfo.classType);

                            // If the property is being accessed from a protocol class (not an instance),
                            // flag this as an error because a property within a protocol is meant to be
                            // interpreted as a read-only attribute rather than a protocol, so accessing
                            // it directly from the class has an ambiguous meaning.
                            if (
                                (flags & MemberAccessFlags.AccessClassMembersOnly) !== 0 &&
                                ClassType.isProtocolClass(baseTypeClass)
                            ) {
                                diag?.addMessage(Localizer.DiagnosticAddendum.propertyAccessFromProtocolClass());
                                isTypeValid = false;
                            }
                        }

                        if (
                            accessMethodType &&
                            (isFunction(accessMethodType) || isOverloadedFunction(accessMethodType))
                        ) {
                            const methodType = accessMethodType;

                            // Don't emit separate diagnostics for these method calls because
                            // they will be redundant.
                            const returnType = this.suppressDiagnostics(errorNode, () => {
                                // Bind the accessor to the base object type.
                                let bindToClass: ClassType | undefined;

                                // The "bind-to" class depends on whether the descriptor is defined
                                // on the metaclass or the class. We handle properties specially here
                                // because of the way we model the __get__ logic in the property class.
                                if (ClassType.isPropertyClass(concreteSubtype) && !isAccessedThroughMetaclass) {
                                    if (memberInfo && isInstantiableClass(memberInfo.classType)) {
                                        bindToClass = memberInfo.classType;
                                    }
                                } else {
                                    if (isInstantiableClass(accessMethod.classType)) {
                                        bindToClass = accessMethod.classType;
                                    }
                                }

                                let boundMethodType = this.bindFunctionToClassOrObject(
                                    lookupClass,
                                    methodType,
                                    bindToClass,
                                    errorNode,
                                    /* recursionCount */ undefined,
                                    /* treatConstructorAsClassMember */ undefined,
                                    isAccessedThroughMetaclass ? concreteSubtype : undefined
                                );

                                // The synthesized access method for the property may contain
                                // type variables associated with the "bindToClass", so we need
                                // to specialize those here.
                                if (
                                    boundMethodType &&
                                    (isFunction(boundMethodType) || isOverloadedFunction(boundMethodType))
                                ) {
                                    const typeVarContext = new TypeVarContext(getTypeVarScopeId(boundMethodType));
                                    if (bindToClass) {
                                        const specializedBoundType = partiallySpecializeType(
                                            boundMethodType,
                                            bindToClass,
                                            baseTypeClass
                                        );
                                        if (specializedBoundType) {
                                            if (
                                                isFunction(specializedBoundType) ||
                                                isOverloadedFunction(specializedBoundType)
                                            ) {
                                                boundMethodType = specializedBoundType;
                                            }
                                        }
                                    }

                                    const callResult = this.validateCallArguments(
                                        errorNode,
                                        argList,
                                        { type: boundMethodType },
                                        typeVarContext,
                                        /* skipUnknownArgCheck */ true
                                    );

                                    if (callResult.argumentErrors) {
                                        if (usage.method === 'set') {
                                            if (
                                                usage.setType &&
                                                isFunction(boundMethodType) &&
                                                boundMethodType.details.parameters.length >= 2
                                            ) {
                                                const setterType = FunctionType.getEffectiveParameterType(
                                                    boundMethodType,
                                                    1
                                                );

                                                diag?.addMessage(
                                                    Localizer.DiagnosticAddendum.typeIncompatible().format({
                                                        destType: this.printType(setterType),
                                                        sourceType: this.printType(usage.setType),
                                                    })
                                                );
                                            } else if (isOverloadedFunction(boundMethodType)) {
                                                diag?.addMessage(
                                                    Localizer.Diagnostic.noOverload().format({ name: accessMethodName })
                                                );
                                            }
                                        }

                                        isTypeValid = false;
                                        return AnyType.create();
                                    }

                                    // For set or delete, always return Any.
                                    return usage.method === 'get'
                                        ? callResult.returnType ?? UnknownType.create()
                                        : AnyType.create();
                                }

                                return undefined;
                            });

                            // Determine if we're calling __set__ on an asymmetric descriptor or property.
                            if (usage.method === 'set' && isClass(accessMethod.classType)) {
                                if (this.isAsymmetricDescriptorClass(accessMethod.classType)) {
                                    isAsymmetricDescriptor = true;
                                }
                            }

                            if (returnType) {
                                return returnType;
                            }
                        }
                    }
                }
            } else if (isFunction(concreteSubtype) || isOverloadedFunction(concreteSubtype)) {
                // Check for an attempt to overwrite a final method.
                if (usage.method === 'set') {
                    let isFinal = false;
                    if (isFunction(concreteSubtype)) {
                        isFinal = FunctionType.isFinal(concreteSubtype);
                    } else {
                        const impl = OverloadedFunctionType.getImplementation(concreteSubtype);
                        if (impl) {
                            isFinal = FunctionType.isFinal(impl);
                        }
                    }

                    if (isFinal && memberInfo && isClass(memberInfo.classType)) {
                        diag?.addMessage(
                            Localizer.Diagnostic.finalMethodOverride().format({
                                name: memberName,
                                className: memberInfo.classType.details.name,
                            })
                        );
                        isTypeValid = false;
                        return undefined;
                    }
                }

                // If this function is an instance member (e.g. a lambda that was
                // assigned to an instance variable), don't perform any binding.
                if (!isAccessedThroughObject || (memberInfo && !memberInfo.isInstanceMember)) {
                    return this.bindFunctionToClassOrObject(
                        isAccessedThroughObject ? ClassType.cloneAsInstance(baseTypeClass) : baseTypeClass,
                        concreteSubtype,
                        memberInfo && isInstantiableClass(memberInfo.classType) ? memberInfo.classType : undefined,
                        errorNode,
                        /* recursionCount */ undefined,
                        treatConstructorAsClassMember,
                        bindToType
                    );
                }
            }

            if (usage.method === 'set') {
                if (memberInfo?.symbol.isClassVar()) {
                    if (flags & MemberAccessFlags.DisallowClassVarWrites) {
                        diag?.addMessage(Localizer.DiagnosticAddendum.memberSetClassVar().format({ name: memberName }));
                        isTypeValid = false;
                        return undefined;
                    }
                }

                // Check for an attempt to overwrite a final member variable.
                const finalVarTypeDecl = memberInfo?.symbol
                    .getDeclarations()
                    .find((decl) => isFinalVariableDeclaration(decl));

                if (finalVarTypeDecl && !ParseTreeUtils.isNodeContainedWithin(errorNode, finalVarTypeDecl.node)) {
                    // If a Final instance variable is declared in the class body but is
                    // being assigned within an __init__ method, it's allowed.
                    const enclosingFunctionNode = ParseTreeUtils.getEnclosingFunction(errorNode);
                    if (!enclosingFunctionNode || enclosingFunctionNode.name.value !== '__init__') {
                        diag?.addMessage(Localizer.Diagnostic.finalReassigned().format({ name: memberName }));
                        isTypeValid = false;
                        return undefined;
                    }
                }

                // Check for an attempt to overwrite an instance variable that is
                // read-only (e.g. in a named tuple).
                if (
                    memberInfo?.isInstanceMember &&
                    isClass(memberInfo.classType) &&
                    ClassType.isReadOnlyInstanceVariables(memberInfo.classType)
                ) {
                    diag?.addMessage(Localizer.DiagnosticAddendum.readOnlyAttribute().format({ name: memberName }));
                    isTypeValid = false;
                    return undefined;
                }

                let enforceTargetType = false;

                if (memberInfo && memberInfo.symbol.hasTypedDeclarations()) {
                    // If the member has a declared type, we will enforce it.
                    enforceTargetType = true;
                } else {
                    // If the member has no declared type, we will enforce it
                    // if this assignment isn't within the enclosing class. If
                    // it is within the enclosing class, the assignment is used
                    // to infer the type of the member.
                    if (memberInfo && !memberInfo.symbol.getDeclarations().some((decl) => decl.node === errorNode)) {
                        enforceTargetType = true;
                    }
                }

                if (enforceTargetType) {
                    let effectiveType = subtype;

                    // If the code is patching a method (defined on the class)
                    // with an object-level function, strip the "self" parameter
                    // off the original type. This is sometimes done for test
                    // purposes to override standard behaviors of specific methods.
                    if (isAccessedThroughObject) {
                        if (!memberInfo!.isInstanceMember && isFunction(concreteSubtype)) {
                            if (
                                FunctionType.isClassMethod(concreteSubtype) ||
                                FunctionType.isInstanceMethod(concreteSubtype)
                            ) {
                                effectiveType = FunctionType.clone(concreteSubtype, /* stripFirstParam */ true);
                            }
                        }
                    }

                    return effectiveType;
                }
            }

            return subtype;
        });

        if (!isTypeValid) {
            return undefined;
        }

        return { type, isAsymmetricDescriptor };
    }

    isAsymmetricDescriptorClass(classType: ClassType): boolean {
        // If the value has already been cached in this type, return the cached value.
        if (classType.isAsymmetricDescriptor !== undefined) {
            return classType.isAsymmetricDescriptor;
        }

        let isAsymmetric = false;

        const getterSymbolResult = lookUpClassMember(classType, '__get__', ClassMemberLookupFlags.SkipBaseClasses);
        const setterSymbolResult = lookUpClassMember(classType, '__set__', ClassMemberLookupFlags.SkipBaseClasses);

        if (!getterSymbolResult || !setterSymbolResult) {
            isAsymmetric = false;
        } else {
            const getterType = this.getEffectiveTypeOfSymbol(getterSymbolResult.symbol);
            const setterType = this.getEffectiveTypeOfSymbol(setterSymbolResult.symbol);

            // If either the setter or getter is an overload (or some other non-function type),
            // conservatively assume that it's not asymmetric.
            if (isFunction(getterType) && isFunction(setterType)) {
                // If there's no declared return type on the getter, assume it's symmetric.
                if (setterType.details.parameters.length >= 3 && getterType.details.declaredReturnType) {
                    const setterValueType = FunctionType.getEffectiveParameterType(setterType, 2);
                    const getterReturnType = FunctionType.getSpecializedReturnType(getterType) ?? UnknownType.create();

                    if (!isTypeSame(setterValueType, getterReturnType)) {
                        isAsymmetric = true;
                    }
                }
            }
        }

        // Cache the value for next time.
        classType.isAsymmetricDescriptor = isAsymmetric;
        return isAsymmetric;
    }

    // Applies the __getattr__, __setattr__ or __delattr__ method if present.
    applyAttributeAccessOverride(
        classType: ClassType,
        errorNode: ExpressionNode,
        usage: EvaluatorUsage,
        memberName: string
    ): Type | undefined {
        const getAttributeAccessMember = (name: string) => {
            // See if the class has a "__getattribute__" or "__getattr__" method.
            // If so, arbitrary members are supported.
            return this.getTypeOfClassMember(
                errorNode,
                classType,
                name,
                { method: 'get' },
                /* diag */ undefined,
                MemberAccessFlags.SkipObjectBaseClass | MemberAccessFlags.SkipAttributeAccessOverride
            )?.type;
        };

        let accessMemberType: Type | undefined;
        if (usage.method === 'get') {
            accessMemberType = getAttributeAccessMember('__getattribute__') ?? getAttributeAccessMember('__getattr__');
        } else if (usage.method === 'set') {
            accessMemberType = getAttributeAccessMember('__setattr__');
        } else {
            assert(usage.method === 'del');
            accessMemberType = getAttributeAccessMember('__delattr__');
        }

        if (accessMemberType) {
            let nameLiteralType: Type = AnyType.create();
            if (this._strClassType && isInstantiableClass(this._strClassType)) {
                nameLiteralType = ClassType.cloneWithLiteral(ClassType.cloneAsInstance(this._strClassType), memberName);
            }

            const argList: FunctionArgument[] = [
                {
                    // Provide "self" argument.
                    argumentCategory: ArgumentCategory.Simple,
                    typeResult: { type: ClassType.cloneAsInstance(classType) },
                },
                {
                    // Provide "name" argument.
                    argumentCategory: ArgumentCategory.Simple,
                    typeResult: { type: nameLiteralType },
                },
            ];

            if (usage.method === 'set') {
                argList.push({
                    // Provide "value" argument.
                    argumentCategory: ArgumentCategory.Simple,
                    typeResult: { type: usage.setType ?? UnknownType.create() },
                });
            }

            if (isFunction(accessMemberType) || isOverloadedFunction(accessMemberType)) {
                const boundMethodType = this.bindFunctionToClassOrObject(
                    classType,
                    accessMemberType,
                    classType,
                    errorNode
                );

                if (boundMethodType && (isFunction(boundMethodType) || isOverloadedFunction(boundMethodType))) {
                    const typeVarContext = new TypeVarContext(getTypeVarScopeId(boundMethodType));
                    const callResult = this.validateCallArguments(
                        errorNode,
                        argList,
                        { type: boundMethodType },
                        typeVarContext,
                        /* skipUnknownArgCheck */ true
                    );

                    return callResult.returnType ?? UnknownType.create();
                }
            }
        }

        return undefined;
    }

    getTypeOfIndex(node: IndexNode, flags = EvaluatorFlags.None): TypeResult {
        const baseTypeResult = this.getTypeOfExpression(node.baseExpression, flags | EvaluatorFlags.DoNotSpecialize);

        // If this is meant to be a type and the base expression is a string expression,
        // emit an error because this will generate a runtime exception in Python versions
        // less than 3.10.
        if (flags & EvaluatorFlags.ExpectingType) {
            if (node.baseExpression.nodeType === ParseNodeType.StringList) {
                const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
                if (!fileInfo.isStubFile && fileInfo.executionEnvironment.pythonVersion < PythonVersion.V3_10) {
                    this.addError(Localizer.Diagnostic.stringNotSubscriptable(), node.baseExpression);
                }
            }
        }

        // Check for builtin classes that will generate runtime exceptions if subscripted.
        if ((flags & EvaluatorFlags.AllowForwardReferences) === 0) {
            // We can skip this check if the class is used within a PEP 526 variable
            // type annotation within a class or function. For some undocumented reason,
            // they don't result in runtime exceptions when used in this manner.
            let skipSubscriptCheck = (flags & EvaluatorFlags.VariableTypeAnnotation) !== 0;
            if (skipSubscriptCheck) {
                const scopeNode = ParseTreeUtils.getExecutionScopeNode(node);
                if (scopeNode?.nodeType === ParseNodeType.Module) {
                    skipSubscriptCheck = false;
                }
            }

            if (!skipSubscriptCheck) {
                const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
                if (
                    isInstantiableClass(baseTypeResult.type) &&
                    ClassType.isBuiltIn(baseTypeResult.type) &&
                    !baseTypeResult.type.aliasName
                ) {
                    const minPythonVersion = nonSubscriptableBuiltinTypes.get(baseTypeResult.type.details.fullName);
                    if (
                        minPythonVersion !== undefined &&
                        fileInfo.executionEnvironment.pythonVersion < minPythonVersion &&
                        !fileInfo.isStubFile
                    ) {
                        this.addError(
                            Localizer.Diagnostic.classNotRuntimeSubscriptable().format({
                                name: baseTypeResult.type.aliasName || baseTypeResult.type.details.name,
                            }),
                            node.baseExpression
                        );
                    }
                }
            }
        }

        const indexTypeResult = this.getTypeOfIndexWithBaseType(node, baseTypeResult, { method: 'get' }, flags);

        if (isCodeFlowSupportedForReference(node)) {
            // We limit type narrowing for index expressions to built-in types that are
            // known to have symmetric __getitem__ and __setitem__ methods (i.e. the value
            // passed to __setitem__ is the same type as the value returned by __getitem__).
            let baseTypeSupportsIndexNarrowing = true;
            this.mapSubtypesExpandTypeVars(baseTypeResult.type, /* conditionFilter */ undefined, (subtype) => {
                if (
                    !isClassInstance(subtype) ||
                    !(ClassType.isBuiltIn(subtype) || ClassType.isTypedDictClass(subtype))
                ) {
                    baseTypeSupportsIndexNarrowing = false;
                }

                return undefined;
            });

            if (baseTypeSupportsIndexNarrowing) {
                // Before performing code flow analysis, update the cache to prevent recursion.
                this.writeTypeCache(node, indexTypeResult.type, flags, /* isIncomplete */ false);

                // See if we can refine the type based on code flow analysis.
                const codeFlowTypeResult = this.getFlowTypeOfReference(
                    node,
                    indeterminateSymbolId,
                    indexTypeResult.type,
                    /* startNode */ undefined,
                    {
                        isTypeAtStartIncomplete: !!baseTypeResult.isIncomplete || !!indexTypeResult.isIncomplete,
                        skipConditionalNarrowing: (flags & EvaluatorFlags.ExpectingTypeAnnotation) !== 0,
                    }
                );
                if (codeFlowTypeResult.type) {
                    indexTypeResult.type = codeFlowTypeResult.type;
                }

                if (codeFlowTypeResult.isIncomplete) {
                    indexTypeResult.isIncomplete = true;
                }

                this.deleteTypeCacheEntry(node);
            }
        }

        if (baseTypeResult.isIncomplete) {
            indexTypeResult.isIncomplete = true;
        }

        // Handle "Required" and "NotRequired" specially.
        if ((flags & EvaluatorFlags.RequiredAllowed) !== 0) {
            if (isInstantiableClass(baseTypeResult.type)) {
                if (ClassType.isBuiltIn(baseTypeResult.type, 'Required')) {
                    indexTypeResult.isRequired = true;
                } else if (ClassType.isBuiltIn(baseTypeResult.type, 'NotRequired')) {
                    indexTypeResult.isNotRequired = true;
                }
            }
        }

        return indexTypeResult;
    }

    adjustTypeArgumentsForVariadicTypeVar(
        typeArgs: TypeResultWithNode[],
        typeParameters: TypeVarType[],
        errorNode: ExpressionNode
    ): TypeResultWithNode[] {
        const variadicIndex = typeParameters.findIndex((param) => isVariadicTypeVar(param));

        // Do we need to adjust the type arguments to map to a variadic type
        // param at the end of the list?
        if (variadicIndex >= 0) {
            if (this._tupleClassType && isInstantiableClass(this._tupleClassType)) {
                if (variadicIndex < typeArgs.length) {
                    const variadicTypeResults = typeArgs.slice(
                        variadicIndex,
                        variadicIndex + 1 + typeArgs.length - typeParameters.length
                    );

                    // If the type args consist of a lone variadic type variable, don't wrap it in a tuple.
                    if (variadicTypeResults.length === 1 && isVariadicTypeVar(variadicTypeResults[0].type)) {
                        this.validateVariadicTypeVarIsUnpacked(
                            variadicTypeResults[0].type,
                            variadicTypeResults[0].node
                        );
                    } else {
                        variadicTypeResults.forEach((arg, index) => {
                            this.validateTypeArg(arg, {
                                allowEmptyTuple: index === 0,
                                allowVariadicTypeVar: true,
                                allowUnpackedTuples: true,
                            });
                        });

                        const variadicTypes: TupleTypeArgument[] = [];
                        if (variadicTypeResults.length !== 1 || !variadicTypeResults[0].isEmptyTupleShorthand) {
                            variadicTypeResults.forEach((typeResult) => {
                                if (isUnpackedClass(typeResult.type) && typeResult.type.tupleTypeArguments) {
                                    appendArray(variadicTypes, typeResult.type.tupleTypeArguments);
                                } else {
                                    variadicTypes.push({
                                        type: convertToInstance(typeResult.type),
                                        isUnbounded: false,
                                    });
                                }
                            });
                        }

                        const tupleObject = convertToInstance(
                            specializeTupleClass(
                                this._tupleClassType,
                                variadicTypes,
                                /* isTypeArgumentExplicit */ true,
                                /* isUnpackedTuple */ true
                            )
                        );

                        typeArgs = [
                            ...typeArgs.slice(0, variadicIndex),
                            { node: typeArgs[variadicIndex].node, type: tupleObject },
                            ...typeArgs.slice(
                                variadicIndex + 1 + typeArgs.length - typeParameters.length,
                                typeArgs.length
                            ),
                        ];
                    }
                } else {
                    // Add an empty tuple that maps to the TypeVarTuple type parameter.
                    typeArgs.push({
                        node: errorNode,
                        type:
                            typeParameters[variadicIndex].details.defaultType ??
                            convertToInstance(
                                specializeTupleClass(
                                    this._tupleClassType,
                                    [],
                                    /* isTypeArgumentExplicit */ true,
                                    /* isUnpackedTuple */ true
                                )
                            ),
                    });
                }
            }
        }

        return typeArgs;
    }

    // If the variadic type variable is not unpacked, report an error.
    validateVariadicTypeVarIsUnpacked(type: TypeVarType, node: ParseNode) {
        if (!type.isVariadicUnpacked) {
            this.addError(
                Localizer.Diagnostic.unpackedTypeVarTupleExpected().format({
                    name1: type.details.name,
                    name2: type.details.name,
                }),
                node
            );
            return false;
        }

        return true;
    }

    // Handles index expressions that are providing type arguments for a
    // generic type alias.
    createSpecializedTypeAlias(node: IndexNode, baseType: Type, flags: EvaluatorFlags): TypeResultWithNode | undefined {
        if (
            !baseType.typeAliasInfo?.typeParameters ||
            (baseType.typeAliasInfo.typeParameters.length === 0 && baseType.typeAliasInfo.typeArguments)
        ) {
            return undefined;
        }

        // If this is not instantiable, then the index expression isn't a specialization.
        if (!TypeBase.isInstantiable(baseType)) {
            return undefined;
        }

        // If this is already specialized, the index expression isn't a specialization.
        if (baseType.typeAliasInfo.typeArguments) {
            return undefined;
        }

        const typeParameters = baseType.typeAliasInfo.typeParameters;
        let typeArgs = this.adjustTypeArgumentsForVariadicTypeVar(this.getTypeArgs(node, flags), typeParameters, node);

        // PEP 612 says that if the class has only one type parameter consisting
        // of a ParamSpec, the list of arguments does not need to be enclosed in
        // a list. We'll handle that case specially here. Presumably this applies to
        // type aliases as well.
        if (typeParameters.length === 1 && typeParameters[0].details.isParamSpec && typeArgs) {
            if (
                typeArgs.every(
                    (typeArg) => !isEllipsisType(typeArg.type) && !typeArg.typeList && !isParamSpec(typeArg.type)
                )
            ) {
                typeArgs = [
                    {
                        type: UnknownType.create(),
                        node: typeArgs[0].node,
                        typeList: typeArgs,
                    },
                ];
            }
        }

        if (
            typeArgs.length > typeParameters.length &&
            !typeParameters.some((typeVar) => typeVar.details.isVariadic && !typeVar.isVariadicInUnion)
        ) {
            this.addError(
                Localizer.Diagnostic.typeArgsTooMany().format({
                    name: this.printType(baseType),
                    expected: typeParameters.length,
                    received: typeArgs.length,
                }),
                typeArgs[typeParameters.length].node
            );
        }

        // Handle the mypy_extensions.FlexibleAlias type specially.
        if (
            isInstantiableClass(baseType) &&
            baseType.details.fullName === 'mypy_extensions.FlexibleAlias' &&
            typeArgs.length >= 1
        ) {
            return { node, type: typeArgs[0].type };
        }

        const typeVarContext = new TypeVarContext(baseType.typeAliasInfo.typeVarScopeId);
        const diag = new DiagnosticAddendum();
        typeParameters.forEach((param, index) => {
            if (param.details.isParamSpec && index < typeArgs.length) {
                const typeArgType = typeArgs[index].type;

                if (typeArgs[index].typeList) {
                    const functionType = FunctionType.createInstantiable(FunctionTypeFlags.ParamSpecValue);
                    TypeBase.setSpecialForm(functionType);
                    typeArgs[index].typeList!.forEach((paramType, paramIndex) => {
                        FunctionType.addParameter(functionType, {
                            category: ParameterCategory.Simple,
                            name: `__p${paramIndex}`,
                            isNameSynthesized: true,
                            type: convertToInstance(paramType.type),
                            hasDeclaredType: true,
                        });
                    });

                    assignTypeToTypeVar(
                        this,
                        param,
                        functionType,
                        diag,
                        typeVarContext,
                        AssignTypeFlags.RetainLiteralsForTypeVar
                    );
                } else if (isParamSpec(typeArgType)) {
                    assignTypeToTypeVar(
                        this,
                        param,
                        convertToInstance(typeArgType),
                        diag,
                        typeVarContext,
                        AssignTypeFlags.RetainLiteralsForTypeVar
                    );
                } else if (isInstantiableClass(typeArgType) && ClassType.isBuiltIn(typeArgType, 'Concatenate')) {
                    const concatTypeArgs = typeArgType.typeArguments;
                    const functionType = FunctionType.createInstance('', '', '', FunctionTypeFlags.None);

                    if (concatTypeArgs && concatTypeArgs.length > 0) {
                        concatTypeArgs.forEach((typeArg, index) => {
                            if (index === concatTypeArgs.length - 1) {
                                // Add a position-only separator
                                FunctionType.addParameter(functionType, {
                                    category: ParameterCategory.Simple,
                                    isNameSynthesized: false,
                                    type: UnknownType.create(),
                                });

                                if (isParamSpec(typeArg)) {
                                    functionType.details.paramSpec = typeArg;
                                }
                            } else {
                                FunctionType.addParameter(functionType, {
                                    category: ParameterCategory.Simple,
                                    name: `__p${index}`,
                                    isNameSynthesized: true,
                                    hasDeclaredType: true,
                                    type: typeArg,
                                });
                            }
                        });
                    }

                    assignTypeToTypeVar(
                        this,
                        param,
                        functionType,
                        diag,
                        typeVarContext,
                        AssignTypeFlags.RetainLiteralsForTypeVar
                    );
                } else if (isEllipsisType(typeArgType)) {
                    const functionType = FunctionType.createInstantiable(
                        FunctionTypeFlags.ParamSpecValue | FunctionTypeFlags.SkipArgsKwargsCompatibilityCheck
                    );
                    TypeBase.setSpecialForm(functionType);
                    FunctionType.addDefaultParameters(functionType);
                    assignTypeToTypeVar(this, param, functionType, diag, typeVarContext);
                } else {
                    this.addError(Localizer.Diagnostic.typeArgListExpected(), typeArgs[index].node);
                }
            } else {
                if (index < typeArgs.length && typeArgs[index].typeList) {
                    this.addError(Localizer.Diagnostic.typeArgListNotAllowed(), typeArgs[index].node);
                }

                const typeArgType: Type =
                    index < typeArgs.length
                        ? convertToInstance(typeArgs[index].type)
                        : param.details.defaultType ?? UnknownType.create();
                assignTypeToTypeVar(
                    this,
                    param,
                    typeArgType,
                    diag,
                    typeVarContext,
                    AssignTypeFlags.RetainLiteralsForTypeVar
                );
            }
        });

        if (!diag.isEmpty()) {
            this.addError(
                Localizer.Diagnostic.typeNotSpecializable().format({ type: this.printType(baseType) }) +
                    diag.getString(),
                node
            );
        }

        const aliasTypeArgs: Type[] = [];
        baseType.typeAliasInfo.typeParameters?.forEach((typeParam) => {
            let typeVarType: Type | undefined;
            if (isParamSpec(typeParam)) {
                const paramSpecValue = typeVarContext.getParamSpec(typeParam);
                typeVarType = paramSpecValue ? convertParamSpecValueToType(paramSpecValue) : UnknownType.create();
            } else {
                typeVarType = typeVarContext.getTypeVarType(typeParam);
            }
            aliasTypeArgs.push(typeVarType || UnknownType.create());
        });

        const type = TypeBase.cloneForTypeAlias(
            applySolvedTypeVars(baseType, typeVarContext),
            baseType.typeAliasInfo.name,
            baseType.typeAliasInfo.fullName,
            baseType.typeAliasInfo.typeVarScopeId,
            baseType.typeAliasInfo.typeParameters,
            aliasTypeArgs
        );

        return { type, node };
    }

    getTypeOfIndexWithBaseType(
        node: IndexNode,
        baseTypeResult: TypeResult,
        usage: EvaluatorUsage,
        flags: EvaluatorFlags
    ): TypeResult {
        // Handle the case where we're specializing a generic type alias.
        const typeAliasResult = this.createSpecializedTypeAlias(node, baseTypeResult.type, flags);
        if (typeAliasResult) {
            return typeAliasResult;
        }

        if (isTypeVar(baseTypeResult.type) && isTypeAliasPlaceholder(baseTypeResult.type)) {
            const typeArgTypes = this.getTypeArgs(node, flags).map((t) => convertToInstance(t.type));
            const type = TypeBase.cloneForTypeAlias(
                baseTypeResult.type,
                baseTypeResult.type.details.recursiveTypeAliasName!,
                '',
                baseTypeResult.type.details.recursiveTypeAliasScopeId!,
                baseTypeResult.type.details.recursiveTypeParameters,
                typeArgTypes
            );
            return { type };
        }

        let isIncomplete = baseTypeResult.isIncomplete;

        const type = this.mapSubtypesExpandTypeVars(
            baseTypeResult.type,
            /* conditionFilter */ undefined,
            (concreteSubtype, unexpandedSubtype) => {
                if (isAnyOrUnknown(concreteSubtype)) {
                    return concreteSubtype;
                }

                if (flags & EvaluatorFlags.ExpectingType) {
                    if (isTypeVar(unexpandedSubtype)) {
                        this.addDiagnostic(
                            AnalyzerNodeInfo.getFileInfo(node).diagnosticRuleSet.reportGeneralTypeIssues,
                            DiagnosticRule.reportGeneralTypeIssues,
                            Localizer.Diagnostic.typeVarNotSubscriptable().format({
                                type: this.printType(unexpandedSubtype),
                            }),
                            node.baseExpression
                        );

                        // Evaluate the index expressions as though they are type arguments for error-reporting.
                        this.getTypeArgs(node, flags, /* isAnnotatedClass */ false, /* hasCustomClassGetItem */ false);

                        return UnknownType.create();
                    }
                }

                if (isInstantiableClass(concreteSubtype)) {
                    // See if the class has a custom metaclass that supports __getitem__, etc.
                    if (
                        concreteSubtype.details.effectiveMetaclass &&
                        isInstantiableClass(concreteSubtype.details.effectiveMetaclass) &&
                        !ClassType.isBuiltIn(concreteSubtype.details.effectiveMetaclass, ['type', '_InitVarMeta'])
                    ) {
                        const itemMethodType = this.getTypeOfClassMember(
                            node,
                            concreteSubtype,
                            this.getIndexAccessMagicMethodName(usage),
                            /* usage */ undefined,
                            /* diag */ undefined,
                            MemberAccessFlags.SkipAttributeAccessOverride | MemberAccessFlags.ConsiderMetaclassOnly
                        );
                        if (itemMethodType) {
                            return this.getTypeOfIndexedObjectOrClass(node, concreteSubtype, usage).type;
                        }
                    }

                    // Setting the value of an indexed class will always result
                    // in an exception.
                    if (usage.method === 'set') {
                        this.addDiagnostic(
                            AnalyzerNodeInfo.getFileInfo(node).diagnosticRuleSet.reportGeneralTypeIssues,
                            DiagnosticRule.reportGeneralTypeIssues,
                            Localizer.Diagnostic.genericClassAssigned(),
                            node.baseExpression
                        );
                    } else if (usage.method === 'del') {
                        this.addDiagnostic(
                            AnalyzerNodeInfo.getFileInfo(node).diagnosticRuleSet.reportGeneralTypeIssues,
                            DiagnosticRule.reportGeneralTypeIssues,
                            Localizer.Diagnostic.genericClassDeleted(),
                            node.baseExpression
                        );
                    }

                    if (ClassType.isSpecialBuiltIn(concreteSubtype, 'Literal')) {
                        // Special-case Literal types.
                        return this.createLiteralType(node, flags);
                    }

                    if (ClassType.isBuiltIn(concreteSubtype, 'InitVar')) {
                        // Special-case InitVar, used in data classes.
                        const typeArgs = this.getTypeArgs(node, flags);
                        if (typeArgs.length === 1) {
                            return typeArgs[0].type;
                        } else {
                            this.addError(
                                Localizer.Diagnostic.typeArgsMismatchOne().format({ received: typeArgs.length }),
                                node.baseExpression
                            );
                            return UnknownType.create();
                        }
                    }

                    if (ClassType.isEnumClass(concreteSubtype)) {
                        // Special-case Enum types.
                        // TODO - validate that there's only one index entry
                        // that is a str type.
                        // TODO - validate that literal strings are referencing
                        // a known enum member.
                        return ClassType.cloneAsInstance(concreteSubtype);
                    }

                    const isAnnotatedClass =
                        isInstantiableClass(concreteSubtype) && ClassType.isBuiltIn(concreteSubtype, 'Annotated');
                    const hasCustomClassGetItem =
                        isInstantiableClass(concreteSubtype) && ClassType.hasCustomClassGetItem(concreteSubtype);
                    const isGenericClass =
                        concreteSubtype.details.typeParameters?.length > 0 ||
                        ClassType.isSpecialBuiltIn(concreteSubtype) ||
                        ClassType.isBuiltIn(concreteSubtype, 'type') ||
                        ClassType.isPartiallyEvaluated(concreteSubtype);
                    const isFinalAnnotation =
                        isInstantiableClass(concreteSubtype) && ClassType.isBuiltIn(concreteSubtype, 'Final');
                    const isClassVarAnnotation =
                        isInstantiableClass(concreteSubtype) && ClassType.isBuiltIn(concreteSubtype, 'ClassVar');

                    let typeArgs = this.getTypeArgs(
                        node,
                        flags,
                        isAnnotatedClass,
                        hasCustomClassGetItem || !isGenericClass,
                        isFinalAnnotation,
                        isClassVarAnnotation
                    );
                    if (!isAnnotatedClass) {
                        typeArgs = this.adjustTypeArgumentsForVariadicTypeVar(
                            typeArgs,
                            concreteSubtype.details.typeParameters,
                            node
                        );
                    }

                    // If this is a custom __class_getitem__, there's no need to specialize the class.
                    // Just return it as is.
                    if (hasCustomClassGetItem) {
                        return concreteSubtype;
                    }

                    if (concreteSubtype.typeArguments) {
                        this.addDiagnostic(
                            AnalyzerNodeInfo.getFileInfo(node).diagnosticRuleSet.reportGeneralTypeIssues,
                            DiagnosticRule.reportGeneralTypeIssues,
                            Localizer.Diagnostic.classAlreadySpecialized().format({
                                type: this.printType(convertToInstance(concreteSubtype), { expandTypeAlias: true }),
                            }),
                            node.baseExpression
                        );
                        return concreteSubtype;
                    }

                    return this.createSpecializedClassType(concreteSubtype, typeArgs, flags, node);
                }

                if (isClassInstance(concreteSubtype)) {
                    const typeResult = this.getTypeOfIndexedObjectOrClass(node, concreteSubtype, usage);
                    if (typeResult.isIncomplete) {
                        isIncomplete = true;
                    }
                    return typeResult.type;
                }

                if (isNever(concreteSubtype)) {
                    return UnknownType.create();
                }

                if (isNoneInstance(concreteSubtype) && !isIncomplete) {
                    this.addDiagnostic(
                        AnalyzerNodeInfo.getFileInfo(node).diagnosticRuleSet.reportOptionalSubscript,
                        DiagnosticRule.reportOptionalSubscript,
                        Localizer.Diagnostic.noneNotSubscriptable(),
                        node.baseExpression
                    );

                    return UnknownType.create();
                }

                if (!isUnbound(concreteSubtype) && !isIncomplete) {
                    const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
                    this.addDiagnostic(
                        fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                        DiagnosticRule.reportGeneralTypeIssues,
                        Localizer.Diagnostic.typeNotSubscriptable().format({ type: this.printType(concreteSubtype) }),
                        node.baseExpression
                    );
                }

                return UnknownType.create();
            }
        );

        // In case we didn't walk the list items above, do so now.
        // If we have, this information will be cached.
        if (!baseTypeResult.isIncomplete) {
            node.items.forEach((item) => {
                if (!this.isTypeCached(item.valueExpression)) {
                    this.getTypeOfExpression(item.valueExpression, flags & EvaluatorFlags.AllowForwardReferences);
                }
            });
        }

        return { type, isIncomplete };
    }

    makeTupleObject(entryTypes: Type[], isUnspecifiedLength = false) {
        if (this._tupleClassType && isInstantiableClass(this._tupleClassType)) {
            return convertToInstance(
                specializeTupleClass(
                    this._tupleClassType,
                    entryTypes.map((t) => {
                        return { type: t, isUnbounded: isUnspecifiedLength };
                    })
                )
            );
        }

        return UnknownType.create();
    }

    getIndexAccessMagicMethodName(usage: EvaluatorUsage): string {
        if (usage.method === 'get') {
            return '__getitem__';
        } else if (usage.method === 'set') {
            return '__setitem__';
        } else {
            assert(usage.method === 'del');
            return '__delitem__';
        }
    }

    getTypeOfIndexedObjectOrClass(node: IndexNode, baseType: ClassType, usage: EvaluatorUsage): TypeResult {
        // Handle index operations for TypedDict classes specially.
        if (isClassInstance(baseType) && ClassType.isTypedDictClass(baseType)) {
            const typeFromTypedDict = getTypeOfIndexedTypedDict(this, node, baseType, usage);
            if (typeFromTypedDict) {
                return typeFromTypedDict;
            }
        }

        const magicMethodName = this.getIndexAccessMagicMethodName(usage);
        const itemMethodType = isClassInstance(baseType)
            ? this.getTypeOfObjectMember(
                  node,
                  baseType,
                  magicMethodName,
                  /* usage */ undefined,
                  /* diag */ undefined,
                  MemberAccessFlags.SkipAttributeAccessOverride
              )?.type
            : this.getTypeOfClassMember(
                  node,
                  baseType,
                  magicMethodName,
                  /* usage */ undefined,
                  /* diag */ undefined,
                  MemberAccessFlags.SkipAttributeAccessOverride | MemberAccessFlags.ConsiderMetaclassOnly
              )?.type;

        if (!itemMethodType) {
            const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
            this.addDiagnostic(
                fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                DiagnosticRule.reportGeneralTypeIssues,
                Localizer.Diagnostic.methodNotDefinedOnType().format({
                    name: magicMethodName,
                    type: this.printType(baseType),
                }),
                node.baseExpression
            );
            return { type: UnknownType.create() };
        }

        // Handle the special case where the object is a Tuple and
        // the index is a constant number (integer) or a slice with integer
        // start and end values. In these cases, we can determine
        // the exact type by indexing into the tuple type array.
        if (
            node.items.length === 1 &&
            !node.trailingComma &&
            !node.items[0].name &&
            node.items[0].argumentCategory === ArgumentCategory.Simple &&
            isClassInstance(baseType)
        ) {
            const index0Expr = node.items[0].valueExpression;
            const valueType = this.getTypeOfExpression(index0Expr).type;

            if (
                isClassInstance(valueType) &&
                ClassType.isBuiltIn(valueType, 'int') &&
                isLiteralType(valueType) &&
                typeof valueType.literalValue === 'number'
            ) {
                const indexValue = valueType.literalValue;
                const tupleType = getSpecializedTupleType(baseType);

                if (tupleType && tupleType.tupleTypeArguments && !isUnboundedTupleClass(tupleType)) {
                    if (indexValue >= 0 && indexValue < tupleType.tupleTypeArguments.length) {
                        return { type: tupleType.tupleTypeArguments[indexValue].type };
                    } else if (indexValue < 0 && tupleType.tupleTypeArguments.length + indexValue >= 0) {
                        return {
                            type: tupleType.tupleTypeArguments[tupleType.tupleTypeArguments.length + indexValue].type,
                        };
                    }
                }
            } else if (isClassInstance(valueType) && ClassType.isBuiltIn(valueType, 'slice')) {
                const tupleType = getSpecializedTupleType(baseType);
                if (tupleType && tupleType.tupleTypeArguments && !isUnboundedTupleClass(tupleType)) {
                    if (index0Expr.nodeType === ParseNodeType.Slice && !index0Expr.stepValue) {
                        // Create a local helper function to evaluate the slice parameters.
                        const getSliceParameter = (expression: ExpressionNode | undefined, defaultValue: number) => {
                            let value = defaultValue;
                            if (expression) {
                                const valType = this.getTypeOfExpression(expression).type;
                                if (
                                    isClassInstance(valType) &&
                                    ClassType.isBuiltIn(valType, 'int') &&
                                    isLiteralType(valType) &&
                                    typeof valType.literalValue === 'number'
                                ) {
                                    value = valType.literalValue;
                                    if (value < 0) {
                                        value = tupleType.tupleTypeArguments!.length + value;
                                    }
                                } else {
                                    value = -1;
                                }
                            }
                            return value;
                        };

                        const startValue = getSliceParameter(index0Expr.startValue, 0);
                        const endValue = getSliceParameter(index0Expr.endValue, tupleType.tupleTypeArguments.length);

                        if (
                            startValue >= 0 &&
                            endValue > 0 &&
                            endValue <= tupleType.tupleTypeArguments.length &&
                            this._tupleClassType &&
                            isInstantiableClass(this._tupleClassType)
                        ) {
                            return {
                                type: ClassType.cloneAsInstance(
                                    specializeTupleClass(
                                        this._tupleClassType,
                                        tupleType.tupleTypeArguments.slice(startValue, endValue)
                                    )
                                ),
                            };
                        }
                    }
                }
            }
        }

        // Follow PEP 637 rules for positional and keyword arguments.
        const positionalArgs = node.items.filter(
            (item) => item.argumentCategory === ArgumentCategory.Simple && !item.name
        );
        const unpackedListArgs = node.items.filter((item) => item.argumentCategory === ArgumentCategory.UnpackedList);

        const keywordArgs = node.items.filter(
            (item) => item.argumentCategory === ArgumentCategory.Simple && !!item.name
        );
        const unpackedDictArgs = node.items.filter(
            (item) => item.argumentCategory === ArgumentCategory.UnpackedDictionary
        );

        let positionalIndexType: Type;
        let isPositionalIndexTypeIncomplete = false;

        if (positionalArgs.length === 1 && unpackedListArgs.length === 0 && !node.trailingComma) {
            // Handle the common case where there is a single positional argument.
            const typeResult = this.getTypeOfExpression(positionalArgs[0].valueExpression);
            positionalIndexType = typeResult.type;
            if (typeResult.isIncomplete) {
                isPositionalIndexTypeIncomplete = true;
            }
        } else if (positionalArgs.length === 0 && unpackedListArgs.length === 0) {
            // Handle the case where there are no positionals provided but there are keywords.
            positionalIndexType =
                this._tupleClassType && isInstantiableClass(this._tupleClassType)
                    ? convertToInstance(specializeTupleClass(this._tupleClassType, []))
                    : UnknownType.create();
        } else {
            // Package up all of the positionals into a tuple.
            const tupleEntries: Type[] = [];
            positionalArgs.forEach((arg) => {
                const typeResult = this.getTypeOfExpression(arg.valueExpression);
                tupleEntries.push(typeResult.type);
                if (typeResult.isIncomplete) {
                    isPositionalIndexTypeIncomplete = true;
                }
            });

            unpackedListArgs.forEach((arg) => {
                const typeResult = this.getTypeOfExpression(arg.valueExpression);
                if (typeResult.isIncomplete) {
                    isPositionalIndexTypeIncomplete = true;
                }
                const iterableType =
                    this.getTypeOfIterator(typeResult, /* isAsync */ false, arg.valueExpression)?.type ??
                    UnknownType.create();
                tupleEntries.push(iterableType);
            });

            positionalIndexType = this.makeTupleObject(tupleEntries, unpackedListArgs.length > 0);
        }

        let argList: FunctionArgument[] = [
            {
                argumentCategory: ArgumentCategory.Simple,
                typeResult: { type: positionalIndexType, isIncomplete: isPositionalIndexTypeIncomplete },
            },
        ];

        if (usage.method === 'set') {
            let setType = usage.setType || AnyType.create();

            // Expand constrained type variables.
            if (isTypeVar(setType) && setType.details.constraints.length > 0) {
                const conditionFilter = isClassInstance(baseType) ? baseType.condition : undefined;
                setType = this.makeTopLevelTypeVarsConcrete(setType, conditionFilter);
            }

            argList.push({
                argumentCategory: ArgumentCategory.Simple,
                typeResult: { type: setType, isIncomplete: isPositionalIndexTypeIncomplete },
            });
        }

        keywordArgs.forEach((arg) => {
            argList.push({
                argumentCategory: ArgumentCategory.Simple,
                valueExpression: arg.valueExpression,
                node: arg,
                name: arg.name,
            });
        });

        unpackedDictArgs.forEach((arg) => {
            argList.push({
                argumentCategory: ArgumentCategory.UnpackedDictionary,
                valueExpression: arg.valueExpression,
                node: arg,
            });
        });

        let callResult: CallResult | undefined;

        // Speculatively attempt the call. We may need to replace the index
        // type with 'int', and we don't want to emit errors before we know
        // which type to use.
        if (keywordArgs.length === 0 && unpackedDictArgs.length === 0 && positionalArgs.length === 1) {
            this.useSpeculativeMode(node, () => {
                callResult = this.validateCallArguments(node, argList, { type: itemMethodType });

                if (callResult.argumentErrors) {
                    // If the object supports "__index__" magic method, convert
                    // the index to an int and try again.
                    if (isClassInstance(positionalIndexType)) {
                        const altArgList = [...argList];
                        altArgList[0] = { ...altArgList[0] };
                        const indexMethod = this.getTypeOfObjectMember(node, positionalIndexType, '__index__');

                        if (indexMethod) {
                            const intType = this.getBuiltInObject(node, 'int');
                            if (isClassInstance(intType)) {
                                altArgList[0].typeResult = { type: intType };
                            }
                        }

                        callResult = this.validateCallArguments(node, altArgList, { type: itemMethodType });

                        // We were successful, so replace the arg list.
                        if (!callResult.argumentErrors) {
                            argList = altArgList;
                        }
                    }
                }
            });
        }

        callResult = this.validateCallArguments(node, argList, { type: itemMethodType });

        return {
            type: callResult.returnType ?? UnknownType.create(),
            isIncomplete: !!callResult.isTypeIncomplete,
        };
    }

    getTypeArgs(
        node: IndexNode,
        flags: EvaluatorFlags,
        isAnnotatedClass = false,
        hasCustomClassGetItem = false,
        isFinalAnnotation = false,
        isClassVarAnnotation = false
    ): TypeResultWithNode[] {
        const typeArgs: TypeResultWithNode[] = [];
        let adjFlags = flags;

        if (isFinalAnnotation || isClassVarAnnotation) {
            adjFlags |= EvaluatorFlags.ClassVarDisallowed | EvaluatorFlags.FinalDisallowed;
        } else {
            adjFlags &= ~(
                EvaluatorFlags.DoNotSpecialize |
                EvaluatorFlags.ParamSpecDisallowed |
                EvaluatorFlags.TypeVarTupleDisallowed |
                EvaluatorFlags.RequiredAllowed |
                EvaluatorFlags.EnforceTypeVarVarianceConsistency
            );

            if (!isAnnotatedClass) {
                adjFlags |= EvaluatorFlags.ClassVarDisallowed | EvaluatorFlags.FinalDisallowed;
            }

            adjFlags |= EvaluatorFlags.AllowUnpackedTupleOrTypeVarTuple;
        }

        // Create a local function that validates a single type argument.
        const getTypeArgTypeResult = (expr: ExpressionNode, argIndex: number) => {
            let typeResult: TypeResultWithNode;

            // If it's a custom __class_getitem__, none of the arguments should be
            // treated as types. If it's an Annotated[a, b, c], only the first index
            // should be treated as a type. The others can be regular (non-type) objects.
            if (hasCustomClassGetItem || (isAnnotatedClass && argIndex > 0)) {
                typeResult = {
                    ...this.getTypeOfExpression(
                        expr,
                        EvaluatorFlags.ParamSpecDisallowed |
                            EvaluatorFlags.TypeVarTupleDisallowed |
                            EvaluatorFlags.DoNotSpecialize |
                            EvaluatorFlags.ClassVarDisallowed
                    ),
                    node: expr,
                };
            } else {
                typeResult = this.getTypeArg(expr, adjFlags);
            }

            return typeResult;
        };

        // A single (non-empty) tuple is treated the same as a list of items in the index.
        if (
            node.items.length === 1 &&
            !node.trailingComma &&
            !node.items[0].name &&
            node.items[0].valueExpression.nodeType === ParseNodeType.Tuple &&
            node.items[0].valueExpression.expressions.length > 0
        ) {
            node.items[0].valueExpression.expressions.forEach((item, index) => {
                typeArgs.push(getTypeArgTypeResult(item, index));
            });

            // Set the node's type so it isn't reevaluated later.
            this.setTypeForNode(node.items[0].valueExpression, UnknownType.create());
        } else {
            node.items.forEach((arg, index) => {
                const typeResult = getTypeArgTypeResult(arg.valueExpression, index);

                if (arg.argumentCategory !== ArgumentCategory.Simple) {
                    if (arg.argumentCategory === ArgumentCategory.UnpackedList) {
                        if (isVariadicTypeVar(typeResult.type) && !typeResult.type.isVariadicUnpacked) {
                            typeResult.type = TypeVarType.cloneForUnpacked(typeResult.type);
                        } else if (
                            isInstantiableClass(typeResult.type) &&
                            !typeResult.type.includeSubclasses &&
                            isTupleClass(typeResult.type)
                        ) {
                            typeResult.type = ClassType.cloneForUnpacked(typeResult.type);
                        }
                    }
                }

                if (arg.name) {
                    this.addError(Localizer.Diagnostic.keywordArgInTypeArgument(), arg.valueExpression);
                }

                typeArgs.push(typeResult);
            });
        }

        return typeArgs;
    }

    getTypeArg(node: ExpressionNode, flags: EvaluatorFlags): TypeResultWithNode {
        let typeResult: TypeResultWithNode;

        let adjustedFlags =
            flags |
            EvaluatorFlags.ExpectingType |
            EvaluatorFlags.ConvertEllipsisToAny |
            EvaluatorFlags.EvaluateStringLiteralAsType;

        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
        if (fileInfo.isStubFile) {
            adjustedFlags |= EvaluatorFlags.AllowForwardReferences;
        }

        if (node.nodeType === ParseNodeType.List) {
            typeResult = {
                type: UnknownType.create(),
                typeList: node.entries.map((entry) => {
                    return { ...this.getTypeOfExpression(entry, adjustedFlags), node: entry };
                }),
                node,
            };

            // Set the node's type so it isn't reevaluated later.
            this.setTypeForNode(node, UnknownType.create());
        } else {
            typeResult = { ...this.getTypeOfExpression(node, adjustedFlags), node };

            // "Protocol" is not allowed as a type argument.
            if (isClass(typeResult.type) && ClassType.isBuiltIn(typeResult.type, 'Protocol')) {
                this.addError(Localizer.Diagnostic.protocolNotAllowedInTypeArgument(), node);
            }

            if ((flags & EvaluatorFlags.ClassVarDisallowed) !== 0) {
                // "ClassVar" is not allowed as a type argument.
                if (isClass(typeResult.type) && ClassType.isBuiltIn(typeResult.type, 'ClassVar')) {
                    this.addError(Localizer.Diagnostic.classVarNotAllowed(), node);
                }
            }
        }

        return typeResult;
    }

    getTypeOfTuple(node: TupleNode, expectedType: Type | undefined, flags: EvaluatorFlags): TypeResult {
        if ((flags & EvaluatorFlags.ExpectingType) !== 0 && node.expressions.length === 0 && !expectedType) {
            return { type: this.makeTupleObject([]), isEmptyTupleShorthand: true };
        }

        // If the expected type is a union, recursively call for each of the subtypes
        // to find one that matches.
        let effectiveExpectedType = expectedType;
        let expectedTypeContainsAny = expectedType && isAny(expectedType);

        if (expectedType && isUnion(expectedType)) {
            let matchingSubtype: Type | undefined;

            doForEachSubtype(expectedType, (subtype) => {
                if (isAny(subtype)) {
                    expectedTypeContainsAny = true;
                }

                if (!matchingSubtype) {
                    const subtypeResult = this.useSpeculativeMode(node, () => {
                        return this.getTypeOfTupleExpected(node, subtype);
                    });

                    if (subtypeResult && this.assignType(subtype, subtypeResult.type)) {
                        matchingSubtype = subtype;
                    }
                }
            });

            effectiveExpectedType = matchingSubtype;
        }

        let expectedTypeDiagAddendum: DiagnosticAddendum | undefined;
        if (effectiveExpectedType) {
            const result = this.getTypeOfTupleExpected(node, effectiveExpectedType);
            if (result && !result.typeErrors) {
                return result;
            }

            expectedTypeDiagAddendum = result?.expectedTypeDiagAddendum;
        }

        const typeResult = this.getTypeOfTupleInferred(node);

        // If there was an expected type of Any, replace the resulting type
        // with Any rather than return a type with unknowns.
        if (expectedTypeContainsAny) {
            typeResult.type = AnyType.create();
        }

        return { ...typeResult, expectedTypeDiagAddendum };
    }

    getTypeOfTupleExpected(node: TupleNode, expectedType: Type): TypeResult | undefined {
        expectedType = transformPossibleRecursiveTypeAlias(expectedType);
        if (!isClassInstance(expectedType)) {
            return undefined;
        }

        if (!this._tupleClassType || !isInstantiableClass(this._tupleClassType)) {
            return undefined;
        }

        // Build an array of expected types.
        let expectedTypes: Type[] = [];

        if (isTupleClass(expectedType) && expectedType.tupleTypeArguments) {
            expectedTypes = expectedType.tupleTypeArguments.map((t) => transformPossibleRecursiveTypeAlias(t.type));
            const unboundedIndex = expectedType.tupleTypeArguments.findIndex((t) => t.isUnbounded);
            if (unboundedIndex >= 0) {
                if (expectedTypes.length > node.expressions.length) {
                    expectedTypes.splice(unboundedIndex, 1);
                } else {
                    while (expectedTypes.length < node.expressions.length) {
                        expectedTypes.splice(unboundedIndex, 0, expectedTypes[unboundedIndex]);
                    }
                }
            }
        } else {
            const tupleTypeVarContext = new TypeVarContext(getTypeVarScopeId(this._tupleClassType));
            if (
                !populateTypeVarContextBasedOnExpectedType(
                    this,
                    ClassType.cloneAsInstance(this._tupleClassType),
                    expectedType,
                    tupleTypeVarContext,
                    this.getTypeVarScopesForNode(node)
                )
            ) {
                return undefined;
            }

            const specializedTuple = applySolvedTypeVars(this._tupleClassType, tupleTypeVarContext) as ClassType;
            if (!specializedTuple.typeArguments || specializedTuple.typeArguments.length !== 1) {
                return undefined;
            }

            const homogenousType = transformPossibleRecursiveTypeAlias(specializedTuple.typeArguments[0]);
            for (let i = 0; i < node.expressions.length; i++) {
                expectedTypes.push(homogenousType);
            }
        }

        const entryTypeResults = node.expressions.map((expr, index) =>
            this.getTypeOfExpression(
                expr,
                /* flags */ undefined,
                index < expectedTypes.length ? expectedTypes[index] : undefined
            )
        );

        const type = convertToInstance(
            specializeTupleClass(
                this._tupleClassType,
                this.buildTupleTypesList(entryTypeResults),
                /* isTypeArgumentExplicit */ true
            )
        );

        // Copy any expected type diag addenda for precision error reporting.
        let expectedTypeDiagAddendum: DiagnosticAddendum | undefined;
        if (entryTypeResults.some((result) => result.expectedTypeDiagAddendum)) {
            expectedTypeDiagAddendum = new DiagnosticAddendum();
            entryTypeResults.forEach((result) => {
                if (result.expectedTypeDiagAddendum) {
                    expectedTypeDiagAddendum!.addAddendum(result.expectedTypeDiagAddendum);
                }
            });
        }

        return { type, expectedTypeDiagAddendum };
    }

    getTypeOfTupleInferred(node: TupleNode): TypeResult {
        const entryTypeResults = node.expressions.map((expr) => this.getTypeOfExpression(expr));
        const isIncomplete = entryTypeResults.some((result) => result.isIncomplete);

        if (!this._tupleClassType || !isInstantiableClass(this._tupleClassType)) {
            return { type: UnknownType.create() };
        }

        const type = convertToInstance(
            specializeTupleClass(this._tupleClassType, this.buildTupleTypesList(entryTypeResults))
        );

        return { type, isIncomplete };
    }

    buildTupleTypesList(entryTypeResults: TypeResult[]): TupleTypeArgument[] {
        const entryTypes: TupleTypeArgument[] = [];

        for (const typeResult of entryTypeResults) {
            let possibleUnpackedTuple: Type | undefined;
            if (typeResult.unpackedType) {
                possibleUnpackedTuple = typeResult.unpackedType;
            } else if (isUnpacked(typeResult.type)) {
                possibleUnpackedTuple = typeResult.type;
            }

            // Is this an unpacked tuple? If so, we can append the individual
            // unpacked entries onto the new tuple. If it's not an upacked tuple
            // but some other iterator (e.g. a List), we won't know the number of
            // items, so we'll need to leave the Tuple open-ended.
            if (
                possibleUnpackedTuple &&
                isClassInstance(possibleUnpackedTuple) &&
                possibleUnpackedTuple.tupleTypeArguments
            ) {
                const typeArgs = possibleUnpackedTuple.tupleTypeArguments;

                if (!typeArgs) {
                    entryTypes.push({ type: UnknownType.create(), isUnbounded: true });
                } else {
                    appendArray(entryTypes, typeArgs);
                }
            } else if (isNever(typeResult.type) && typeResult.isIncomplete && !typeResult.unpackedType) {
                entryTypes.push({ type: UnknownType.create(/* isIncomplete */ true), isUnbounded: false });
            } else {
                entryTypes.push({ type: typeResult.type, isUnbounded: !!typeResult.unpackedType });
            }
        }

        // If there are multiple unbounded entries, combine all of them into a single
        // unbounded entry to avoid violating the invariant that there can be at most
        // one unbounded entry in a tuple.
        if (entryTypes.filter((t) => t.isUnbounded).length > 1) {
            const firstUnboundedEntryIndex = entryTypes.findIndex((t) => t.isUnbounded);
            const removedEntries = entryTypes.splice(firstUnboundedEntryIndex);
            entryTypes.push({ type: combineTypes(removedEntries.map((t) => t.type)), isUnbounded: true });
        }

        return entryTypes;
    }

    getTypeOfCall(node: CallNode, expectedType: Type | undefined, flags: EvaluatorFlags): TypeResult {
        const baseTypeResult = this.getTypeOfExpression(node.leftExpression, EvaluatorFlags.DoNotSpecialize);

        const argList = node.arguments.map((arg) => {
            const functionArg: FunctionArgument = {
                valueExpression: arg.valueExpression,
                argumentCategory: arg.argumentCategory,
                node: arg,
                name: arg.name,
            };
            return functionArg;
        });

        let typeResult: TypeResult = { type: UnknownType.create() };

        if (!isTypeAliasPlaceholder(baseTypeResult.type)) {
            if (node.leftExpression.nodeType === ParseNodeType.Name && node.leftExpression.value === 'super') {
                // Handle the built-in "super" call specially.
                typeResult = this.getTypeOfSuperCall(node);
            } else if (
                isAnyOrUnknown(baseTypeResult.type) &&
                node.leftExpression.nodeType === ParseNodeType.Name &&
                node.leftExpression.value === 'reveal_type'
            ) {
                // Handle the implicit "reveal_type" call.
                typeResult = this.getTypeOfRevealType(node, expectedType);
            } else if (isFunction(baseTypeResult.type) && baseTypeResult.type.details.builtInName === 'reveal_type') {
                // Handle the "typing.reveal_type" call.
                typeResult = this.getTypeOfRevealType(node, expectedType);
            } else if (isFunction(baseTypeResult.type) && baseTypeResult.type.details.builtInName === 'assert_type') {
                // Handle the "typing.assert_type" call.
                typeResult = this.getTypeOfAssertType(node, expectedType);
            } else if (
                isAnyOrUnknown(baseTypeResult.type) &&
                node.leftExpression.nodeType === ParseNodeType.Name &&
                node.leftExpression.value === 'reveal_locals'
            ) {
                if (node.arguments.length === 0) {
                    // Handle the special-case "reveal_locals" call.
                    typeResult.type = this.getTypeOfRevealLocals(node);
                } else {
                    this.addError(Localizer.Diagnostic.revealLocalsArgs(), node);
                }
            } else {
                const callResult = this.validateCallArguments(
                    node,
                    argList,
                    baseTypeResult,
                    /* typeVarContext */ undefined,
                    /* skipUnknownArgCheck */ false,
                    expectedType
                );

                typeResult.type = callResult.returnType ?? UnknownType.create();

                if (callResult.argumentErrors) {
                    typeResult.typeErrors = true;
                }

                if (callResult.isTypeIncomplete) {
                    typeResult.isIncomplete = true;
                }
            }

            if (baseTypeResult.isIncomplete) {
                typeResult.isIncomplete = true;
            }
        } else {
            typeResult.isIncomplete = true;
        }

        // Don't bother evaluating the arguments if we're speculatively evaluating the call
        // or the base type is incomplete.
        if (!this._speculativeTypeTracker.isSpeculative(node) && !baseTypeResult.isIncomplete) {
            // Touch all of the args so they're marked accessed even if there were errors.
            // We skip this if it's a TypeVar() call in the typing.pyi module because
            // this results in a cyclical type resolution problem whereby we try to
            // retrieve the str class, which inherits from Sequence, which inherits from
            // Iterable, which uses a TypeVar. Without this, Iterable and Sequence classes
            // have invalid type parameters.
            const isCyclicalTypeVarCall =
                isInstantiableClass(baseTypeResult.type) &&
                ClassType.isBuiltIn(baseTypeResult.type, 'TypeVar') &&
                AnalyzerNodeInfo.getFileInfo(node).isTypingStubFile;

            if (!isCyclicalTypeVarCall) {
                argList.forEach((arg) => {
                    if (
                        arg.valueExpression &&
                        arg.valueExpression.nodeType !== ParseNodeType.StringList &&
                        !this.isTypeCached(arg.valueExpression)
                    ) {
                        this.getTypeOfExpression(arg.valueExpression);
                    }
                });
            }
        }

        if ((flags & EvaluatorFlags.ExpectingTypeAnnotation) !== 0) {
            this.addDiagnostic(
                AnalyzerNodeInfo.getFileInfo(node).diagnosticRuleSet.reportGeneralTypeIssues,
                DiagnosticRule.reportGeneralTypeIssues,
                Localizer.Diagnostic.typeAnnotationCall(),
                node
            );

            typeResult = { type: UnknownType.create() };
        }

        return typeResult;
    }

    getTypeOfAssertType(node: CallNode, expectedType: Type | undefined): TypeResult {
        if (
            node.arguments.length !== 2 ||
            node.arguments[0].argumentCategory !== ArgumentCategory.Simple ||
            node.arguments[0].name !== undefined ||
            node.arguments[0].argumentCategory !== ArgumentCategory.Simple ||
            node.arguments[1].name !== undefined
        ) {
            this.addError(Localizer.Diagnostic.assertTypeArgs(), node);
            return { type: UnknownType.create() };
        }

        const arg0TypeResult = this.getTypeOfExpression(
            node.arguments[0].valueExpression,
            /* flags */ undefined,
            expectedType
        );
        if (arg0TypeResult.isIncomplete) {
            return { type: UnknownType.create(/* isIncomplete */ true), isIncomplete: true };
        }

        const assertedType = convertToInstance(this.getTypeOfArgumentExpectingType(node.arguments[1]).type);

        if (!isTypeSame(assertedType, arg0TypeResult.type, { treatAnySameAsUnknown: true })) {
            this.addDiagnostic(
                AnalyzerNodeInfo.getFileInfo(node).diagnosticRuleSet.reportGeneralTypeIssues,
                DiagnosticRule.reportGeneralTypeIssues,
                Localizer.Diagnostic.assertTypeTypeMismatch().format({
                    expected: this.printType(assertedType),
                    received: this.printType(arg0TypeResult.type),
                }),
                node.arguments[0].valueExpression
            );
        }

        return { type: arg0TypeResult.type };
    }

    getTypeOfRevealType(node: CallNode, expectedType: Type | undefined): TypeResult {
        let arg0Value: ExpressionNode | undefined;
        let expectedRevealTypeNode: ExpressionNode | undefined;
        let expectedRevealType: Type | undefined;
        let expectedTextNode: ExpressionNode | undefined;
        let expectedText: string | undefined;

        // Make sure there is only one positional argument passed as arg 0.
        node.arguments.forEach((arg, index) => {
            if (index === 0) {
                if (arg.argumentCategory === ArgumentCategory.Simple && !arg.name) {
                    arg0Value = arg.valueExpression;
                }
            } else if (arg.argumentCategory !== ArgumentCategory.Simple || !arg.name) {
                arg0Value = undefined;
            } else if (arg.name.value === 'expected_text') {
                expectedTextNode = arg.valueExpression;
                const expectedTextType = this.getTypeOfExpression(arg.valueExpression).type;

                if (
                    !isClassInstance(expectedTextType) ||
                    !ClassType.isBuiltIn(expectedTextType, 'str') ||
                    typeof expectedTextType.literalValue !== 'string'
                ) {
                    this.addError(Localizer.Diagnostic.revealTypeExpectedTextArg(), arg.valueExpression);
                } else {
                    expectedText = expectedTextType.literalValue;
                }
            } else if (arg.name.value === 'expected_type') {
                expectedRevealTypeNode = arg.valueExpression;
                expectedRevealType = convertToInstance(this.getTypeOfArgumentExpectingType(arg).type);
            }
        });

        if (!arg0Value) {
            this.addError(Localizer.Diagnostic.revealTypeArgs(), node);
            return { type: UnknownType.create() };
        }

        const typeResult = this.getTypeOfExpression(arg0Value, /* flags */ undefined, expectedType);
        const type = typeResult.type;

        const exprString = ParseTreeUtils.printExpression(arg0Value);
        const typeString = this.printType(type, { expandTypeAlias: true });

        if (expectedText !== undefined) {
            if (expectedText !== typeString) {
                this.addError(
                    Localizer.Diagnostic.revealTypeExpectedTextMismatch().format({
                        expected: expectedText,
                        received: typeString,
                    }),
                    expectedTextNode ?? arg0Value
                );
            }
        }

        if (expectedRevealType) {
            if (!isTypeSame(expectedRevealType, type)) {
                const expectedRevealTypeText = this.printType(expectedRevealType);
                this.addError(
                    Localizer.Diagnostic.revealTypeExpectedTypeMismatch().format({
                        expected: expectedRevealTypeText,
                        received: typeString,
                    }),
                    expectedRevealTypeNode ?? arg0Value
                );
            }
        }

        this.addInformation(
            Localizer.DiagnosticAddendum.typeOfSymbol().format({ name: exprString, type: typeString }),
            node.arguments[0]
        );

        return { type, isIncomplete: typeResult.isIncomplete };
    }

    getTypeOfRevealLocals(node: CallNode) {
        let curNode: ParseNode | undefined = node;
        let scope: Scope | undefined;

        while (curNode) {
            scope = ScopeUtils.getScopeForNode(curNode);

            // Stop when we get a valid scope that's not a list comprehension
            // scope. That includes lambdas, functions, classes, and modules.
            if (scope && scope.type !== ScopeType.ListComprehension) {
                break;
            }

            curNode = curNode.parent;
        }

        const infoMessages: string[] = [];

        if (scope) {
            scope.symbolTable.forEach((symbol, name) => {
                if (!symbol.isIgnoredForProtocolMatch()) {
                    const typeOfSymbol = this.getEffectiveTypeOfSymbol(symbol);
                    infoMessages.push(
                        Localizer.DiagnosticAddendum.typeOfSymbol().format({
                            name,
                            type: this.printType(typeOfSymbol, { expandTypeAlias: true }),
                        })
                    );
                }
            });
        }

        if (infoMessages.length > 0) {
            this.addInformation(infoMessages.join('\n'), node);
        } else {
            this.addInformation(Localizer.Diagnostic.revealLocalsNone(), node);
        }

        return NoneType.createInstance();
    }

    getTypeOfSuperCall(node: CallNode): TypeResult {
        if (node.arguments.length > 2) {
            this.addError(Localizer.Diagnostic.superCallArgCount(), node.arguments[2]);
        }

        // Determine which class the "super" call is applied to. If
        // there is no first argument, then the class is implicit.
        let targetClassType: Type;
        if (node.arguments.length > 0) {
            targetClassType = this.getTypeOfExpression(node.arguments[0].valueExpression).type;
            const concreteTargetClassType = this.makeTopLevelTypeVarsConcrete(targetClassType);

            if (!isAnyOrUnknown(concreteTargetClassType) && !isInstantiableClass(concreteTargetClassType)) {
                this.addDiagnostic(
                    AnalyzerNodeInfo.getFileInfo(node).diagnosticRuleSet.reportGeneralTypeIssues,
                    DiagnosticRule.reportGeneralTypeIssues,
                    Localizer.Diagnostic.superCallFirstArg().format({ type: this.printType(targetClassType) }),
                    node.arguments[0].valueExpression
                );
            }
        } else {
            const enclosingClass = ParseTreeUtils.getEnclosingClass(node);
            if (enclosingClass) {
                const classTypeInfo = this.getTypeOfClass(enclosingClass);
                targetClassType = classTypeInfo ? classTypeInfo.classType : UnknownType.create();
            } else {
                this.addError(Localizer.Diagnostic.superCallZeroArgForm(), node.leftExpression);
                targetClassType = UnknownType.create();
            }
        }

        // Determine whether to further narrow the type.
        let bindToType: ClassType | undefined;
        if (node.arguments.length > 1) {
            const secondArgType = this.makeTopLevelTypeVarsConcrete(
                this.getTypeOfExpression(node.arguments[1].valueExpression).type
            );

            let reportError = false;

            if (isAnyOrUnknown(secondArgType)) {
                // Ignore unknown or any types.
            } else if (isClassInstance(secondArgType)) {
                if (isInstantiableClass(targetClassType)) {
                    if (
                        !derivesFromClassRecursive(
                            ClassType.cloneAsInstantiable(secondArgType),
                            targetClassType,
                            /* ignoreUnknown */ true
                        )
                    ) {
                        reportError = true;
                    }
                }
                bindToType = secondArgType;
            } else if (isInstantiableClass(secondArgType)) {
                if (isInstantiableClass(targetClassType)) {
                    if (!derivesFromClassRecursive(secondArgType, targetClassType, /* ignoreUnknown */ true)) {
                        reportError = true;
                    }
                }
                bindToType = secondArgType;
            } else {
                reportError = true;
            }

            if (reportError) {
                const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
                this.addDiagnostic(
                    fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                    DiagnosticRule.reportGeneralTypeIssues,
                    Localizer.Diagnostic.superCallSecondArg().format({ type: this.printType(targetClassType) }),
                    node.arguments[1].valueExpression
                );
            }
        } else {
            const enclosingMethod = ParseTreeUtils.getEnclosingFunction(node);
            let implicitBindToType: Type | undefined;

            // Get the type from the self or cls parameter if it is explicitly annotated.
            if (enclosingMethod) {
                const methodTypeInfo = this.getTypeOfFunction(enclosingMethod);
                if (methodTypeInfo) {
                    const methodType = methodTypeInfo.functionType;
                    if (FunctionType.isClassMethod(methodType)) {
                        if (
                            methodType.details.parameters.length > 0 &&
                            methodType.details.parameters[0].hasDeclaredType
                        ) {
                            implicitBindToType = this.makeTopLevelTypeVarsConcrete(
                                methodType.details.parameters[0].type
                            );
                        }
                    } else if (FunctionType.isInstanceMethod(methodType)) {
                        if (
                            methodType.details.parameters.length > 0 &&
                            methodType.details.parameters[0].hasDeclaredType
                        ) {
                            implicitBindToType = this.makeTopLevelTypeVarsConcrete(
                                convertToInstantiable(methodType.details.parameters[0].type)
                            );
                        }
                    }
                }
            }

            if (implicitBindToType && isInstantiableClass(implicitBindToType)) {
                bindToType = implicitBindToType;
            } else if (isInstantiableClass(targetClassType)) {
                bindToType = targetClassType;
            }
        }

        // Determine whether super() should return an instance of the class or
        // the class itself. It depends on whether the super() call is located
        // within an instance method or not.
        let resultIsInstance = true;
        if (node.arguments.length <= 1) {
            const enclosingMethod = ParseTreeUtils.getEnclosingFunction(node);
            if (enclosingMethod) {
                const methodType = this.getTypeOfFunction(enclosingMethod);
                if (methodType) {
                    if (
                        FunctionType.isStaticMethod(methodType.functionType) ||
                        FunctionType.isConstructorMethod(methodType.functionType) ||
                        FunctionType.isClassMethod(methodType.functionType)
                    ) {
                        resultIsInstance = false;
                    }
                }
            }
        }

        // Python docs indicate that super() isn't valid for
        // operations other than member accesses or attribute lookups.
        const parentNode = node.parent!;
        if (parentNode.nodeType === ParseNodeType.MemberAccess) {
            const memberName = parentNode.memberName.value;
            const lookupResults = lookUpClassMember(
                targetClassType,
                memberName,
                ClassMemberLookupFlags.SkipOriginalClass
            );
            if (lookupResults && isInstantiableClass(lookupResults.classType)) {
                return {
                    type: resultIsInstance
                        ? ClassType.cloneAsInstance(lookupResults.classType)
                        : lookupResults.classType,
                    bindToType:
                        resultIsInstance && bindToType && isInstantiableClass(bindToType)
                            ? ClassType.cloneAsInstance(bindToType)
                            : bindToType,
                };
            }
        }

        // If the lookup failed, try to return the first base class. An error
        // will be reported by the member lookup logic at a later time.
        if (isInstantiableClass(targetClassType)) {
            // If the class derives from one or more unknown classes,
            // return unknown here to prevent spurious errors.
            if (targetClassType.details.mro.some((mroBase) => isAnyOrUnknown(mroBase))) {
                return { type: UnknownType.create() };
            }

            const baseClasses = targetClassType.details.baseClasses;
            if (baseClasses.length > 0) {
                const baseClassType = baseClasses[0];
                if (isInstantiableClass(baseClassType)) {
                    return {
                        type: resultIsInstance ? ClassType.cloneAsInstance(baseClassType) : baseClassType,
                    };
                }
            }
        }

        return { type: UnknownType.create() };
    }

    // Attempts to find an overloaded function for each set of argument
    // types in the expandedArgTypes list. If an argument type is undefined,
    // its type is evaluated from the argument's expression using the
    // corresponding parameter's expected type. The first time this is called,
    // there will be only one argument list in expandedArgTypes, and all entries
    // (one for each argument) will be undefined. On subsequent calls, this
    // list will grow to include union expansions.
    validateOverloadsWithExpandedTypes(
        errorNode: ExpressionNode,
        expandedArgTypes: (Type | undefined)[][],
        argParamMatches: MatchArgsToParamsResult[],
        typeVarContext: TypeVarContext | undefined,
        skipUnknownArgCheck: boolean,
        expectedType: Type | undefined
    ): CallResult {
        const returnTypes: Type[] = [];
        const matchedOverloads: {
            overload: FunctionType;
            matchResults: MatchArgsToParamsResult;
            typeVarContext: TypeVarContext;
        }[] = [];
        let isTypeIncomplete = false;

        for (let expandedTypesIndex = 0; expandedTypesIndex < expandedArgTypes.length; expandedTypesIndex++) {
            let matchedOverload: FunctionType | undefined;
            const argTypeOverride = expandedArgTypes[expandedTypesIndex];
            const hasArgTypeOverride = argTypeOverride.some((a) => a !== undefined);

            for (let overloadIndex = 0; overloadIndex < argParamMatches.length; overloadIndex++) {
                const overload = argParamMatches[overloadIndex].overload;

                let matchResults = argParamMatches[overloadIndex];
                if (hasArgTypeOverride) {
                    matchResults = { ...argParamMatches[overloadIndex] };
                    matchResults.argParams = matchResults.argParams.map((argParam, argIndex) => {
                        if (!argTypeOverride[argIndex]) {
                            return argParam;
                        }
                        const argParamCopy = { ...argParam };
                        argParamCopy.argType = argTypeOverride[argIndex];
                        return argParamCopy;
                    });
                }

                // Clone the typeVarContext so we don't modify the original. If this is
                // not the first time through the loop, clone the type var context
                // from the previous successful match.
                const typeVarContextToClone =
                    matchedOverloads.length > 0
                        ? matchedOverloads[matchedOverloads.length - 1].typeVarContext.clone()
                        : typeVarContext;
                const effectiveTypeVarContext =
                    typeVarContextToClone?.clone() ?? new TypeVarContext(getTypeVarScopeId(overload));
                effectiveTypeVarContext.addSolveForScope(getTypeVarScopeId(overload));
                effectiveTypeVarContext.unlock();

                // Use speculative mode so we don't output any diagnostics or
                // record any final types in the type cache.
                const callResult = this.useSpeculativeMode(errorNode, () => {
                    return this.validateFunctionArgumentTypesWithExpectedType(
                        errorNode,
                        matchResults,
                        effectiveTypeVarContext,
                        /* skipUnknownArgCheck */ true,
                        expectedType
                    );
                });

                if (callResult.isTypeIncomplete) {
                    isTypeIncomplete = true;
                }

                if (!callResult.argumentErrors && callResult.returnType) {
                    matchedOverload = overload;
                    matchedOverloads.push({
                        overload: matchedOverload,
                        matchResults,
                        typeVarContext: effectiveTypeVarContext,
                    });
                    returnTypes.push(callResult.returnType);
                    break;
                }
            }

            if (!matchedOverload) {
                return { argumentErrors: true, isTypeIncomplete };
            }
        }

        // We found a match for all of the expanded argument lists. Copy the
        // resulting type var context back into the caller's type var context.
        // Use the type var context from the last matched overload because it
        // includes the type var solutions for all earlier matched overloads.
        if (typeVarContext) {
            typeVarContext.copyFromClone(matchedOverloads[matchedOverloads.length - 1].typeVarContext);
        }

        // And run through the first expanded argument list one more time to
        // populate the type cache.
        const finalTypeVarContext = typeVarContext ?? matchedOverloads[0].typeVarContext;
        finalTypeVarContext.unlock();
        finalTypeVarContext.addSolveForScope(getTypeVarScopeId(matchedOverloads[0].overload));
        const finalCallResult = this.validateFunctionArgumentTypesWithExpectedType(
            errorNode,
            matchedOverloads[0].matchResults,
            finalTypeVarContext,
            skipUnknownArgCheck,
            expectedType
        );

        if (finalCallResult.isTypeIncomplete) {
            isTypeIncomplete = true;
        }

        return {
            argumentErrors: false,
            returnType: combineTypes(returnTypes),
            isTypeIncomplete,
            specializedInitSelfType: finalCallResult.specializedInitSelfType,
        };
    }

    getBestOverloadForArguments(
        errorNode: ExpressionNode,
        type: OverloadedFunctionType,
        argList: FunctionArgument[]
    ): FunctionType | undefined {
        let overloadIndex = 0;
        let matches: MatchArgsToParamsResult[] = [];

        // Create a list of potential overload matches based on arguments.
        OverloadedFunctionType.getOverloads(type).forEach((overload) => {
            this.useSpeculativeMode(errorNode, () => {
                const matchResults = this.matchFunctionArgumentsToParameters(
                    errorNode,
                    argList,
                    overload,
                    overloadIndex
                );

                if (!matchResults.argumentErrors) {
                    matches.push(matchResults);
                }

                overloadIndex++;
            });
        });

        matches = this.sortOverloadsByBestMatch(matches);

        let winningOverloadIndex: number | undefined;

        matches.forEach((match, matchIndex) => {
            if (winningOverloadIndex === undefined) {
                this.useSpeculativeMode(errorNode, () => {
                    const callResult = this.validateFunctionArgumentTypes(
                        errorNode,
                        match,
                        new TypeVarContext(getTypeVarScopeId(match.overload)),
                        /* skipUnknownArgCheck */ true
                    );

                    if (callResult && !callResult.argumentErrors) {
                        winningOverloadIndex = matchIndex;
                    }
                });
            }
        });

        return winningOverloadIndex === undefined ? undefined : matches[winningOverloadIndex].overload;
    }

    // Sorts the list of overloads based first on "relevance" and second on order.
    sortOverloadsByBestMatch(matches: MatchArgsToParamsResult[]) {
        return matches.sort((a, b) => {
            if (a.relevance !== b.relevance) {
                return b.relevance - a.relevance;
            }

            return a.overloadIndex - b.overloadIndex;
        });
    }

    validateOverloadedFunctionArguments(
        errorNode: ExpressionNode,
        argList: FunctionArgument[],
        type: OverloadedFunctionType,
        typeVarContext: TypeVarContext | undefined,
        skipUnknownArgCheck: boolean,
        expectedType: Type | undefined
    ): CallResult {
        let filteredMatchResults: MatchArgsToParamsResult[] = [];
        let contextFreeArgTypes: Type[] | undefined;

        // Start by evaluating the types of the arguments without any expected
        // type. Also, filter the list of overloads based on the number of
        // positional and named arguments that are present. We do all of this
        // speculatively because we don't want to record any types in the type
        // cache or record any diagnostics at this stage.
        this.useSpeculativeMode(errorNode, () => {
            let overloadIndex = 0;
            OverloadedFunctionType.getOverloads(type).forEach((overload) => {
                // Consider only the functions that have the @overload decorator,
                // not the final function that omits the overload. This is the
                // intended behavior according to PEP 484.
                const matchResults = this.matchFunctionArgumentsToParameters(
                    errorNode,
                    argList,
                    overload,
                    overloadIndex
                );
                if (!matchResults.argumentErrors) {
                    filteredMatchResults.push(matchResults);
                }

                overloadIndex++;
            });
        });

        filteredMatchResults = this.sortOverloadsByBestMatch(filteredMatchResults);

        // If there are no possible arg/param matches among the overloads,
        // emit an error that includes the argument types.
        if (filteredMatchResults.length === 0) {
            // Skip the error message if we're in speculative mode because it's very
            // expensive, and we're going to suppress the diagnostic anyway.
            if (!this.isDiagnosticSuppressedForNode(errorNode)) {
                const functionName = type.overloads[0].details.name || '<anonymous function>';
                const diagAddendum = new DiagnosticAddendum();
                const argTypes = argList.map((t) => this.printType(this.getTypeOfArgument(t).type));

                diagAddendum.addMessage(
                    Localizer.DiagnosticAddendum.argumentTypes().format({ types: argTypes.join(', ') })
                );
                this.addDiagnostic(
                    AnalyzerNodeInfo.getFileInfo(errorNode).diagnosticRuleSet.reportGeneralTypeIssues,
                    DiagnosticRule.reportGeneralTypeIssues,
                    Localizer.Diagnostic.noOverload().format({ name: functionName }) + diagAddendum.getString(),
                    errorNode
                );
            }

            return { argumentErrors: true, isTypeIncomplete: false };
        }

        // Create a helper lambda that evaluates the overload that matches
        // the arg/param lists.
        const evaluateUsingLastMatchingOverload = (skipUnknownArgCheck: boolean) => {
            // Find the match with the largest overload index (i.e. the last overload
            // that was in the overload list).
            const lastMatch = filteredMatchResults.reduce((previous, current) => {
                return current.overloadIndex > previous.overloadIndex ? current : previous;
            });

            const effectiveTypeVarContext = typeVarContext ?? new TypeVarContext();
            effectiveTypeVarContext.addSolveForScope(getTypeVarScopeId(lastMatch.overload));
            effectiveTypeVarContext.unlock();

            return this.validateFunctionArgumentTypesWithExpectedType(
                errorNode,
                lastMatch,
                effectiveTypeVarContext,
                skipUnknownArgCheck,
                expectedType
            );
        };

        // If there is only one possible arg/param match among the overloads,
        // use the normal type matching mechanism because it is faster and
        // will provide a clearer error message.
        if (filteredMatchResults.length === 1) {
            return evaluateUsingLastMatchingOverload(/* skipUnknownArgCheck */ false);
        }

        let expandedArgTypes: (Type | undefined)[][] | undefined = [argList.map((arg) => undefined)];
        let isTypeIncomplete = false;

        while (true) {
            const callResult = this.validateOverloadsWithExpandedTypes(
                errorNode,
                expandedArgTypes,
                filteredMatchResults,
                typeVarContext,
                skipUnknownArgCheck,
                expectedType
            );

            if (callResult.isTypeIncomplete) {
                isTypeIncomplete = true;
            }

            if (!callResult.argumentErrors) {
                return callResult;
            }

            // We didn't find an overload match. Try to expand the next union
            // argument type into individual types and retry with the expanded types.
            if (!contextFreeArgTypes) {
                this.useSpeculativeMode(errorNode, () => {
                    // Evaluate the types of each argument expression without regard to
                    // the expectedType. We'll use this to determine whether we need to do
                    // union expansion.
                    contextFreeArgTypes = argList.map((arg) => {
                        if (arg.typeResult) {
                            return arg.typeResult.type;
                        }

                        if (arg.valueExpression) {
                            const valueExpressionNode = arg.valueExpression;
                            return this.useSpeculativeMode(valueExpressionNode, () => {
                                return this.getTypeOfExpression(valueExpressionNode).type;
                            });
                        }

                        return AnyType.create();
                    });
                });
            }

            expandedArgTypes = this.expandArgumentUnionTypes(contextFreeArgTypes!, expandedArgTypes);

            // Check for combinatoric explosion and break out of loop.
            if (!expandedArgTypes || expandedArgTypes.length > maxOverloadUnionExpansionCount) {
                break;
            }
        }

        // We couldn't find any valid overloads. Skip the error message if we're
        // in speculative mode because it's very expensive, and we're going to
        // suppress the diagnostic anyway.
        if (!this.isDiagnosticSuppressedForNode(errorNode) && !isTypeIncomplete) {
            const result = evaluateUsingLastMatchingOverload(/* skipUnknownArgCheck */ true);

            // Replace the result with an unknown type since we don't know
            // what overload should have been used.
            result.returnType = UnknownType.create();
            return result;
        }

        return { argumentErrors: true, isTypeIncomplete: false };
    }

    // Replaces each item in the expandedArgTypes with n items where n is
    // the number of subtypes in a union. The contextFreeArgTypes parameter
    // represents the types of the arguments evaluated with no bidirectional
    // type inference (i.e. without the help of the corresponding parameter's
    // expected type). If the function returns undefined, that indicates that
    // all unions have been expanded, and no more expansion is possible.
    expandArgumentUnionTypes(
        contextFreeArgTypes: Type[],
        expandedArgTypes: (Type | undefined)[][]
    ): (Type | undefined)[][] | undefined {
        // Find the rightmost already-expanded argument.
        let indexToExpand = contextFreeArgTypes.length - 1;
        while (indexToExpand >= 0 && !expandedArgTypes[0][indexToExpand]) {
            indexToExpand--;
        }

        // Move to the next candidate for expansion.
        indexToExpand++;

        if (indexToExpand >= contextFreeArgTypes.length) {
            return undefined;
        }

        let unionToExpand: Type | undefined;
        while (indexToExpand < contextFreeArgTypes.length) {
            // Is this a union type? If so, we can expand it.
            const argType = contextFreeArgTypes[indexToExpand];
            if (isUnion(argType)) {
                unionToExpand = this.makeTopLevelTypeVarsConcrete(argType);
                break;
            } else if (isTypeVar(argType) && argType.details.constraints.length > 1) {
                unionToExpand = this.makeTopLevelTypeVarsConcrete(argType);
                break;
            }
            indexToExpand++;
        }

        // We have nothing left to expand.
        if (!unionToExpand) {
            return undefined;
        }

        // Expand entry indexToExpand.
        const newExpandedArgTypes: (Type | undefined)[][] = [];

        expandedArgTypes.forEach((preExpandedTypes) => {
            doForEachSubtype(unionToExpand!, (subtype) => {
                const expandedTypes = [...preExpandedTypes];
                expandedTypes[indexToExpand] = subtype;
                newExpandedArgTypes.push(expandedTypes);
            });
        });

        return newExpandedArgTypes;
    }

    // Tries to match the arguments of a call to the constructor for a class.
    // If successful, it returns the resulting (specialized) object type that
    // is allocated by the constructor. If unsuccessful, it records diagnostic
    // information and returns undefined.
    validateConstructorArguments(
        errorNode: ExpressionNode,
        argList: FunctionArgument[],
        type: ClassType,
        skipUnknownArgCheck: boolean,
        expectedType: Type | undefined
    ): CallResult {
        let validatedTypes = false;
        let returnType: Type | undefined;
        let reportedErrors = false;
        let isTypeIncomplete = false;
        let usedMetaclassCallMethod = false;

        // Create a helper function that determines whether we should skip argument
        // validation for either __init__ or __new__. This is required for certain
        // synthesized constructor types, namely NamedTuples.
        const skipConstructorCheck = (type: Type) => {
            return isFunction(type) && FunctionType.isSkipConstructorCheck(type);
        };

        // Validate __init__
        // We validate __init__ before __new__ because the former typically has
        // more specific type annotations, and we want to evaluate the arguments
        // in the context of these types. The __new__ method often uses generic
        // vargs and kwargs.
        const initMethodType = this.getTypeOfObjectMember(
            errorNode,
            ClassType.cloneAsInstance(type),
            '__init__',
            { method: 'get' },
            /* diag */ undefined,
            MemberAccessFlags.SkipObjectBaseClass | MemberAccessFlags.SkipAttributeAccessOverride
        )?.type;

        if (initMethodType && !skipConstructorCheck(initMethodType)) {
            // If there is an expected type, analyze the constructor call
            // for each of the subtypes that comprise the expected type. If
            // one or more analyzes with no errors, use those results.
            if (expectedType) {
                const expectedCallResult = this.validateConstructorMethodWithExpectedType(
                    errorNode,
                    argList,
                    type,
                    skipUnknownArgCheck,
                    expectedType,
                    initMethodType
                );

                if (expectedCallResult) {
                    returnType = expectedCallResult.returnType;

                    if (expectedCallResult.isTypeIncomplete) {
                        isTypeIncomplete = true;
                    }
                }
            }

            if (!returnType) {
                const typeVarContext = type.typeArguments
                    ? buildTypeVarContextFromSpecializedClass(type, /* makeConcrete */ false)
                    : new TypeVarContext(getTypeVarScopeId(type));

                typeVarContext.addSolveForScope(getTypeVarScopeId(initMethodType));
                const callResult = this.validateCallArguments(
                    errorNode,
                    argList,
                    { type: initMethodType },
                    typeVarContext,
                    skipUnknownArgCheck
                );

                if (!callResult.argumentErrors) {
                    let adjustedClassType = type;
                    if (
                        callResult.specializedInitSelfType &&
                        isClassInstance(callResult.specializedInitSelfType) &&
                        ClassType.isSameGenericClass(callResult.specializedInitSelfType, type)
                    ) {
                        adjustedClassType = ClassType.cloneAsInstantiable(callResult.specializedInitSelfType);
                    }

                    returnType = this.applyExpectedTypeForConstructor(
                        adjustedClassType,
                        /* expectedType */ undefined,
                        typeVarContext
                    );

                    if (callResult.isTypeIncomplete) {
                        isTypeIncomplete = true;
                    }
                } else {
                    reportedErrors = true;
                }
            }

            validatedTypes = true;
            skipUnknownArgCheck = true;
        }

        // Validate __new__
        // Don't report errors for __new__ if __init__ already generated errors. They're
        // probably going to be entirely redundant anyway.
        if (!reportedErrors) {
            const metaclass = type.details.effectiveMetaclass;
            let constructorMethodInfo: ClassMemberLookup | undefined;

            // See if there's a custom `__call__` method on the metaclass. If so, we'll
            // use that rather than the `__new__` method on the class.
            if (metaclass && isInstantiableClass(metaclass) && !ClassType.isSameGenericClass(metaclass, type)) {
                constructorMethodInfo = this.getTypeOfClassMemberName(
                    errorNode,
                    metaclass,
                    /* isAccessedThroughObject */ true,
                    '__call__',
                    { method: 'get' },
                    /* diag */ undefined,
                    MemberAccessFlags.ConsiderMetaclassOnly |
                        MemberAccessFlags.SkipTypeBaseClass |
                        MemberAccessFlags.SkipAttributeAccessOverride,
                    type
                );

                if (constructorMethodInfo) {
                    usedMetaclassCallMethod = true;
                }
            }

            if (!constructorMethodInfo) {
                constructorMethodInfo = this.getTypeOfClassMemberName(
                    errorNode,
                    type,
                    /* isAccessedThroughObject */ false,
                    '__new__',
                    { method: 'get' },
                    /* diag */ undefined,
                    MemberAccessFlags.AccessClassMembersOnly |
                        MemberAccessFlags.SkipObjectBaseClass |
                        MemberAccessFlags.TreatConstructorAsClassMethod,
                    type
                );
            }

            if (constructorMethodInfo && !skipConstructorCheck(constructorMethodInfo.type)) {
                const constructorMethodType = constructorMethodInfo.type;

                // If there is an expected type that was not applied above when
                // handling the __init__ method, try to apply it with the __new__ method.
                if (expectedType && !returnType) {
                    const expectedCallResult = this.validateConstructorMethodWithExpectedType(
                        errorNode,
                        argList,
                        type,
                        skipUnknownArgCheck,
                        expectedType,
                        constructorMethodType
                    );

                    if (expectedCallResult) {
                        returnType = expectedCallResult.returnType;

                        if (expectedCallResult.isTypeIncomplete) {
                            isTypeIncomplete = true;
                        }
                    }
                }

                const typeVarContext = new TypeVarContext(getTypeVarScopeId(type));

                if (type.typeAliasInfo) {
                    typeVarContext.addSolveForScope(type.typeAliasInfo.typeVarScopeId);
                }

                typeVarContext.addSolveForScope(getTypeVarScopeId(constructorMethodType));

                // Skip the unknown argument check if we've already checked for __init__.
                const callResult = this.validateCallArguments(
                    errorNode,
                    argList,
                    constructorMethodInfo,
                    typeVarContext,
                    skipUnknownArgCheck
                );

                if (callResult.argumentErrors) {
                    reportedErrors = true;
                } else {
                    let newReturnType = callResult.returnType;

                    if (callResult.isTypeIncomplete) {
                        isTypeIncomplete = true;
                    }

                    // If the constructor returned an object whose type matches the class of
                    // the original type being constructed, use the return type in case it was
                    // specialized. If it doesn't match, we'll fall back on the assumption that
                    // the constructed type is an instance of the class type. We need to do this
                    // in cases where we're inferring the return type based on a call to
                    // super().__new__().
                    if (newReturnType) {
                        if (isClassInstance(newReturnType) && ClassType.isSameGenericClass(newReturnType, type)) {
                            // If the specialized return type derived from the __init__
                            // method is "better" than the return type provided by the
                            // __new__ method (where "better" means that the type arguments
                            // are all known), stick with the __init__ result.
                            if (
                                (!isPartlyUnknown(newReturnType) && !requiresSpecialization(newReturnType)) ||
                                returnType === undefined
                            ) {
                                // Special-case the 'tuple' type specialization to use
                                // the homogenous arbitrary-length form.
                                if (
                                    isClassInstance(newReturnType) &&
                                    ClassType.isTupleClass(newReturnType) &&
                                    !newReturnType.tupleTypeArguments &&
                                    newReturnType.typeArguments &&
                                    newReturnType.typeArguments.length === 1
                                ) {
                                    newReturnType = specializeTupleClass(newReturnType, [
                                        { type: newReturnType.typeArguments[0], isUnbounded: true },
                                    ]);
                                }

                                returnType = newReturnType;
                            }
                        } else if (!returnType && !isUnknown(newReturnType)) {
                            returnType = newReturnType;
                        }
                    }
                }

                if (!returnType) {
                    returnType = this.applyExpectedTypeForConstructor(type, expectedType, typeVarContext);
                } else if (isClassInstance(returnType) && isTupleClass(returnType) && !returnType.tupleTypeArguments) {
                    returnType = this.applyExpectedTypeForTupleConstructor(returnType, expectedType);
                }
                validatedTypes = true;
            }
        }

        // If we weren't able to validate the args, analyze the expressions
        // here to mark symbols as referenced and report expression-level errors.
        if (!validatedTypes) {
            argList.forEach((arg) => {
                if (arg.valueExpression && !this._speculativeTypeTracker.isSpeculative(arg.valueExpression)) {
                    this.getTypeOfExpression(arg.valueExpression);
                }
            });
        }

        if (!validatedTypes && argList.some((arg) => arg.argumentCategory === ArgumentCategory.Simple)) {
            // Suppress this error if the class was instantiated from a custom
            // metaclass because it's likely that it's a false positive. Also
            // suppress the error if the class's metaclass has a __call__ method.
            const isCustomMetaclass =
                !!type.details.effectiveMetaclass &&
                isInstantiableClass(type.details.effectiveMetaclass) &&
                !ClassType.isBuiltIn(type.details.effectiveMetaclass);

            if (!isCustomMetaclass && !usedMetaclassCallMethod) {
                const fileInfo = AnalyzerNodeInfo.getFileInfo(errorNode);
                this.addDiagnostic(
                    fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                    DiagnosticRule.reportGeneralTypeIssues,
                    Localizer.Diagnostic.constructorNoArgs().format({ type: type.aliasName || type.details.name }),
                    errorNode
                );
            }
        }

        if (!returnType) {
            // There was no __init__ or __new__ method or we couldn't match the provided
            // arguments to them.
            if (!expectedType && type.typeArguments) {
                // If there was no expected type but the type was already specialized,
                // assume that we're constructing an instance of the specialized type.
                returnType = convertToInstance(type);
            } else {
                // Do our best to specialize the instantiated class based on the expected
                // type if provided.
                const typeVarContext = new TypeVarContext(getTypeVarScopeId(type));

                if (expectedType) {
                    populateTypeVarContextBasedOnExpectedType(
                        this,
                        ClassType.cloneAsInstance(type),
                        expectedType,
                        typeVarContext,
                        this.getTypeVarScopesForNode(errorNode)
                    );
                }

                returnType = this.applyExpectedTypeForConstructor(type, expectedType, typeVarContext);
            }
        }

        if (!reportedErrors) {
            const transformed = applyConstructorTransform(this, errorNode, argList, type, {
                argumentErrors: reportedErrors,
                returnType,
                isTypeIncomplete,
            });

            returnType = transformed.returnType;

            if (transformed.isTypeIncomplete) {
                isTypeIncomplete = true;
            }

            if (transformed.argumentErrors) {
                reportedErrors = true;
            }
        }

        const result: CallResult = { argumentErrors: reportedErrors, returnType, isTypeIncomplete };

        return result;
    }

    // For a constructor call that targets a generic class and an "expected type"
    // (i.e. bidirectional inference), this function attempts to infer the correct
    // specialized return type for the constructor.
    validateConstructorMethodWithExpectedType(
        errorNode: ExpressionNode,
        argList: FunctionArgument[],
        type: ClassType,
        skipUnknownArgCheck: boolean,
        expectedType: Type,
        constructorMethodType: Type
    ): CallResult | undefined {
        let isTypeIncomplete = false;
        let argumentErrors = false;

        const returnType = mapSubtypes(expectedType, (expectedSubType) => {
            expectedSubType = transformPossibleRecursiveTypeAlias(expectedSubType);
            const typeVarContext = new TypeVarContext(getTypeVarScopeId(type));
            if (
                populateTypeVarContextBasedOnExpectedType(
                    this,
                    ClassType.cloneAsInstance(type),
                    expectedSubType,
                    typeVarContext,
                    this.getTypeVarScopesForNode(errorNode)
                )
            ) {
                let callResult: CallResult | undefined;
                this.useSpeculativeMode(errorNode, () => {
                    callResult = this.validateCallArguments(
                        errorNode,
                        argList,
                        { type: constructorMethodType },
                        typeVarContext.clone(),
                        skipUnknownArgCheck
                    );
                });

                if (!callResult?.argumentErrors) {
                    // Call validateCallArguments again, this time without speculative
                    // mode, so any errors are reported.
                    const callResult = this.validateCallArguments(
                        errorNode,
                        argList,
                        { type: constructorMethodType },
                        typeVarContext,
                        skipUnknownArgCheck
                    );

                    if (callResult.isTypeIncomplete) {
                        isTypeIncomplete = true;
                    }

                    if (callResult.argumentErrors) {
                        argumentErrors = true;
                    }

                    return this.applyExpectedSubtypeForConstructor(type, expectedSubType, typeVarContext);
                }
            }

            return undefined;
        });

        if (isNever(returnType)) {
            return undefined;
        }

        return { returnType, isTypeIncomplete, argumentErrors };
    }

    applyExpectedSubtypeForConstructor(
        type: ClassType,
        expectedSubtype: Type,
        typeVarContext: TypeVarContext
    ): Type | undefined {
        const specializedType = applySolvedTypeVars(ClassType.cloneAsInstance(type), typeVarContext);

        if (!this.assignType(expectedSubtype, specializedType)) {
            return undefined;
        }

        // If the expected type is "Any", transform it to an Any.
        if (isAny(expectedSubtype)) {
            return expectedSubtype;
        }

        return specializedType;
    }

    // Handles the case where a constructor is a generic type and the type
    // arguments are not specified but can be provided by the expected type.
    applyExpectedTypeForConstructor(
        type: ClassType,
        expectedType: Type | undefined,
        typeVarContext: TypeVarContext
    ): Type {
        let unsolvedTypeVarsAreUnknown = true;

        if (expectedType) {
            const specializedExpectedType = mapSubtypes(expectedType, (expectedSubtype) => {
                return this.applyExpectedSubtypeForConstructor(type, expectedSubtype, typeVarContext);
            });

            if (!isNever(specializedExpectedType)) {
                return specializedExpectedType;
            }

            // If the expected type didn't provide TypeVar values, remaining
            // unsolved TypeVars should be considered Unknown unless they were
            // provided explicitly in the constructor call.
            if (type.typeArguments) {
                unsolvedTypeVarsAreUnknown = false;
            }
        }

        const specializedType = applySolvedTypeVars(type, typeVarContext, unsolvedTypeVarsAreUnknown) as ClassType;
        return ClassType.cloneAsInstance(specializedType);
    }

    // Similar to applyExpectedTypeForConstructor, this function handles the
    // special case of the tuple class.
    applyExpectedTypeForTupleConstructor(type: ClassType, expectedType: Type | undefined) {
        let specializedType = type;

        if (
            expectedType &&
            isClassInstance(expectedType) &&
            isTupleClass(expectedType) &&
            expectedType.tupleTypeArguments
        ) {
            specializedType = specializeTupleClass(type, expectedType.tupleTypeArguments);
        }

        return specializedType;
    }

    // Validates that the arguments can be assigned to the call's parameter
    // list, specializes the call based on arg types, and returns the
    // specialized type of the return value. If it detects an error along
    // the way, it emits a diagnostic and sets argumentErrors to true.
    validateCallArguments(
        errorNode: ExpressionNode,
        argList: FunctionArgument[],
        callTypeResult: TypeResult,
        typeVarContext?: TypeVarContext,
        skipUnknownArgCheck = false,
        expectedType?: Type,
        recursionCount = 0
    ): CallResult {
        let argumentErrors = false;
        let isTypeIncomplete = false;
        let specializedInitSelfType: Type | undefined;

        if (recursionCount > maxTypeRecursionCount) {
            return { returnType: UnknownType.create(), argumentErrors: true };
        }
        recursionCount++;

        if (TypeBase.isSpecialForm(callTypeResult.type)) {
            const exprNode = errorNode.nodeType === ParseNodeType.Call ? errorNode.leftExpression : errorNode;
            this.addDiagnostic(
                AnalyzerNodeInfo.getFileInfo(errorNode).diagnosticRuleSet.reportGeneralTypeIssues,
                DiagnosticRule.reportGeneralTypeIssues,
                Localizer.Diagnostic.typeNotCallable().format({
                    expression: ParseTreeUtils.printExpression(exprNode),
                    type: this.printType(callTypeResult.type, { expandTypeAlias: true }),
                }),
                exprNode
            );
            return { returnType: UnknownType.create(), argumentErrors: true };
        }

        const returnType = this.mapSubtypesExpandTypeVars(
            callTypeResult.type,
            /* conditionFilter */ undefined,
            (expandedSubtype, unexpandedSubtype) => {
                switch (expandedSubtype.category) {
                    case TypeCategory.Unknown:
                    case TypeCategory.Any: {
                        // Touch all of the args so they're marked accessed. Don't bother
                        // doing this if the call type is incomplete because this will need
                        // to be done again once it is complete.
                        if (!callTypeResult.isIncomplete) {
                            argList.forEach((arg) => {
                                if (
                                    arg.valueExpression &&
                                    !this._speculativeTypeTracker.isSpeculative(arg.valueExpression)
                                ) {
                                    this.getTypeOfArgument(arg);
                                }
                            });
                        }

                        return expandedSubtype;
                    }

                    case TypeCategory.Function: {
                        // The stdlib collections/__init__.pyi stub file defines namedtuple
                        // as a function rather than a class, so we need to check for it here.
                        if (expandedSubtype.details.builtInName === 'namedtuple') {
                            this.addDiagnostic(
                                AnalyzerNodeInfo.getFileInfo(errorNode).diagnosticRuleSet.reportUntypedNamedTuple,
                                DiagnosticRule.reportUntypedNamedTuple,
                                Localizer.Diagnostic.namedTupleNoTypes(),
                                errorNode
                            );
                            return createNamedTupleType(this, errorNode, argList, /* includesTypes */ false);
                        }

                        // Handle the NewType specially, replacing the normal return type.
                        if (expandedSubtype.details.builtInName === 'NewType') {
                            return this.createNewType(errorNode, argList);
                        }

                        let effectiveTypeVarContext = typeVarContext;
                        if (!effectiveTypeVarContext) {
                            // If a typeVarContext wasn't provided by the caller, allocate one here.
                            effectiveTypeVarContext = new TypeVarContext(getTypeVarScopeId(expandedSubtype));

                            // There are certain cases, such as with super().__new__(cls) calls where
                            // the call is a constructor but the proper TypeVar scope has been lost.
                            // We'll add a wildcard TypeVar scope here. This is a bit of a hack and
                            // we may need to revisit this in the future.
                            if (FunctionType.isConstructorMethod(expandedSubtype)) {
                                effectiveTypeVarContext.addSolveForScope(WildcardTypeVarScopeId);
                            }
                        }

                        const functionResult = this.validateFunctionArguments(
                            errorNode,
                            argList,
                            expandedSubtype,
                            effectiveTypeVarContext,
                            skipUnknownArgCheck,
                            expectedType
                        );

                        if (functionResult.isTypeIncomplete) {
                            isTypeIncomplete = true;
                        }

                        if (functionResult.argumentErrors) {
                            argumentErrors = true;
                        } else {
                            specializedInitSelfType = functionResult.specializedInitSelfType;

                            // Call the function transform logic to handle special-cased functions.
                            const transformed = applyFunctionTransform(this, errorNode, argList, expandedSubtype, {
                                argumentErrors: functionResult.argumentErrors,
                                returnType: functionResult.returnType ?? UnknownType.create(isTypeIncomplete),
                                isTypeIncomplete,
                            });

                            functionResult.returnType = transformed.returnType;
                            if (transformed.isTypeIncomplete) {
                                isTypeIncomplete = true;
                            }
                            if (transformed.argumentErrors) {
                                argumentErrors = true;
                            }
                        }

                        if (expandedSubtype.details.builtInName === '__import__') {
                            // For the special __import__ type, we'll override the return type to be "Any".
                            // This is required because we don't know what module was imported, and we don't
                            // want to fail type checks when accessing members of the resulting module type.
                            return AnyType.create();
                        }

                        return functionResult.returnType;
                    }

                    case TypeCategory.OverloadedFunction: {
                        // Handle the 'cast' call as a special case.
                        if (expandedSubtype.overloads[0].details.builtInName === 'cast' && argList.length === 2) {
                            // Verify that the cast is necessary.
                            const castToType = this.getTypeOfArgumentExpectingType(argList[0]).type;
                            const castFromType = this.getTypeOfArgument(argList[1]).type;
                            if (isInstantiableClass(castToType) && isClassInstance(castFromType)) {
                                if (
                                    isTypeSame(castToType, ClassType.cloneAsInstantiable(castFromType), {
                                        ignorePseudoGeneric: true,
                                    })
                                ) {
                                    this.addDiagnostic(
                                        AnalyzerNodeInfo.getFileInfo(errorNode).diagnosticRuleSet.reportUnnecessaryCast,
                                        DiagnosticRule.reportUnnecessaryCast,
                                        Localizer.Diagnostic.unnecessaryCast().format({
                                            type: this.printType(castFromType),
                                        }),
                                        errorNode
                                    );
                                }
                            }

                            return convertToInstance(castToType);
                        }

                        const functionResult = this.validateOverloadedFunctionArguments(
                            errorNode,
                            argList,
                            expandedSubtype,
                            typeVarContext,
                            skipUnknownArgCheck,
                            expectedType
                        );

                        if (functionResult.isTypeIncomplete) {
                            isTypeIncomplete = true;
                        }

                        if (functionResult.argumentErrors) {
                            argumentErrors = true;
                        } else {
                            specializedInitSelfType = functionResult.specializedInitSelfType;

                            // Call the function transform logic to handle special-cased functions.
                            const transformed = applyFunctionTransform(this, errorNode, argList, expandedSubtype, {
                                argumentErrors: functionResult.argumentErrors,
                                returnType: functionResult.returnType ?? UnknownType.create(isTypeIncomplete),
                                isTypeIncomplete,
                            });

                            functionResult.returnType = transformed.returnType;
                            if (transformed.isTypeIncomplete) {
                                isTypeIncomplete = true;
                            }
                            if (transformed.argumentErrors) {
                                argumentErrors = true;
                            }
                        }

                        return functionResult.returnType ?? UnknownType.create();
                    }

                    case TypeCategory.Class: {
                        if (TypeBase.isInstantiable(expandedSubtype)) {
                            if (expandedSubtype.literalValue !== undefined) {
                                this.addDiagnostic(
                                    AnalyzerNodeInfo.getFileInfo(errorNode).diagnosticRuleSet.reportGeneralTypeIssues,
                                    DiagnosticRule.reportGeneralTypeIssues,
                                    Localizer.Diagnostic.literalNotCallable(),
                                    errorNode
                                );
                                argumentErrors = true;
                                return UnknownType.create();
                            }

                            if (ClassType.isBuiltIn(expandedSubtype)) {
                                const className = expandedSubtype.aliasName || expandedSubtype.details.name;

                                if (className === 'type') {
                                    // Validate the constructor arguments.
                                    this.validateConstructorArguments(
                                        errorNode,
                                        argList,
                                        expandedSubtype,
                                        skipUnknownArgCheck,
                                        expectedType
                                    );

                                    // Handle the 'type' call specially.
                                    if (argList.length === 1) {
                                        // The one-parameter form of "type" returns the class
                                        // for the specified object.
                                        const argType = this.getTypeOfArgument(argList[0]).type;
                                        return mapSubtypes(argType, (subtype) => {
                                            if (
                                                isClassInstance(subtype) ||
                                                (isTypeVar(subtype) && TypeBase.isInstance(subtype)) ||
                                                isNoneInstance(subtype)
                                            ) {
                                                return convertToInstantiable(this.stripLiteralValue(subtype));
                                            }

                                            return AnyType.create();
                                        });
                                    } else if (argList.length >= 2) {
                                        // The two-parameter form of "type" returns a new class type
                                        // built from the specified base types.
                                        return this.createType(errorNode, argList) || AnyType.create();
                                    }

                                    // If the parameter to type() is not statically known,
                                    // fall back to Any.
                                    return AnyType.create();
                                }

                                if (className === 'TypeVar') {
                                    return this.createTypeVarType(errorNode, argList);
                                }

                                if (className === 'TypeVarTuple') {
                                    return this.createTypeVarTupleType(errorNode, argList);
                                }

                                if (className === 'ParamSpec') {
                                    return this.createParamSpecType(errorNode, argList);
                                }

                                if (className === 'NamedTuple') {
                                    return createNamedTupleType(this, errorNode, argList, /* includesTypes */ true);
                                }

                                if (className === 'NewType') {
                                    return this.createNewType(errorNode, argList);
                                }

                                if (
                                    className === 'Protocol' ||
                                    className === 'Generic' ||
                                    className === 'Callable' ||
                                    className === 'Concatenate' ||
                                    className === 'Type'
                                ) {
                                    const fileInfo = AnalyzerNodeInfo.getFileInfo(errorNode);
                                    this.addDiagnostic(
                                        fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                                        DiagnosticRule.reportGeneralTypeIssues,
                                        Localizer.Diagnostic.typeNotIntantiable().format({ type: className }),
                                        errorNode
                                    );
                                    return AnyType.create();
                                }

                                if (isClass(unexpandedSubtype) && isKnownEnumType(className)) {
                                    return createEnumType(errorNode, expandedSubtype, argList);
                                }

                                if (className === 'TypedDict') {
                                    return createTypedDictType(this, errorNode, expandedSubtype, argList);
                                }

                                if (className === 'auto' && argList.length === 0) {
                                    return getEnumAutoValueType(this, errorNode);
                                }
                            }

                            if (ClassType.supportsAbstractMethods(expandedSubtype)) {
                                const abstractMethods = this.getAbstractMethods(expandedSubtype);
                                if (
                                    abstractMethods.length > 0 &&
                                    !expandedSubtype.includeSubclasses &&
                                    !isTypeVar(unexpandedSubtype)
                                ) {
                                    // If the class is abstract, it can't be instantiated.
                                    const diagAddendum = new DiagnosticAddendum();
                                    const errorsToDisplay = 2;

                                    abstractMethods.forEach((abstractMethod, index) => {
                                        if (index === errorsToDisplay) {
                                            diagAddendum.addMessage(
                                                Localizer.DiagnosticAddendum.memberIsAbstractMore().format({
                                                    count: abstractMethods.length - errorsToDisplay,
                                                })
                                            );
                                        } else if (index < errorsToDisplay) {
                                            if (isInstantiableClass(abstractMethod.classType)) {
                                                const className = abstractMethod.classType.details.name;
                                                diagAddendum.addMessage(
                                                    Localizer.DiagnosticAddendum.memberIsAbstract().format({
                                                        type: className,
                                                        name: abstractMethod.symbolName,
                                                    })
                                                );
                                            }
                                        }
                                    });

                                    this.addDiagnostic(
                                        AnalyzerNodeInfo.getFileInfo(errorNode).diagnosticRuleSet
                                            .reportGeneralTypeIssues,
                                        DiagnosticRule.reportGeneralTypeIssues,
                                        Localizer.Diagnostic.instantiateAbstract().format({
                                            type: expandedSubtype.details.name,
                                        }) + diagAddendum.getString(),
                                        errorNode
                                    );
                                }
                            }

                            if (ClassType.isProtocolClass(expandedSubtype) && !expandedSubtype.includeSubclasses) {
                                // If the class is a protocol, it can't be instantiated.
                                this.addDiagnostic(
                                    AnalyzerNodeInfo.getFileInfo(errorNode).diagnosticRuleSet.reportGeneralTypeIssues,
                                    DiagnosticRule.reportGeneralTypeIssues,
                                    Localizer.Diagnostic.instantiateProtocol().format({
                                        type: expandedSubtype.details.name,
                                    }),
                                    errorNode
                                );
                            }

                            // Assume this is a call to the constructor.
                            const constructorResult = this.validateConstructorArguments(
                                errorNode,
                                argList,
                                expandedSubtype,
                                skipUnknownArgCheck,
                                expectedType
                            );

                            if (constructorResult.argumentErrors) {
                                argumentErrors = true;
                            }

                            if (constructorResult.isTypeIncomplete) {
                                isTypeIncomplete = true;
                            }

                            let returnType = constructorResult.returnType;

                            // If the expandedSubtype originated from a TypeVar, convert
                            // the constructed type back to the TypeVar. For example, if
                            // we have `cls: Type[_T]` followed by `_T()`.
                            if (isTypeVar(unexpandedSubtype)) {
                                returnType = convertToInstance(unexpandedSubtype);
                            }

                            // If we instantiated a type, transform it into a class.
                            // This can happen if someone directly instantiates a metaclass
                            // deriving from type.
                            if (
                                returnType &&
                                isClassInstance(returnType) &&
                                returnType.details.mro.some(
                                    (baseClass) =>
                                        isInstantiableClass(baseClass) && ClassType.isBuiltIn(baseClass, 'type')
                                )
                            ) {
                                let newClassName = '__class_' + returnType.details.name;
                                if (argList.length === 3) {
                                    const firstArgType = this.getTypeOfArgument(argList[0]).type;
                                    if (
                                        isClassInstance(firstArgType) &&
                                        ClassType.isBuiltIn(firstArgType, 'str') &&
                                        typeof firstArgType.literalValue === 'string'
                                    ) {
                                        newClassName = firstArgType.literalValue;
                                    }
                                }

                                const newClassType = ClassType.createInstantiable(
                                    newClassName,
                                    '',
                                    '',
                                    AnalyzerNodeInfo.getFileInfo(errorNode).filePath,
                                    ClassTypeFlags.None,
                                    ParseTreeUtils.getTypeSourceId(errorNode),
                                    ClassType.cloneAsInstantiable(returnType),
                                    ClassType.cloneAsInstantiable(returnType)
                                );
                                newClassType.details.baseClasses.push(this.getBuiltInType(errorNode, 'object'));
                                newClassType.details.effectiveMetaclass = expandedSubtype;
                                computeMroLinearization(newClassType);
                                return newClassType;
                            }

                            return returnType;
                        } else {
                            const memberType = this.getTypeOfObjectMember(errorNode, expandedSubtype, '__call__')?.type;

                            if (memberType) {
                                const functionResult = this.validateCallArguments(
                                    errorNode,
                                    argList,
                                    { type: memberType },
                                    typeVarContext,
                                    skipUnknownArgCheck,
                                    expectedType,
                                    recursionCount
                                );
                                if (functionResult.argumentErrors) {
                                    argumentErrors = true;
                                }

                                if (
                                    isTypeVar(unexpandedSubtype) &&
                                    TypeBase.isInstantiable(unexpandedSubtype) &&
                                    isClass(expandedSubtype) &&
                                    ClassType.isBuiltIn(expandedSubtype, 'type')
                                ) {
                                    // Handle the case where a Type[T] is being called. We presume this
                                    // will instantiate an object of type T.
                                    return convertToInstance(unexpandedSubtype);
                                }

                                return functionResult.returnType ?? UnknownType.create();
                            }

                            if (!memberType || !isAnyOrUnknown(memberType)) {
                                this.addDiagnostic(
                                    AnalyzerNodeInfo.getFileInfo(errorNode).diagnosticRuleSet.reportGeneralTypeIssues,
                                    DiagnosticRule.reportGeneralTypeIssues,
                                    Localizer.Diagnostic.objectNotCallable().format({
                                        type: this.printType(expandedSubtype),
                                    }),
                                    errorNode
                                );
                            }
                            return UnknownType.create();
                        }
                    }

                    case TypeCategory.None: {
                        this.addDiagnostic(
                            AnalyzerNodeInfo.getFileInfo(errorNode).diagnosticRuleSet.reportOptionalCall,
                            DiagnosticRule.reportOptionalCall,
                            Localizer.Diagnostic.noneNotCallable(),
                            errorNode
                        );
                        return undefined;
                    }

                    // TypeVars should have been expanded in most cases,
                    // but we still need to handle the case of Type[T] where
                    // T is a constrained type that contains a union. We also
                    // need to handle recursive type aliases.
                    case TypeCategory.TypeVar: {
                        expandedSubtype = transformPossibleRecursiveTypeAlias(expandedSubtype);

                        const callResult = this.validateCallArguments(
                            errorNode,
                            argList,
                            { type: expandedSubtype },
                            typeVarContext,
                            skipUnknownArgCheck,
                            expectedType,
                            recursionCount
                        );

                        if (callResult.argumentErrors) {
                            argumentErrors = true;
                        }

                        return callResult.returnType ?? UnknownType.create();
                    }

                    case TypeCategory.Module: {
                        this.addDiagnostic(
                            AnalyzerNodeInfo.getFileInfo(errorNode).diagnosticRuleSet.reportGeneralTypeIssues,
                            DiagnosticRule.reportGeneralTypeIssues,
                            Localizer.Diagnostic.moduleNotCallable(),
                            errorNode
                        );
                        return undefined;
                    }
                }

                return undefined;
            }
        );

        return {
            argumentErrors,
            returnType: isNever(returnType) && !returnType.isNoReturn ? undefined : returnType,
            isTypeIncomplete,
            specializedInitSelfType,
        };
    }

    // Expands any unpacked tuples within an argument list.
    expandArgList(argList: FunctionArgument[]): FunctionArgument[] {
        const expandedArgList: FunctionArgument[] = [];

        for (const arg of argList) {
            if (arg.argumentCategory === ArgumentCategory.UnpackedList) {
                const argType = this.getTypeOfArgument(arg).type;

                // If this is a tuple with specified element types, use those
                // specified types rather than using the more generic iterator
                // type which will be a union of all element types.
                const combinedArgType = combineSameSizedTuples(
                    this.makeTopLevelTypeVarsConcrete(argType),
                    this._tupleClassType
                );

                if (isClassInstance(combinedArgType) && isTupleClass(combinedArgType)) {
                    const tupleTypeArgs = combinedArgType.tupleTypeArguments ?? [];

                    if (tupleTypeArgs.length !== 1) {
                        for (const tupleTypeArg of tupleTypeArgs) {
                            if (tupleTypeArg.isUnbounded) {
                                expandedArgList.push({
                                    ...arg,
                                    argumentCategory: ArgumentCategory.UnpackedList,
                                    valueExpression: undefined,
                                    typeResult: {
                                        type: specializeTupleClass(combinedArgType, [tupleTypeArg]),
                                    },
                                });
                            } else {
                                expandedArgList.push({
                                    ...arg,
                                    argumentCategory: ArgumentCategory.Simple,
                                    valueExpression: undefined,
                                    typeResult: {
                                        type: tupleTypeArg.type,
                                    },
                                });
                            }
                        }
                        continue;
                    }
                }
            }

            expandedArgList.push(arg);
        }

        return expandedArgList;
    }

    // Matches the arguments passed to a function to the corresponding parameters in that
    // function. This matching is done based on positions and keywords. Type evaluation and
    // validation is left to the caller.
    // This logic is based on PEP 3102: https://www.python.org/dev/peps/pep-3102/
    matchFunctionArgumentsToParameters(
        errorNode: ExpressionNode,
        argList: FunctionArgument[],
        type: FunctionType,
        overloadIndex: number
    ): MatchArgsToParamsResult {
        const paramDetails = getParameterListDetails(type);
        let argIndex = 0;
        let matchedUnpackedListOfUnknownLength = false;
        let reportedArgError = false;
        let isTypeIncomplete = false;
        let isVariadicTypeVarFullyMatched = false;

        // Expand any unpacked tuples in the arg list.
        argList = this.expandArgList(argList);

        // Build a map of parameters by name.
        const paramMap = new Map<string, ParamAssignmentInfo>();
        paramDetails.params.forEach((paramInfo) => {
            const param = paramInfo.param;
            if (param.name && param.category === ParameterCategory.Simple) {
                paramMap.set(param.name, {
                    argsNeeded: param.category === ParameterCategory.Simple && !param.hasDefault ? 1 : 0,
                    argsReceived: 0,
                    isPositionalOnly: paramInfo.source === ParameterSource.PositionOnly,
                });
            }
        });

        let positionalOnlyLimitIndex = paramDetails.positionOnlyParamCount;
        let positionParamLimitIndex = paramDetails.firstKeywordOnlyIndex ?? paramDetails.params.length;

        const varArgListParamIndex = paramDetails.argsIndex;
        const varArgDictParamIndex = paramDetails.kwargsIndex;

        // Is this an function that uses the *args and **kwargs
        // from a param spec? If so, we need to treat all positional parameters
        // prior to the *args as positional-only according to PEP 612.
        let paramSpecArgList: FunctionArgument[] | undefined;
        let paramSpecTarget: TypeVarType | undefined;
        let hasParamSpecArgsKwargs = false;

        if (varArgListParamIndex !== undefined && varArgDictParamIndex !== undefined) {
            assert(paramDetails.params[varArgListParamIndex], 'varArgListParamIndex params entry is undefined');
            const varArgListParam = paramDetails.params[varArgListParamIndex].param;
            assert(paramDetails.params[varArgDictParamIndex], 'varArgDictParamIndex params entry is undefined');
            const varArgDictParam = paramDetails.params[varArgDictParamIndex].param;

            if (
                isParamSpec(varArgListParam.type) &&
                varArgListParam.type.paramSpecAccess === 'args' &&
                isParamSpec(varArgDictParam.type) &&
                varArgDictParam.type.paramSpecAccess === 'kwargs' &&
                varArgListParam.type.details.name === varArgDictParam.type.details.name
            ) {
                hasParamSpecArgsKwargs = true;

                // Does this function define the param spec, or is it an inner
                // function nested within another function that defines the param
                // spec? We need to handle these two cases differently.
                if (
                    varArgListParam.type.scopeId === type.details.typeVarScopeId ||
                    varArgListParam.type.scopeId === type.details.constructorTypeVarScopeId
                ) {
                    paramSpecArgList = [];
                    paramSpecTarget = TypeVarType.cloneForParamSpecAccess(varArgListParam.type, /* access */ undefined);
                } else {
                    positionalOnlyLimitIndex = varArgListParamIndex;
                }
            }
        }

        // If there are keyword arguments present after a *args argument,
        // the keyword arguments may target one or more parameters that are positional.
        // In this case, we will limit the number of positional parameters so the
        // *args doesn't consume them all.
        if (argList.some((arg) => arg.argumentCategory === ArgumentCategory.UnpackedList)) {
            argList.forEach((arg) => {
                if (arg.name) {
                    const keywordParamIndex = paramDetails.params.findIndex(
                        (paramInfo) =>
                            paramInfo.param.name === arg.name!.value &&
                            paramInfo.param.category === ParameterCategory.Simple
                    );

                    // Is this a parameter that can be interpreted as either a keyword or a positional?
                    // If so, we'll treat it as a keyword parameter in this case because it's being
                    // targeted by a keyword argument.
                    if (keywordParamIndex >= 0 && keywordParamIndex >= positionalOnlyLimitIndex) {
                        if (positionParamLimitIndex < 0 || keywordParamIndex < positionParamLimitIndex) {
                            positionParamLimitIndex = keywordParamIndex;
                        }
                    }
                }
            });
        }

        // If we didn't see any special cases, then all parameters are positional.
        if (positionParamLimitIndex < 0) {
            positionParamLimitIndex = paramDetails.params.length;
        }

        // Determine how many positional args are being passed before
        // we see a keyword arg.
        let positionalArgCount = argList.findIndex(
            (arg) => arg.argumentCategory === ArgumentCategory.UnpackedDictionary || arg.name !== undefined
        );
        if (positionalArgCount < 0) {
            positionalArgCount = argList.length;
        }

        let validateArgTypeParams: ValidateArgTypeParams[] = [];

        let activeParam: FunctionParameter | undefined;
        function trySetActive(arg: FunctionArgument, param: FunctionParameter) {
            if (arg.active) {
                activeParam = param;
            }
        }

        const foundUnpackedListArg =
            argList.find((arg) => arg.argumentCategory === ArgumentCategory.UnpackedList) !== undefined;

        // Map the positional args to parameters.
        let paramIndex = 0;

        while (argIndex < positionalArgCount) {
            if (argIndex < positionalOnlyLimitIndex && argList[argIndex].name) {
                const fileInfo = AnalyzerNodeInfo.getFileInfo(argList[argIndex].name!);
                this.addDiagnostic(
                    fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                    DiagnosticRule.reportGeneralTypeIssues,
                    Localizer.Diagnostic.argPositional(),
                    argList[argIndex].name!
                );
                reportedArgError = true;
            }

            const remainingArgCount = positionalArgCount - argIndex;
            const remainingParamCount = positionParamLimitIndex - paramIndex - 1;

            if (paramIndex >= positionParamLimitIndex) {
                if (!type.details.paramSpec) {
                    let tooManyPositionals = false;

                    if (foundUnpackedListArg && argList[argIndex].argumentCategory === ArgumentCategory.UnpackedList) {
                        // If this is an unpacked iterable, we will conservatively assume that it
                        // might have zero iterations unless we can tell from its type that it
                        // definitely has at least one iterable value.
                        const argType = this.getTypeOfArgument(argList[argIndex]).type;

                        if (
                            isClassInstance(argType) &&
                            isTupleClass(argType) &&
                            !isUnboundedTupleClass(argType) &&
                            argType.tupleTypeArguments !== undefined &&
                            argType.tupleTypeArguments.length > 0
                        ) {
                            tooManyPositionals = true;
                        }
                    } else {
                        tooManyPositionals = true;
                    }

                    if (tooManyPositionals) {
                        this.addDiagnostic(
                            AnalyzerNodeInfo.getFileInfo(errorNode).diagnosticRuleSet.reportGeneralTypeIssues,
                            DiagnosticRule.reportGeneralTypeIssues,
                            positionParamLimitIndex === 1
                                ? Localizer.Diagnostic.argPositionalExpectedOne()
                                : Localizer.Diagnostic.argPositionalExpectedCount().format({
                                      expected: positionParamLimitIndex,
                                  }),
                            argList[argIndex].valueExpression ?? errorNode
                        );
                        reportedArgError = true;
                    }
                }
                break;
            }

            if (paramIndex >= paramDetails.params.length) {
                break;
            }

            assert(paramDetails.params[paramIndex], 'paramIndex params entry is undefined');
            const paramType = paramDetails.params[paramIndex].type;
            const paramName = paramDetails.params[paramIndex].param.name;

            const isParamVariadic =
                paramDetails.params[paramIndex].param.category === ParameterCategory.VarArgList &&
                isVariadicTypeVar(paramType);

            if (argList[argIndex].argumentCategory === ArgumentCategory.UnpackedList) {
                let isArgCompatibleWithVariadic = false;
                const argTypeResult = this.getTypeOfArgument(argList[argIndex]);
                let listElementType: Type | undefined;
                let advanceToNextArg = false;

                // Handle the case where *args is being passed to a function defined
                // with a ParamSpec and a Concatenate operator. PEP 612 indicates that
                // all positional parameters specified in the Concatenate must be
                // filled explicitly.
                if (type.details.paramSpec && paramIndex < positionParamLimitIndex) {
                    this.addDiagnostic(
                        AnalyzerNodeInfo.getFileInfo(errorNode).diagnosticRuleSet.reportGeneralTypeIssues,
                        DiagnosticRule.reportGeneralTypeIssues,
                        positionParamLimitIndex === 1
                            ? Localizer.Diagnostic.argPositionalExpectedOne()
                            : Localizer.Diagnostic.argPositionalExpectedCount().format({
                                  expected: positionParamLimitIndex,
                              }),
                        argList[argIndex].valueExpression ?? errorNode
                    );
                    reportedArgError = true;
                }

                const argType = argTypeResult.type;

                if (isParamVariadic && isUnpackedVariadicTypeVar(argType)) {
                    // Allow an unpacked variadic type variable to satisfy an
                    // unpacked variadic type variable.
                    listElementType = argType;
                    isArgCompatibleWithVariadic = true;
                    advanceToNextArg = true;
                    isVariadicTypeVarFullyMatched = true;
                } else if (
                    isClassInstance(argType) &&
                    isTupleClass(argType) &&
                    argType.tupleTypeArguments &&
                    argType.tupleTypeArguments.length === 1 &&
                    isUnpackedVariadicTypeVar(argType.tupleTypeArguments[0].type)
                ) {
                    // Handle the case where an unpacked variadic type var has
                    // been packaged into a tuple.
                    listElementType = argType.tupleTypeArguments[0].type;
                    isArgCompatibleWithVariadic = true;
                    advanceToNextArg = true;
                    isVariadicTypeVarFullyMatched = true;
                } else if (isParamVariadic && isClassInstance(argType) && isTupleClass(argType)) {
                    // Handle the case where an unpacked tuple argument is
                    // matched to a TypeVarTuple parameter.
                    isArgCompatibleWithVariadic = true;
                    advanceToNextArg = true;

                    // Determine whether we should treat the variadic type as fully matched.
                    // This depends on how many args and unmatched parameters exist.
                    if (remainingArgCount < remainingParamCount) {
                        isVariadicTypeVarFullyMatched = true;
                    }

                    listElementType = ClassType.cloneForUnpacked(argType);
                } else if (isParamSpec(argType) && argType.paramSpecAccess === 'args') {
                    listElementType = undefined;
                } else {
                    listElementType =
                        this.getTypeOfIterator(
                            { type: argType, isIncomplete: argTypeResult.isIncomplete },
                            /* isAsync */ false,
                            argList[argIndex].valueExpression!
                        )?.type ?? UnknownType.create();

                    if (paramDetails.params[paramIndex].param.category !== ParameterCategory.VarArgList) {
                        matchedUnpackedListOfUnknownLength = true;
                    }
                }

                const funcArg: FunctionArgument | undefined = listElementType
                    ? {
                          argumentCategory: ArgumentCategory.Simple,
                          typeResult: { type: listElementType, isIncomplete: argTypeResult.isIncomplete },
                      }
                    : undefined;
                if (funcArg && argTypeResult.isIncomplete) {
                    isTypeIncomplete = true;
                }

                // It's not allowed to use unpacked arguments with a variadic *args
                // parameter unless the argument is a variadic arg as well.
                if (isParamVariadic && !isArgCompatibleWithVariadic) {
                    this.addDiagnostic(
                        AnalyzerNodeInfo.getFileInfo(errorNode).diagnosticRuleSet.reportGeneralTypeIssues,
                        DiagnosticRule.reportGeneralTypeIssues,
                        Localizer.Diagnostic.unpackedArgWithVariadicParam(),
                        argList[argIndex].valueExpression || errorNode
                    );
                    reportedArgError = true;
                } else {
                    if (paramSpecArgList) {
                        paramSpecArgList.push(argList[argIndex]);
                    }

                    if (funcArg) {
                        validateArgTypeParams.push({
                            paramCategory: paramDetails.params[paramIndex].param.category,
                            paramType,
                            requiresTypeVarMatching: requiresSpecialization(paramType),
                            argument: funcArg,
                            errorNode: argList[argIndex].valueExpression || errorNode,
                            paramName,
                            isParamNameSynthesized: paramDetails.params[paramIndex].param.isNameSynthesized,
                            mapsToVarArgList: isParamVariadic && remainingArgCount > remainingParamCount,
                        });
                    }
                }

                trySetActive(argList[argIndex], paramDetails.params[paramIndex].param);

                // Note that the parameter has received an argument.
                if (
                    paramName &&
                    paramDetails.params[paramIndex].param.category === ParameterCategory.Simple &&
                    paramMap.has(paramName)
                ) {
                    paramMap.get(paramName)!.argsReceived++;
                }

                if (
                    advanceToNextArg ||
                    paramDetails.params[paramIndex].param.category === ParameterCategory.VarArgList
                ) {
                    argIndex++;
                }

                if (
                    isVariadicTypeVarFullyMatched ||
                    paramDetails.params[paramIndex].param.category !== ParameterCategory.VarArgList
                ) {
                    paramIndex++;
                }
            } else if (paramDetails.params[paramIndex].param.category === ParameterCategory.VarArgList) {
                trySetActive(argList[argIndex], paramDetails.params[paramIndex].param);

                if (paramSpecArgList) {
                    paramSpecArgList.push(argList[argIndex]);
                    argIndex++;
                } else {
                    let paramCategory = paramDetails.params[paramIndex].param.category;
                    let effectiveParamType = paramType;
                    const paramName = paramDetails.params[paramIndex].param.name;

                    if (
                        isUnpackedClass(paramType) &&
                        paramType.tupleTypeArguments &&
                        paramType.tupleTypeArguments.length > 0
                    ) {
                        effectiveParamType = paramType.tupleTypeArguments[0].type;
                    }

                    paramCategory = isVariadicTypeVar(effectiveParamType)
                        ? ParameterCategory.VarArgList
                        : ParameterCategory.Simple;

                    if (remainingArgCount <= remainingParamCount) {
                        if (remainingArgCount < remainingParamCount) {
                            // Have we run out of arguments and still have parameters left to fill?
                            this.addDiagnostic(
                                AnalyzerNodeInfo.getFileInfo(errorNode).diagnosticRuleSet.reportGeneralTypeIssues,
                                DiagnosticRule.reportGeneralTypeIssues,
                                remainingArgCount === 1
                                    ? Localizer.Diagnostic.argMorePositionalExpectedOne()
                                    : Localizer.Diagnostic.argMorePositionalExpectedCount().format({
                                          expected: remainingArgCount,
                                      }),
                                argList[argIndex].valueExpression || errorNode
                            );
                            reportedArgError = true;
                        }

                        paramIndex++;
                    } else {
                        validateArgTypeParams.push({
                            paramCategory,
                            paramType: effectiveParamType,
                            requiresTypeVarMatching: requiresSpecialization(paramType),
                            argument: argList[argIndex],
                            errorNode: argList[argIndex].valueExpression || errorNode,
                            paramName,
                            isParamNameSynthesized: paramDetails.params[paramIndex].param.isNameSynthesized,
                            mapsToVarArgList: true,
                        });

                        argIndex++;
                    }
                }
            } else {
                const paramName = paramDetails.params[paramIndex].param.name;
                validateArgTypeParams.push({
                    paramCategory: paramDetails.params[paramIndex].param.category,
                    paramType,
                    requiresTypeVarMatching: requiresSpecialization(paramType),
                    argument: argList[argIndex],
                    errorNode: argList[argIndex].valueExpression || errorNode,
                    paramName,
                    isParamNameSynthesized: paramDetails.params[paramIndex].param.isNameSynthesized,
                });
                trySetActive(argList[argIndex], paramDetails.params[paramIndex].param);

                // Note that the parameter has received an argument.
                if (paramName && paramMap.has(paramName)) {
                    paramMap.get(paramName)!.argsReceived++;
                }

                argIndex++;
                paramIndex++;
            }
        }

        // If there weren't enough positional arguments to populate all of the
        // positional-only parameters and the next positional-only parameter is
        // an unbounded tuple, skip past it.
        let skippedArgsParam = false;
        if (
            positionalOnlyLimitIndex >= 0 &&
            paramIndex < positionalOnlyLimitIndex &&
            paramDetails.params[paramIndex].param.category === ParameterCategory.VarArgList &&
            !isParamSpec(paramDetails.params[paramIndex].param.type)
        ) {
            paramIndex++;
            skippedArgsParam = true;
        }

        // Check if there weren't enough positional arguments to populate all of
        // the positional-only parameters.
        if (
            positionalOnlyLimitIndex >= 0 &&
            paramIndex < positionalOnlyLimitIndex &&
            (!foundUnpackedListArg || hasParamSpecArgsKwargs)
        ) {
            const firstParamWithDefault = paramDetails.params.findIndex((paramInfo) => paramInfo.param.hasDefault);
            const positionOnlyWithoutDefaultsCount =
                firstParamWithDefault >= 0 && firstParamWithDefault < positionalOnlyLimitIndex
                    ? firstParamWithDefault
                    : positionalOnlyLimitIndex;

            // Calculate the number of remaining positional parameters to report.
            let argsRemainingCount = positionOnlyWithoutDefaultsCount - positionalArgCount;
            if (skippedArgsParam) {
                // If we skipped an args parameter above, reduce the count by one
                // because it's permitted to pass zero arguments to *args.
                argsRemainingCount--;
            }

            const firstArgsParam = paramDetails.params.findIndex(
                (paramInfo) =>
                    paramInfo.param.category === ParameterCategory.VarArgList && !isParamSpec(paramInfo.param.type)
            );
            if (firstArgsParam >= paramIndex && firstArgsParam < positionalOnlyLimitIndex) {
                // If there is another args parameter beyond the current param index,
                // reduce the count by one because it's permitted to pass zero arguments
                // to *args.
                argsRemainingCount--;
            }

            if (argsRemainingCount > 0) {
                this.addDiagnostic(
                    AnalyzerNodeInfo.getFileInfo(errorNode).diagnosticRuleSet.reportGeneralTypeIssues,
                    DiagnosticRule.reportGeneralTypeIssues,
                    argsRemainingCount === 1
                        ? Localizer.Diagnostic.argMorePositionalExpectedOne()
                        : Localizer.Diagnostic.argMorePositionalExpectedCount().format({
                              expected: argsRemainingCount,
                          }),
                    argList.length > positionalArgCount
                        ? argList[positionalArgCount].valueExpression || errorNode
                        : errorNode
                );
                reportedArgError = true;
            }
        }

        if (!reportedArgError) {
            let unpackedDictionaryArgType: Type | undefined;

            // Now consume any keyword arguments.
            while (argIndex < argList.length) {
                if (argList[argIndex].argumentCategory === ArgumentCategory.UnpackedDictionary) {
                    // Verify that the type used in this expression is a Mapping[str, T].
                    const argType = this.getTypeOfArgument(argList[argIndex]).type;
                    if (isAnyOrUnknown(argType)) {
                        unpackedDictionaryArgType = argType;
                    } else if (isClassInstance(argType) && ClassType.isTypedDictClass(argType)) {
                        // Handle the special case where it is a TypedDict and we know which
                        // keys are present.
                        const typedDictEntries = getTypedDictMembersForClass(this, argType);
                        const diag = new DiagnosticAddendum();

                        typedDictEntries.forEach((entry, name) => {
                            const paramEntry = paramMap.get(name);
                            if (paramEntry && !paramEntry.isPositionalOnly) {
                                if (paramEntry.argsReceived > 0) {
                                    diag.addMessage(Localizer.Diagnostic.paramAlreadyAssigned().format({ name }));
                                } else {
                                    paramEntry.argsReceived++;

                                    const paramInfoIndex = paramDetails.params.findIndex(
                                        (paramInfo) => paramInfo.param.name === name
                                    );
                                    assert(paramInfoIndex >= 0);
                                    const paramType = paramDetails.params[paramInfoIndex].type;

                                    validateArgTypeParams.push({
                                        paramCategory: ParameterCategory.Simple,
                                        paramType,
                                        requiresTypeVarMatching: requiresSpecialization(paramType),
                                        argument: {
                                            argumentCategory: ArgumentCategory.Simple,
                                            typeResult: { type: entry.valueType },
                                        },
                                        errorNode: argList[argIndex].valueExpression || errorNode,
                                        paramName: name,
                                    });
                                }
                            } else if (paramDetails.kwargsIndex !== undefined) {
                                const paramType = paramDetails.params[paramDetails.kwargsIndex].type;
                                validateArgTypeParams.push({
                                    paramCategory: ParameterCategory.VarArgDictionary,
                                    paramType,
                                    requiresTypeVarMatching: requiresSpecialization(paramType),
                                    argument: {
                                        argumentCategory: ArgumentCategory.Simple,
                                        typeResult: { type: entry.valueType },
                                    },
                                    errorNode: argList[argIndex].valueExpression || errorNode,
                                    paramName: name,
                                });

                                // Remember that this parameter has already received a value.
                                paramMap.set(name, {
                                    argsNeeded: 1,
                                    argsReceived: 1,
                                    isPositionalOnly: false,
                                });
                            } else {
                                // If the function doesn't have a **kwargs parameter, we need to emit an error.
                                // However, it's possible that there was a **kwargs but it was eliminated by
                                // getParameterListDetails because it was associated with an unpacked TypedDict.
                                // In this case, we can skip the error.
                                if (!paramDetails.hasUnpackedTypedDict) {
                                    diag.addMessage(Localizer.Diagnostic.paramNameMissing().format({ name }));
                                }
                            }
                        });

                        if (!diag.isEmpty()) {
                            this.addDiagnostic(
                                AnalyzerNodeInfo.getFileInfo(errorNode).diagnosticRuleSet.reportGeneralTypeIssues,
                                DiagnosticRule.reportGeneralTypeIssues,
                                Localizer.Diagnostic.unpackedTypedDictArgument() + diag.getString(),
                                argList[argIndex].valueExpression || errorNode
                            );
                            reportedArgError = true;
                        }
                    } else if (isParamSpec(argType) && argType.paramSpecAccess === 'kwargs') {
                        unpackedDictionaryArgType = AnyType.create();
                        if (type.details.paramSpec) {
                            validateArgTypeParams.push({
                                paramCategory: ParameterCategory.VarArgDictionary,
                                paramType: type.details.paramSpec,
                                requiresTypeVarMatching: false,
                                argument: argList[argIndex],
                                errorNode: argList[argIndex].valueExpression || errorNode,
                            });
                        }
                    } else {
                        const mappingType = this.getTypingType(errorNode, 'Mapping');
                        const strObjType = this.getBuiltInObject(errorNode, 'str');

                        if (
                            mappingType &&
                            isInstantiableClass(mappingType) &&
                            strObjType &&
                            isClassInstance(strObjType)
                        ) {
                            const mappingTypeVarContext = new TypeVarContext(getTypeVarScopeId(mappingType));
                            let isValidMappingType = false;

                            // If this was a TypeVar (e.g. for pseudo-generic classes),
                            // don't emit this error.
                            if (isTypeVar(argType)) {
                                isValidMappingType = true;
                            } else if (
                                this.assignType(
                                    ClassType.cloneAsInstance(mappingType),
                                    argType,
                                    /* diag */ undefined,
                                    mappingTypeVarContext
                                )
                            ) {
                                const specializedMapping = applySolvedTypeVars(
                                    mappingType,
                                    mappingTypeVarContext
                                ) as ClassType;
                                const typeArgs = specializedMapping.typeArguments;
                                if (typeArgs && typeArgs.length >= 2) {
                                    if (this.assignType(strObjType, typeArgs[0])) {
                                        isValidMappingType = true;
                                    }
                                    unpackedDictionaryArgType = typeArgs[1];
                                } else {
                                    isValidMappingType = true;
                                    unpackedDictionaryArgType = UnknownType.create();
                                }
                            }

                            if (!isValidMappingType) {
                                this.addDiagnostic(
                                    AnalyzerNodeInfo.getFileInfo(errorNode).diagnosticRuleSet.reportGeneralTypeIssues,
                                    DiagnosticRule.reportGeneralTypeIssues,
                                    Localizer.Diagnostic.unpackedDictArgumentNotMapping(),
                                    argList[argIndex].valueExpression || errorNode
                                );
                                reportedArgError = true;
                            }
                        }
                    }

                    if (paramSpecArgList) {
                        paramSpecArgList.push(argList[argIndex]);
                    }
                } else {
                    // Protect against the case where a non-keyword argument appears after
                    // a keyword argument. This will have already been reported as a parse
                    // error, but we need to protect against it here.
                    const paramName = argList[argIndex].name;
                    if (paramName) {
                        const paramNameValue = paramName.value;
                        const paramEntry = paramMap.get(paramNameValue);
                        if (paramEntry && !paramEntry.isPositionalOnly) {
                            if (paramEntry.argsReceived > 0) {
                                this.addDiagnostic(
                                    AnalyzerNodeInfo.getFileInfo(paramName).diagnosticRuleSet.reportGeneralTypeIssues,
                                    DiagnosticRule.reportGeneralTypeIssues,
                                    Localizer.Diagnostic.paramAlreadyAssigned().format({ name: paramNameValue }),
                                    paramName
                                );
                                reportedArgError = true;
                            } else {
                                paramEntry.argsReceived++;

                                const paramInfoIndex = paramDetails.params.findIndex(
                                    (paramInfo) => paramInfo.param.name === paramNameValue
                                );
                                assert(paramInfoIndex >= 0);
                                const paramType = paramDetails.params[paramInfoIndex].type;

                                validateArgTypeParams.push({
                                    paramCategory: ParameterCategory.Simple,
                                    paramType,
                                    requiresTypeVarMatching: requiresSpecialization(paramType),
                                    argument: argList[argIndex],
                                    errorNode: argList[argIndex].valueExpression || errorNode,
                                    paramName: paramNameValue,
                                });
                                trySetActive(argList[argIndex], paramDetails.params[paramInfoIndex].param);
                            }
                        } else if (paramDetails.kwargsIndex !== undefined) {
                            if (paramSpecArgList) {
                                paramSpecArgList.push(argList[argIndex]);
                            } else {
                                const paramType = paramDetails.params[paramDetails.kwargsIndex].type;
                                validateArgTypeParams.push({
                                    paramCategory: ParameterCategory.VarArgDictionary,
                                    paramType,
                                    requiresTypeVarMatching: requiresSpecialization(paramType),
                                    argument: argList[argIndex],
                                    errorNode: argList[argIndex].valueExpression || errorNode,
                                    paramName: paramNameValue,
                                });

                                // Remember that this parameter has already received a value.
                                paramMap.set(paramNameValue, {
                                    argsNeeded: 1,
                                    argsReceived: 1,
                                    isPositionalOnly: false,
                                });
                            }
                            assert(
                                paramDetails.params[paramDetails.kwargsIndex],
                                'paramDetails.kwargsIndex params entry is undefined'
                            );
                            trySetActive(argList[argIndex], paramDetails.params[paramDetails.kwargsIndex].param);
                        } else {
                            this.addDiagnostic(
                                AnalyzerNodeInfo.getFileInfo(paramName).diagnosticRuleSet.reportGeneralTypeIssues,
                                DiagnosticRule.reportGeneralTypeIssues,
                                Localizer.Diagnostic.paramNameMissing().format({ name: paramName.value }),
                                paramName
                            );
                            reportedArgError = true;
                        }
                    } else if (argList[argIndex].argumentCategory === ArgumentCategory.Simple) {
                        const fileInfo = AnalyzerNodeInfo.getFileInfo(errorNode);
                        this.addDiagnostic(
                            fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                            DiagnosticRule.reportGeneralTypeIssues,
                            positionParamLimitIndex === 1
                                ? Localizer.Diagnostic.argPositionalExpectedOne()
                                : Localizer.Diagnostic.argPositionalExpectedCount().format({
                                      expected: positionParamLimitIndex,
                                  }),
                            argList[argIndex].valueExpression || errorNode
                        );
                        reportedArgError = true;
                    } else if (argList[argIndex].argumentCategory === ArgumentCategory.UnpackedList) {
                        // Handle the case where a *args: P.args is passed as an argument to
                        // a function that accepts a ParamSpec.
                        if (type.details.paramSpec) {
                            const argTypeResult = this.getTypeOfArgument(argList[argIndex]);
                            const argType = argTypeResult.type;

                            if (argTypeResult.isIncomplete) {
                                isTypeIncomplete = true;
                            }

                            if (isParamSpec(argType) && argType.paramSpecAccess === 'args') {
                                validateArgTypeParams.push({
                                    paramCategory: ParameterCategory.VarArgList,
                                    paramType: type.details.paramSpec,
                                    requiresTypeVarMatching: false,
                                    argument: argList[argIndex],
                                    errorNode: argList[argIndex].valueExpression || errorNode,
                                });
                            }
                        }
                    }
                }

                argIndex++;
            }

            // If there are keyword-only parameters that haven't been matched but we
            // have an unpacked dictionary arg, assume that it applies to them.
            if (unpackedDictionaryArgType && (!foundUnpackedListArg || paramDetails.argsIndex !== undefined)) {
                // Don't consider any position-only parameters, since they cannot be matched to
                // **kwargs arguments. Consider parameters that are either positional or keyword
                // if there is no *args argument.
                paramDetails.params.forEach((paramInfo, paramIndex) => {
                    const param = paramInfo.param;
                    if (
                        paramIndex >= paramDetails.firstPositionOrKeywordIndex &&
                        param.category === ParameterCategory.Simple &&
                        param.name &&
                        !param.hasDefault &&
                        paramMap.has(param.name) &&
                        paramMap.get(param.name)!.argsReceived === 0
                    ) {
                        const paramType = paramDetails.params[paramIndex].type;
                        validateArgTypeParams.push({
                            paramCategory: ParameterCategory.Simple,
                            paramType,
                            requiresTypeVarMatching: requiresSpecialization(paramType),
                            argument: {
                                argumentCategory: ArgumentCategory.Simple,
                                typeResult: { type: unpackedDictionaryArgType! },
                            },
                            errorNode:
                                argList.find((arg) => arg.argumentCategory === ArgumentCategory.UnpackedDictionary)
                                    ?.valueExpression ?? errorNode,
                            paramName: param.name,
                            isParamNameSynthesized: param.isNameSynthesized,
                        });

                        paramMap.get(param.name)!.argsReceived = 1;
                    }
                });
            }

            // Determine whether there are any parameters that require arguments
            // but have not yet received them. If we received a dictionary argument
            // (i.e. an arg starting with a "**"), we will assume that all parameters
            // are matched.
            if (!unpackedDictionaryArgType && !FunctionType.isDefaultParameterCheckDisabled(type)) {
                const unassignedParams = [...paramMap.keys()].filter((name) => {
                    const entry = paramMap.get(name)!;
                    return !entry || entry.argsReceived < entry.argsNeeded;
                });

                if (unassignedParams.length > 0) {
                    const missingParamNames = unassignedParams.map((p) => `"${p}"`).join(', ');
                    this.addDiagnostic(
                        AnalyzerNodeInfo.getFileInfo(errorNode).diagnosticRuleSet.reportGeneralTypeIssues,
                        DiagnosticRule.reportGeneralTypeIssues,
                        unassignedParams.length === 1
                            ? Localizer.Diagnostic.argMissingForParam().format({ name: missingParamNames })
                            : Localizer.Diagnostic.argMissingForParams().format({ names: missingParamNames }),
                        errorNode
                    );
                    reportedArgError = true;
                }

                // Add any implicit (default) arguments that are needed for resolving
                // generic types. For example, if the function is defined as
                // def foo(v1: _T = 'default')
                // and _T is a TypeVar, we need to match the TypeVar to the default
                // value's type if it's not provided by the caller.
                paramDetails.params.forEach((paramInfo) => {
                    const param = paramInfo.param;
                    if (param.category === ParameterCategory.Simple && param.name) {
                        const entry = paramMap.get(param.name)!;
                        if (entry.argsNeeded === 0 && entry.argsReceived === 0) {
                            const defaultArgType = paramInfo.defaultArgType ?? param.defaultType;

                            if (
                                defaultArgType &&
                                !isEllipsisType(defaultArgType) &&
                                requiresSpecialization(param.type)
                            ) {
                                validateArgTypeParams.push({
                                    paramCategory: param.category,
                                    paramType: paramInfo.type,
                                    requiresTypeVarMatching: true,
                                    argument: {
                                        argumentCategory: ArgumentCategory.Simple,
                                        typeResult: { type: defaultArgType },
                                    },
                                    errorNode: errorNode,
                                    paramName: param.name,
                                    isParamNameSynthesized: param.isNameSynthesized,
                                });
                            }
                        }
                    }
                });
            }
        }

        // If we're in speculative mode and an arg/param mismatch has already been reported, don't
        // bother doing the extra work here. This occurs frequently when attempting to find the
        // correct overload.
        if (!reportedArgError || !this._speculativeTypeTracker.isSpeculative(undefined)) {
            // If there are arguments that map to a variadic *args parameter that hasn't
            // already been matched, see if the type of that *args parameter is a variadic
            // type variable. If so, we'll preprocess those arguments and combine them
            // into a tuple.
            if (
                paramDetails.argsIndex !== undefined &&
                paramDetails.argsIndex >= 0 &&
                paramDetails.params[paramDetails.argsIndex].param.hasDeclaredType &&
                !isVariadicTypeVarFullyMatched
            ) {
                const paramType = paramDetails.params[paramDetails.argsIndex].type;
                const variadicArgs = validateArgTypeParams.filter((argParam) => argParam.mapsToVarArgList);

                if (isVariadicTypeVar(paramType) && !paramType.isVariadicInUnion) {
                    if (this._tupleClassType && isInstantiableClass(this._tupleClassType)) {
                        const tupleTypeArgs: TupleTypeArgument[] = variadicArgs.map((argParam) => {
                            const argType = this.getTypeOfArgument(argParam.argument).type;
                            const containsVariadicTypeVar =
                                isUnpackedVariadicTypeVar(argType) ||
                                (isClassInstance(argType) &&
                                    isTupleClass(argType) &&
                                    argType.tupleTypeArguments &&
                                    argType.tupleTypeArguments.length === 1 &&
                                    isUnpackedVariadicTypeVar(argType.tupleTypeArguments[0].type));

                            if (
                                containsVariadicTypeVar &&
                                argParam.argument.argumentCategory !== ArgumentCategory.UnpackedList &&
                                !argParam.mapsToVarArgList
                            ) {
                                this.addDiagnostic(
                                    AnalyzerNodeInfo.getFileInfo(errorNode).diagnosticRuleSet.reportGeneralTypeIssues,
                                    DiagnosticRule.reportGeneralTypeIssues,
                                    Localizer.Diagnostic.typeVarTupleMustBeUnpacked(),
                                    argParam.argument.valueExpression ?? errorNode
                                );
                                reportedArgError = true;
                            }

                            return {
                                type: this.stripLiteralValue(argType),
                                isUnbounded: argParam.argument.argumentCategory === ArgumentCategory.UnpackedList,
                            };
                        });

                        let specializedTuple: Type;
                        if (
                            tupleTypeArgs.length === 1 &&
                            !tupleTypeArgs[0].isUnbounded &&
                            (isUnpackedClass(tupleTypeArgs[0].type) || isVariadicTypeVar(tupleTypeArgs[0].type))
                        ) {
                            // If there is a single unpacked tuple or unpacked variadic type variable
                            // (including an unpacked TypeVarTuple union) within this tuple,
                            // simplify the type.
                            specializedTuple = tupleTypeArgs[0].type;
                        } else {
                            specializedTuple = ClassType.cloneAsInstance(
                                specializeTupleClass(
                                    this._tupleClassType,
                                    tupleTypeArgs,
                                    /* isTypeArgumentExplicit */ true,
                                    /* isUnpackedTuple */ true
                                )
                            );
                        }

                        const combinedArg: ValidateArgTypeParams = {
                            paramCategory: ParameterCategory.VarArgList,
                            paramType,
                            requiresTypeVarMatching: true,
                            argument: {
                                argumentCategory: ArgumentCategory.Simple,
                                typeResult: { type: specializedTuple },
                            },
                            errorNode,
                            paramName: paramDetails.params[paramDetails.argsIndex].param.name,
                            isParamNameSynthesized: paramDetails.params[paramDetails.argsIndex].param.isNameSynthesized,
                            mapsToVarArgList: true,
                        };

                        validateArgTypeParams = [
                            ...validateArgTypeParams.filter((argParam) => !argParam.mapsToVarArgList),
                            combinedArg,
                        ];
                    }
                }
            }
        }

        let relevance = 0;
        if (matchedUnpackedListOfUnknownLength) {
            // Lower the relevance if we made assumptions about the length
            // of an unpacked argument. This will favor overloads that
            // associate this case with a *args parameter.
            relevance--;
        }

        // Special-case the builtin isinstance and issubclass functions.
        if (
            ['isinstance', 'issubclass'].some((name) => name === type.details.builtInName) &&
            validateArgTypeParams.length === 2
        ) {
            validateArgTypeParams[1].expectingType = true;
        }

        return {
            overload: type,
            overloadIndex,
            argumentErrors: reportedArgError,
            isTypeIncomplete,
            argParams: validateArgTypeParams,
            paramSpecTarget,
            paramSpecArgList,
            activeParam,
            relevance,
        };
    }

    // After having matched arguments with parameters, this function evaluates the
    // types of each argument expression and validates that the resulting type is
    // compatible with the declared type of the corresponding parameter.
    validateFunctionArgumentTypesWithExpectedType(
        errorNode: ExpressionNode,
        matchResults: MatchArgsToParamsResult,
        typeVarContext: TypeVarContext,
        skipUnknownArgCheck = false,
        expectedType: Type | undefined
    ): CallResult {
        const type = matchResults.overload;

        if (
            !expectedType ||
            isAnyOrUnknown(expectedType) ||
            isNever(expectedType) ||
            requiresSpecialization(expectedType) ||
            !type.details.declaredReturnType ||
            !requiresSpecialization(FunctionType.getSpecializedReturnType(type) ?? UnknownType.create())
        ) {
            return this.validateFunctionArgumentTypes(errorNode, matchResults, typeVarContext, skipUnknownArgCheck);
        }

        const effectiveReturnType = this.getFunctionEffectiveReturnType(type);
        let effectiveExpectedType: Type | undefined = expectedType;
        let effectiveFlags = AssignTypeFlags.AllowTypeVarNarrowing;
        if (containsLiteralType(effectiveExpectedType, /* includeTypeArgs */ true)) {
            effectiveFlags |= AssignTypeFlags.RetainLiteralsForTypeVar;
        }

        // If the expected type is a union, we don't know which type is expected.
        // We may or may not be able to make use of the expected type. We'll evaluate
        // speculatively to see if using the expected type works.
        if (isUnion(expectedType)) {
            let speculativeResults: CallResult | undefined;

            this.useSpeculativeMode(errorNode, () => {
                const typeVarContextCopy = typeVarContext.clone();
                this.assignType(
                    effectiveReturnType,
                    effectiveExpectedType!,
                    /* diag */ undefined,
                    typeVarContextCopy,
                    /* srcTypeVarContext */ undefined,
                    effectiveFlags | AssignTypeFlags.PopulatingExpectedType
                );
                speculativeResults = this.validateFunctionArgumentTypes(
                    errorNode,
                    matchResults,
                    typeVarContextCopy,
                    skipUnknownArgCheck
                );
            });

            if (speculativeResults && speculativeResults.argumentErrors) {
                effectiveExpectedType = undefined;
            }
        }

        if (effectiveExpectedType) {
            // Prepopulate the typeVarContext based on the specialized expected type if the
            // callee has a declared return type. This will allow us to more closely match
            // the expected type if possible. We set the AllowTypeVarNarrowing and
            // SkipStripLiteralForTypeVar flags so the type can be further narrowed
            // and so literals are not stripped.

            // If the return type is not the same as the expected type but is
            // assignable to the expected type, determine which type arguments
            // are needed to match the expected type.
            if (
                isClassInstance(effectiveReturnType) &&
                isClassInstance(effectiveExpectedType) &&
                !ClassType.isSameGenericClass(effectiveReturnType, effectiveExpectedType)
            ) {
                const tempTypeVarContext = new TypeVarContext(getTypeVarScopeId(effectiveReturnType));
                populateTypeVarContextBasedOnExpectedType(
                    this,
                    effectiveReturnType,
                    effectiveExpectedType,
                    tempTypeVarContext,
                    this.getTypeVarScopesForNode(errorNode)
                );

                const genericReturnType = ClassType.cloneForSpecialization(
                    effectiveReturnType,
                    /* typeArguments */ undefined,
                    /* isTypeArgumentExplicit */ false
                );

                effectiveExpectedType = applySolvedTypeVars(genericReturnType, tempTypeVarContext);
            }

            this.assignType(
                effectiveReturnType,
                effectiveExpectedType,
                /* diag */ undefined,
                typeVarContext,
                /* srcTypeVarContext */ undefined,
                effectiveFlags | AssignTypeFlags.PopulatingExpectedType
            );
        }

        return this.validateFunctionArgumentTypes(errorNode, matchResults, typeVarContext, skipUnknownArgCheck);
    }

    validateFunctionArgumentTypes(
        errorNode: ExpressionNode,
        matchResults: MatchArgsToParamsResult,
        typeVarContext: TypeVarContext,
        skipUnknownArgCheck = false
    ): CallResult {
        const type = matchResults.overload;
        let isTypeIncomplete = matchResults.isTypeIncomplete;
        let argumentErrors = false;
        let specializedInitSelfType: Type | undefined;
        const typeCondition = getTypeCondition(type);

        if (type.boundTypeVarScopeId) {
            // If the function was bound to a class or object and was a constructor, a
            // static method or a class method, it's possible that some of that class's
            // type variables have not yet been solved. Add that class's TypeVar scope ID.
            if (type.preBoundFlags !== undefined && type.boundToType && requiresSpecialization(type.boundToType)) {
                if (
                    type.preBoundFlags &
                    (FunctionTypeFlags.StaticMethod | FunctionTypeFlags.ClassMethod | FunctionTypeFlags.StaticMethod)
                ) {
                    typeVarContext.addSolveForScope(type.boundTypeVarScopeId);
                }
            }

            // Some typeshed stubs use specialized type annotations in the "self" parameter
            // of an overloaded __init__ method to specify which specialized type should
            // be constructed. Although this isn't part of the official Python spec, other
            // type checkers appear to honor it.
            if (
                type.details.name === '__init__' &&
                FunctionType.isOverloaded(type) &&
                type.strippedFirstParamType &&
                type.boundToType &&
                isClassInstance(type.strippedFirstParamType) &&
                isClassInstance(type.boundToType) &&
                ClassType.isSameGenericClass(type.strippedFirstParamType, type.boundToType) &&
                type.strippedFirstParamType.typeArguments
            ) {
                const typeParams = type.strippedFirstParamType.details.typeParameters;
                specializedInitSelfType = type.strippedFirstParamType;
                type.strippedFirstParamType.typeArguments.forEach((typeArg, index) => {
                    if (index < typeParams.length) {
                        const typeParam = typeParams[index];
                        if (!isTypeSame(typeParam, typeArg, { ignorePseudoGeneric: true })) {
                            typeVarContext.setTypeVarType(typeParams[index], typeArg);
                        }
                    }
                });
            }
        }

        // Special-case a few built-in calls that are often used for
        // casting or checking for unknown types.
        if (['cast', 'isinstance', 'issubclass'].some((name) => name === type.details.builtInName)) {
            skipUnknownArgCheck = true;
        }

        // Run through all args and validate them against their matched parameter.
        // We'll do two passes. The first one will match any type arguments. The second
        // will perform the actual validation. We can skip the first pass if there
        // are no type vars to match.
        const typeVarMatchingCount = matchResults.argParams.filter((arg) => arg.requiresTypeVarMatching).length;
        if (typeVarMatchingCount > 0) {
            // In theory, we may need to do up to n passes where n is the number of
            // arguments that need type var matching. That's because later matches
            // can provide bidirectional type hints for earlier matches. The best
            // example of this is the built-in "map" method whose first parameter is
            // a lambda and second parameter indicates what type the lambda should accept.
            // In practice, we will limit the number of passes to 2 because it can get
            // very expensive to go beyond this, and we don't see generally see cases
            // where more than two passes are needed.
            let passCount = Math.min(typeVarMatchingCount, 2);
            for (let i = 0; i < passCount; i++) {
                this.useSpeculativeMode(errorNode, () => {
                    matchResults.argParams.forEach((argParam) => {
                        if (argParam.requiresTypeVarMatching) {
                            // Populate the typeVarContext for the argument. If the argument
                            // is an overload function, skip it during the first pass
                            // because the selection of the proper overload may depend
                            // on type arguments supplied by other function arguments.
                            // Set useNarrowBoundOnly to true the first time through
                            // the loop if we're going to go through the loop multiple
                            // times.
                            const argResult = this.validateArgType(
                                argParam,
                                typeVarContext,
                                type,
                                skipUnknownArgCheck,
                                /* skipOverloadArg */ i === 0,
                                /* useNarrowBoundOnly */ passCount > 1 && i === 0,
                                typeCondition
                            );

                            if (argResult.isTypeIncomplete) {
                                isTypeIncomplete = true;
                            }

                            // If we skipped a overload arg during the first pass,
                            // add another pass to ensure that we handle all of the
                            // type variables.
                            if (i === 0 && argResult.skippedOverloadArg) {
                                passCount++;
                            }
                        }
                    });
                });
            }

            // Lock the type var map so it cannot be modified and revalidate the
            // arguments in a second pass.
            typeVarContext.lock();
        }

        let sawParamSpecArgs = false;
        let sawParamSpecKwargs = false;

        let condition: TypeCondition[] = [];
        matchResults.argParams.forEach((argParam) => {
            const argResult = this.validateArgType(
                argParam,
                typeVarContext,
                type,
                skipUnknownArgCheck,
                /* skipOverloadArg */ false,
                /* useNarrowBoundOnly */ false,
                typeCondition
            );

            if (!argResult.isCompatible) {
                argumentErrors = true;
            }

            if (argResult.isTypeIncomplete) {
                isTypeIncomplete = true;
            }

            if (argResult.condition) {
                condition = TypeCondition.combine(condition, argResult.condition) ?? [];
            }

            if (type.details.paramSpec) {
                if (argParam.argument.argumentCategory === ArgumentCategory.UnpackedList) {
                    if (isParamSpec(argResult.argType) && argResult.argType.paramSpecAccess === 'args') {
                        sawParamSpecArgs = true;
                    }
                }

                if (argParam.argument.argumentCategory === ArgumentCategory.UnpackedDictionary) {
                    if (isParamSpec(argResult.argType) && argResult.argType.paramSpecAccess === 'kwargs') {
                        sawParamSpecKwargs = true;
                    }
                }
            }
        });

        // Handle the assignment of additional arguments that map to a param spec.
        if (matchResults.paramSpecArgList && matchResults.paramSpecTarget) {
            if (
                !this.validateFunctionArgumentsForParamSpec(
                    errorNode,
                    matchResults.paramSpecArgList,
                    matchResults.paramSpecTarget,
                    typeVarContext,
                    typeCondition
                )
            ) {
                argumentErrors = true;
            }
        } else if (type.details.paramSpec) {
            if (!sawParamSpecArgs || !sawParamSpecKwargs) {
                if (!isTypeIncomplete) {
                    this.addDiagnostic(
                        AnalyzerNodeInfo.getFileInfo(errorNode).diagnosticRuleSet.reportGeneralTypeIssues,
                        DiagnosticRule.reportGeneralTypeIssues,
                        Localizer.Diagnostic.paramSpecArgsMissing().format({
                            type: this.printType(type.details.paramSpec),
                        }),
                        errorNode
                    );
                }
                argumentErrors = true;
            }
        }

        // Calculate the return type.
        let returnType = this.getFunctionEffectiveReturnType(type, matchResults.argParams);

        if (condition.length > 0) {
            returnType = TypeBase.cloneForCondition(returnType, condition);
        }

        // Determine whether the expression being evaluated is within the current TypeVar
        // scope. If not, then the expression is invoking a function in another scope,
        // and we should eliminate unsolved type variables from union types that appear
        // in the return type. If we're within the same scope, we should retain these
        // extra type variables because they are still potentially relevant within this
        // scope.
        let eliminateUnsolvedInUnions = true;
        let curNode: ParseNode | undefined = errorNode;
        while (curNode) {
            const typeVarScopeNode = ParseTreeUtils.getTypeVarScopeNode(curNode);
            if (!typeVarScopeNode) {
                break;
            }

            const typeVarScopeId = this.getScopeIdForNode(typeVarScopeNode);
            if (typeVarContext.hasSolveForScope(typeVarScopeId)) {
                eliminateUnsolvedInUnions = false;
            }

            curNode = typeVarScopeNode.parent;
        }

        // If the function is returning a callable, don't eliminate unsolved
        // type vars within a union. There are legit uses for unsolved type vars
        // within a callable.
        if (
            isFunction(returnType) ||
            isOverloadedFunction(returnType) ||
            type.details.typeVarScopeId === WildcardTypeVarScopeId
        ) {
            eliminateUnsolvedInUnions = false;
        }

        // In general, we want to replace in-scope TypeVars with Unknown
        // if they were not solved. However, if the return type is a
        // Callable, we'll leave the TypeVars unsolved because
        // the call below to adjustCallableReturnType will "detach" these
        // TypeVars from the scope of this function and "attach" them to
        // the scope of the callable.
        let unknownIfUnsolved = !isFunction(returnType);

        // We'll also leave TypeVars unsolved if the call is a recursive
        // call to a generic function.
        const typeVarScopes = this.getTypeVarScopesForNode(errorNode);
        if (typeVarScopes.some((typeVarScope) => typeVarContext.hasSolveForScope(typeVarScope))) {
            unknownIfUnsolved = false;
        }

        let specializedReturnType = addConditionToType(
            applySolvedTypeVars(
                returnType,
                typeVarContext,
                unknownIfUnsolved,
                /* useNarrowBoundOnly */ false,
                eliminateUnsolvedInUnions
            ),
            typeCondition
        );

        // If the final return type is an unpacked tuple, turn it into a normal (unpacked) tuple.
        if (isUnpackedClass(specializedReturnType)) {
            specializedReturnType = ClassType.cloneForUnpacked(specializedReturnType, /* isUnpackedTuple */ false);
        }

        // Handle 'TypeGuard' and 'StrictTypeGuard' specially. We'll transform the
        // return type into a 'bool' object with a type argument that reflects the
        // narrowed type.
        if (
            isClassInstance(specializedReturnType) &&
            ClassType.isBuiltIn(specializedReturnType, ['TypeGuard', 'StrictTypeGuard']) &&
            specializedReturnType.typeArguments &&
            specializedReturnType.typeArguments.length > 0
        ) {
            if (this._boolClassType && isInstantiableClass(this._boolClassType)) {
                specializedReturnType = ClassType.cloneAsInstance(
                    ClassType.cloneForTypeGuard(
                        this._boolClassType,
                        specializedReturnType.typeArguments[0],
                        ClassType.isBuiltIn(specializedReturnType, 'StrictTypeGuard')
                    )
                );
            }
        }

        specializedReturnType = this.adjustCallableReturnType(specializedReturnType);

        if (specializedInitSelfType) {
            specializedInitSelfType = applySolvedTypeVars(specializedInitSelfType, typeVarContext);
        }

        return {
            argumentErrors,
            returnType: specializedReturnType,
            isTypeIncomplete,
            activeParam: matchResults.activeParam,
            specializedInitSelfType,
        };
    }

    adjustCallableReturnType(type: Type): Type {
        // If the return type includes a generic Callable type, set the type var
        // scope to a wildcard to allow these type vars to be solved. This won't
        // work with overloads or unions of callables. It's intended for a
        // specific use case. We may need to make this more sophisticated in
        // the future.
        if (isFunction(type) && !type.details.name) {
            type.details = {
                ...type.details,
                typeVarScopeId: WildcardTypeVarScopeId,
            };
        }

        return type;
    }

    // Tries to assign the call arguments to the function parameter
    // list and reports any mismatches in types or counts. Returns the
    // specialized return type of the call.
    validateFunctionArguments(
        errorNode: ExpressionNode,
        argList: FunctionArgument[],
        type: FunctionType,
        typeVarContext: TypeVarContext,
        skipUnknownArgCheck = false,
        expectedType?: Type
    ): CallResult {
        const matchResults = this.matchFunctionArgumentsToParameters(errorNode, argList, type, 0);

        if (matchResults.argumentErrors) {
            // Evaluate types of all args. This will ensure that referenced symbols are
            // not reported as unaccessed.
            argList.forEach((arg) => {
                if (arg.valueExpression && !this._speculativeTypeTracker.isSpeculative(arg.valueExpression)) {
                    this.getTypeOfExpression(arg.valueExpression);
                }
            });

            return {
                argumentErrors: true,
                activeParam: matchResults.activeParam,
            };
        }

        return this.validateFunctionArgumentTypesWithExpectedType(
            errorNode,
            matchResults,
            typeVarContext,
            skipUnknownArgCheck,
            expectedType
        );
    }

    // Determines whether the specified argument list satisfies the function
    // signature bound to the specified ParamSpec. Return value indicates success.
    validateFunctionArgumentsForParamSpec(
        errorNode: ExpressionNode,
        argList: FunctionArgument[],
        paramSpec: TypeVarType,
        typeVarContext: TypeVarContext,
        conditionFilter: TypeCondition[] | undefined
    ): boolean {
        const paramSpecValue = typeVarContext.getParamSpec(paramSpec);

        if (!paramSpecValue) {
            this.addDiagnostic(
                AnalyzerNodeInfo.getFileInfo(errorNode).diagnosticRuleSet.reportGeneralTypeIssues,
                DiagnosticRule.reportGeneralTypeIssues,
                Localizer.Diagnostic.paramSpecNotBound().format({ type: this.printType(paramSpec) }),
                argList[0]?.valueExpression || errorNode
            );
            return false;
        }

        // If the ParamSpec was bound to a generic function, some TypeVars may
        // not yet be solved. Add the TypeVar scope for the bound function.
        typeVarContext.addSolveForScope(paramSpecValue.typeVarScopeId);

        let reportedArgError = false;

        // Build a map of all named parameters.
        const paramMap = new Map<string, ParamSpecEntry>();
        const paramSpecParams = paramSpecValue.parameters;
        paramSpecParams.forEach((param) => {
            if (param.name) {
                paramMap.set(param.name, param);
            }
        });

        let positionalIndex = 0;
        let positionalIndexLimit = paramSpecParams.findIndex(
            (paramInfo) => paramInfo.category !== ParameterCategory.Simple
        );
        if (positionalIndexLimit < 0) {
            positionalIndexLimit = paramSpecParams.length;
        }
        const argsParam = paramSpecParams.find((paramInfo) => paramInfo.category === ParameterCategory.VarArgList);
        const kwargsParam = paramSpecParams.find(
            (paramInfo) => paramInfo.category === ParameterCategory.VarArgDictionary
        );

        argList.forEach((arg) => {
            if (arg.argumentCategory === ArgumentCategory.Simple) {
                let paramType: Type | undefined;

                if (arg.name) {
                    const paramInfo = paramMap.get(arg.name.value);
                    if (paramInfo) {
                        paramType = paramInfo.type;
                        paramMap.delete(arg.name.value);
                    } else if (kwargsParam) {
                        paramType = kwargsParam.type;
                    } else {
                        this.addDiagnostic(
                            AnalyzerNodeInfo.getFileInfo(errorNode).diagnosticRuleSet.reportGeneralTypeIssues,
                            DiagnosticRule.reportGeneralTypeIssues,
                            Localizer.Diagnostic.paramNameMissing().format({ name: arg.name.value }),
                            arg.name || errorNode
                        );
                        reportedArgError = true;
                    }
                } else {
                    if (positionalIndex < positionalIndexLimit) {
                        const paramInfo = paramSpecParams[positionalIndex];
                        paramType = paramInfo.type;
                        if (paramInfo.name) {
                            paramMap.delete(paramInfo.name);
                        }
                    } else if (argsParam) {
                        paramType = argsParam.type;
                    } else {
                        this.addDiagnostic(
                            AnalyzerNodeInfo.getFileInfo(errorNode).diagnosticRuleSet.reportGeneralTypeIssues,
                            DiagnosticRule.reportGeneralTypeIssues,
                            paramSpecParams.length === 1
                                ? Localizer.Diagnostic.argPositionalExpectedOne()
                                : Localizer.Diagnostic.argPositionalExpectedCount().format({
                                      expected: paramSpecParams.length,
                                  }),
                            arg.valueExpression ?? errorNode
                        );
                        reportedArgError = true;
                    }

                    positionalIndex++;
                }

                if (paramType) {
                    if (
                        !this.validateArgType(
                            {
                                paramCategory: ParameterCategory.Simple,
                                paramType,
                                requiresTypeVarMatching: false,
                                argument: arg,
                                errorNode: arg.valueExpression || errorNode,
                            },
                            typeVarContext,
                            /* functionType */ undefined,
                            /* skipUnknownArgCheck */ false,
                            /* skipOverloadArg */ false,
                            /* useNarrowBoundOnly */ false,
                            conditionFilter
                        )
                    ) {
                        reportedArgError = true;
                    }
                }
            } else {
                // TODO - handle *args and **kwargs
                paramMap.clear();
            }
        });

        // Report any missing parameters.
        if (!reportedArgError) {
            let unassignedParams = [...paramMap.keys()];

            // Parameters that have defaults can be left unspecified.
            unassignedParams = unassignedParams.filter((name) => {
                const paramInfo = paramMap.get(name)!;
                return paramInfo.category === ParameterCategory.Simple && !paramInfo.hasDefault;
            });

            if (unassignedParams.length > 0 && !paramSpecValue.paramSpec) {
                const missingParamNames = unassignedParams.map((p) => `"${p}"`).join(', ');
                this.addDiagnostic(
                    AnalyzerNodeInfo.getFileInfo(errorNode).diagnosticRuleSet.reportGeneralTypeIssues,
                    DiagnosticRule.reportGeneralTypeIssues,
                    unassignedParams.length === 1
                        ? Localizer.Diagnostic.argMissingForParam().format({ name: missingParamNames })
                        : Localizer.Diagnostic.argMissingForParams().format({ names: missingParamNames }),
                    errorNode
                );
                reportedArgError = true;
            }
        }

        return !reportedArgError;
    }

    validateArgType(
        argParam: ValidateArgTypeParams,
        typeVarContext: TypeVarContext,
        functionType: FunctionType | undefined,
        skipUnknownCheck: boolean,
        skipOverloadArg: boolean,
        useNarrowBoundOnly: boolean,
        conditionFilter: TypeCondition[] | undefined
    ): ArgResult {
        let argType: Type | undefined;
        let expectedTypeDiag: DiagnosticAddendum | undefined;
        let isTypeIncomplete = false;
        let isCompatible = true;
        const functionName = functionType?.details.name;

        if (argParam.argument.valueExpression) {
            // If the param type is a "bare" TypeVar, don't use it as an expected
            // type. This causes problems for cases where the the call expression
            // result can influence the type of the TypeVar, such as in
            // the expression "min(1, max(2, 0.5))". We set useNarrowBoundOnly
            // to true if this is the first pass through the parameter list because
            // a wide bound on a TypeVar (if a narrow bound has not yet been established)
            // will unnecessarily constrain the expected type.
            let expectedType: Type | undefined =
                isTypeVar(argParam.paramType) &&
                functionType !== undefined &&
                argParam.paramType.scopeId === functionType.details.typeVarScopeId
                    ? undefined
                    : applySolvedTypeVars(
                          argParam.paramType,
                          typeVarContext,
                          /* unknownIfNotFound */ false,
                          useNarrowBoundOnly
                      );

            // If the expected type is unknown, don't use an expected type. Instead,
            // use default rules for evaluating the expression type.
            if (expectedType && isUnknown(expectedType)) {
                expectedType = undefined;
            }

            // Was the argument's type precomputed by the caller?
            if (argParam.argType) {
                argType = argParam.argType;
            } else {
                const flags = argParam.expectingType
                    ? EvaluatorFlags.EvaluateStringLiteralAsType |
                      EvaluatorFlags.ParamSpecDisallowed |
                      EvaluatorFlags.TypeVarTupleDisallowed
                    : EvaluatorFlags.None;
                const exprTypeResult = this.getTypeOfExpression(argParam.argument.valueExpression, flags, expectedType);
                argType = exprTypeResult.type;
                if (exprTypeResult.isIncomplete) {
                    isTypeIncomplete = true;
                }
                if (exprTypeResult.typeErrors) {
                    isCompatible = false;
                }
                expectedTypeDiag = exprTypeResult.expectedTypeDiagAddendum;
            }

            if (
                argParam.argument &&
                argParam.argument.name &&
                !this._speculativeTypeTracker.isSpeculative(argParam.errorNode)
            ) {
                this.writeTypeCache(
                    argParam.argument.name,
                    expectedType || argType,
                    EvaluatorFlags.None,
                    isTypeIncomplete
                );
            }
        } else {
            // Was the argument's type precomputed by the caller?
            if (argParam.argType) {
                argType = argParam.argType;
            } else if (argParam.expectingType && !argParam.argument.typeResult && argParam.argument.valueExpression) {
                const argTypeResult = this.getTypeOfExpression(
                    argParam.argument.valueExpression,
                    EvaluatorFlags.EvaluateStringLiteralAsType |
                        EvaluatorFlags.ParamSpecDisallowed |
                        EvaluatorFlags.TypeVarTupleDisallowed
                );
                argType = argTypeResult.type;
                if (argTypeResult.isIncomplete) {
                    isTypeIncomplete = true;
                }
            } else {
                const argTypeResult = this.getTypeOfArgument(argParam.argument);
                argType = argTypeResult.type;
                if (argTypeResult.isIncomplete) {
                    isTypeIncomplete = true;
                }
            }
        }

        // If we're assigning to a var arg dictionary with a TypeVar type,
        // strip literals before performing the assignment. This is used in
        // places like a dict constructor.
        if (argParam.paramCategory === ParameterCategory.VarArgDictionary && isTypeVar(argParam.paramType)) {
            argType = this.stripLiteralValue(argType);
        }

        // If there's a constraint filter, apply it to top-level type variables
        // if appropriate. This doesn't properly handle non-top-level constrained
        // type variables.
        if (conditionFilter) {
            argType = this.mapSubtypesExpandTypeVars(argType, conditionFilter, (expandedSubtype) => {
                return expandedSubtype;
            });
        }

        const condition = argType.condition;

        let diag = new DiagnosticAddendum();

        // Handle the case where we're assigning a *args or **kwargs argument
        // to a *P.args or **P.kwargs parameter.
        if (isParamSpec(argParam.paramType) && argParam.paramType.paramSpecAccess !== undefined) {
            return { isCompatible, argType, isTypeIncomplete, condition };
        }

        // Handle the case where we're assigning a *P.args or **P.kwargs argument
        // to a *P.args or **P.kwargs parameter.
        if (isParamSpec(argType) && argType.paramSpecAccess !== undefined) {
            return { isCompatible, argType, isTypeIncomplete, condition };
        }

        // If we are asked to skip overload arguments, determine whether the argument
        // is an explicit overload type, an overloaded class constructor, or a
        // an overloaded callback protocol.
        if (skipOverloadArg) {
            if (isOverloadedFunction(argType)) {
                return { isCompatible, argType, isTypeIncomplete, skippedOverloadArg: true, condition };
            }

            const concreteParamType = this.makeTopLevelTypeVarsConcrete(argParam.paramType);
            if (isFunction(concreteParamType) || isOverloadedFunction(concreteParamType)) {
                if (isInstantiableClass(argType)) {
                    const constructor = this.createFunctionFromConstructor(argType);
                    if (constructor && isOverloadedFunction(constructor)) {
                        return { isCompatible, argType, isTypeIncomplete, skippedOverloadArg: true, condition };
                    }
                }

                if (isClassInstance(argType)) {
                    const callMember = lookUpObjectMember(argType, '__call__');
                    if (callMember) {
                        const memberType = this.getTypeOfMember(callMember);
                        if (isOverloadedFunction(memberType)) {
                            return { isCompatible, argType, isTypeIncomplete, skippedOverloadArg: true, condition };
                        }
                    }
                }
            }
        }

        if (!this.assignType(argParam.paramType, argType, diag.createAddendum(), typeVarContext)) {
            // Mismatching parameter types are common in untyped code; don't bother spending time
            // printing types if the diagnostic is disabled.
            const fileInfo = AnalyzerNodeInfo.getFileInfo(argParam.errorNode);
            if (
                fileInfo.diagnosticRuleSet.reportGeneralTypeIssues !== 'none' &&
                !this.isDiagnosticSuppressedForNode(argParam.errorNode) &&
                !isTypeIncomplete
            ) {
                const fileInfo = AnalyzerNodeInfo.getFileInfo(argParam.errorNode);
                const argTypeText = this.printType(argType);
                const paramTypeText = this.printType(argParam.paramType);

                let message: string;
                if (argParam.paramName && !argParam.isParamNameSynthesized) {
                    if (functionName) {
                        message = Localizer.Diagnostic.argAssignmentParamFunction().format({
                            argType: argTypeText,
                            paramType: paramTypeText,
                            functionName,
                            paramName: argParam.paramName,
                        });
                    } else {
                        message = Localizer.Diagnostic.argAssignmentParam().format({
                            argType: argTypeText,
                            paramType: paramTypeText,
                            paramName: argParam.paramName,
                        });
                    }
                } else {
                    if (functionName) {
                        message = Localizer.Diagnostic.argAssignmentFunction().format({
                            argType: argTypeText,
                            paramType: paramTypeText,
                            functionName,
                        });
                    } else {
                        message = Localizer.Diagnostic.argAssignment().format({
                            argType: argTypeText,
                            paramType: paramTypeText,
                        });
                    }
                }

                // If we have an expected type diagnostic addendum, use that
                // instead of the local diagnostic addendum because it will
                // be more informative.
                if (expectedTypeDiag) {
                    diag = expectedTypeDiag;
                }

                this.addDiagnostic(
                    fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                    DiagnosticRule.reportGeneralTypeIssues,
                    message + diag.getString(),
                    argParam.errorNode,
                    diag.getEffectiveTextRange() ?? argParam.errorNode
                );
            }

            return { isCompatible: false, argType, isTypeIncomplete, condition };
        }

        if (!skipUnknownCheck) {
            const simplifiedType = removeUnbound(argType);
            const fileInfo = AnalyzerNodeInfo.getFileInfo(argParam.errorNode);

            const getDiagAddendum = () => {
                const diagAddendum = new DiagnosticAddendum();
                if (argParam.paramName) {
                    diagAddendum.addMessage(
                        (functionName
                            ? Localizer.DiagnosticAddendum.argParamFunction().format({
                                  paramName: argParam.paramName,
                                  functionName,
                              })
                            : Localizer.DiagnosticAddendum.argParam().format({ paramName: argParam.paramName })) +
                            diagAddendum.getString()
                    );
                }
                return diagAddendum;
            };

            // Do not check for unknown types if the expected type is "Any".
            // Don't print types if reportUnknownArgumentType is disabled for performance.
            if (
                fileInfo.diagnosticRuleSet.reportUnknownArgumentType !== 'none' &&
                !isAny(argParam.paramType) &&
                !isTypeIncomplete
            ) {
                if (isUnknown(simplifiedType)) {
                    const diagAddendum = getDiagAddendum();
                    this.addDiagnostic(
                        fileInfo.diagnosticRuleSet.reportUnknownArgumentType,
                        DiagnosticRule.reportUnknownArgumentType,
                        Localizer.Diagnostic.argTypeUnknown() + diagAddendum.getString(),
                        argParam.errorNode
                    );
                } else if (isPartlyUnknown(simplifiedType, /* allowUnknownTypeArgsForClasses */ true)) {
                    let suppressPartialUnknown = false;

                    // Don't report an error if the type is a partially-specialized
                    // class. This comes up frequently in cases where a type is passed
                    // as an argument (e.g. "defaultdict(list)").
                    if (isInstantiableClass(simplifiedType)) {
                        suppressPartialUnknown = true;
                    }

                    // If the parameter type is also partially unknown, don't report
                    // the error because it's likely that the partially-unknown type
                    // arose due to bidirectional type matching.
                    if (isPartlyUnknown(argParam.paramType)) {
                        suppressPartialUnknown = true;
                    }

                    // If the argument type comes from a `[]` or `{}` expression,
                    // don't bother reporting it.
                    if (isClassInstance(simplifiedType) && simplifiedType.isEmptyContainer) {
                        suppressPartialUnknown = true;
                    }

                    if (!suppressPartialUnknown) {
                        const diagAddendum = getDiagAddendum();
                        diagAddendum.addMessage(
                            Localizer.DiagnosticAddendum.argumentType().format({
                                type: this.printType(simplifiedType, { expandTypeAlias: true }),
                            })
                        );
                        this.addDiagnostic(
                            fileInfo.diagnosticRuleSet.reportUnknownArgumentType,
                            DiagnosticRule.reportUnknownArgumentType,
                            Localizer.Diagnostic.argTypePartiallyUnknown() + diagAddendum.getString(),
                            argParam.errorNode
                        );
                    }
                }
            }
        }

        return { isCompatible, argType, isTypeIncomplete, condition };
    }

    createTypeVarType(errorNode: ExpressionNode, argList: FunctionArgument[]): Type | undefined {
        let typeVarName = '';
        let firstConstraintArg: FunctionArgument | undefined;
        let defaultValueNode: ExpressionNode | undefined;

        if (argList.length === 0) {
            this.addError(Localizer.Diagnostic.typeVarFirstArg(), errorNode);
            return undefined;
        }

        const firstArg = argList[0];
        if (firstArg.valueExpression && firstArg.valueExpression.nodeType === ParseNodeType.StringList) {
            typeVarName = firstArg.valueExpression.strings.map((s) => s.value).join('');
        } else {
            this.addError(Localizer.Diagnostic.typeVarFirstArg(), firstArg.valueExpression || errorNode);
        }

        const typeVar = TypeVarType.createInstantiable(typeVarName, /* isParamSpec */ false);

        // Parse the remaining parameters.
        const paramNameMap = new Map<string, string>();
        for (let i = 1; i < argList.length; i++) {
            const paramNameNode = argList[i].name;
            const paramName = paramNameNode ? paramNameNode.value : undefined;

            if (paramName) {
                if (paramNameMap.get(paramName)) {
                    this.addError(
                        Localizer.Diagnostic.duplicateParam().format({ name: paramName }),
                        argList[i].valueExpression || errorNode
                    );
                }

                if (paramName === 'bound') {
                    if (typeVar.details.constraints.length > 0) {
                        this.addError(
                            Localizer.Diagnostic.typeVarBoundAndConstrained(),
                            argList[i].valueExpression || errorNode
                        );
                    } else {
                        const argType =
                            argList[i].typeResult?.type ??
                            this.getTypeOfExpressionExpectingType(argList[i].valueExpression!).type;
                        if (requiresSpecialization(argType, /* ignorePseudoGeneric */ true)) {
                            this.addError(
                                Localizer.Diagnostic.typeVarBoundGeneric(),
                                argList[i].valueExpression || errorNode
                            );
                        }
                        typeVar.details.boundType = convertToInstance(argType);
                    }
                } else if (paramName === 'covariant') {
                    if (argList[i].valueExpression && this.getBooleanValue(argList[i].valueExpression!)) {
                        if (
                            typeVar.details.declaredVariance === Variance.Contravariant ||
                            typeVar.details.declaredVariance === Variance.Auto
                        ) {
                            this.addError(Localizer.Diagnostic.typeVarVariance(), argList[i].valueExpression!);
                        } else {
                            typeVar.details.declaredVariance = Variance.Covariant;
                        }
                    }
                } else if (paramName === 'contravariant') {
                    if (argList[i].valueExpression && this.getBooleanValue(argList[i].valueExpression!)) {
                        if (
                            typeVar.details.declaredVariance === Variance.Covariant ||
                            typeVar.details.declaredVariance === Variance.Auto
                        ) {
                            this.addError(Localizer.Diagnostic.typeVarVariance(), argList[i].valueExpression!);
                        } else {
                            typeVar.details.declaredVariance = Variance.Contravariant;
                        }
                    }
                } else if (paramName === 'infer_variance') {
                    if (argList[i].valueExpression && this.getBooleanValue(argList[i].valueExpression!)) {
                        if (
                            typeVar.details.declaredVariance === Variance.Covariant ||
                            typeVar.details.declaredVariance === Variance.Contravariant
                        ) {
                            this.addError(Localizer.Diagnostic.typeVarVariance(), argList[i].valueExpression!);
                        } else {
                            typeVar.details.declaredVariance = Variance.Auto;
                        }
                    }
                } else if (paramName === 'default') {
                    defaultValueNode = argList[i].valueExpression;
                    const argType =
                        argList[i].typeResult?.type ??
                        this.getTypeOfExpressionExpectingType(argList[i].valueExpression!).type;
                    typeVar.details.defaultType = convertToInstance(argType);
                } else {
                    this.addError(
                        Localizer.Diagnostic.typeVarUnknownParam().format({ name: paramName }),
                        argList[i].node?.name || argList[i].valueExpression || errorNode
                    );
                }

                paramNameMap.set(paramName, paramName);
            } else {
                if (typeVar.details.boundType) {
                    this.addError(
                        Localizer.Diagnostic.typeVarBoundAndConstrained(),
                        argList[i].valueExpression || errorNode
                    );
                } else {
                    const argType =
                        argList[i].typeResult?.type ??
                        this.getTypeOfExpressionExpectingType(argList[i].valueExpression!).type;

                    if (requiresSpecialization(argType, /* ignorePseudoGeneric */ true)) {
                        this.addError(
                            Localizer.Diagnostic.typeVarConstraintGeneric(),
                            argList[i].valueExpression || errorNode
                        );
                    }
                    TypeVarType.addConstraint(typeVar, convertToInstance(argType));
                    if (firstConstraintArg === undefined) {
                        firstConstraintArg = argList[i];
                    }
                }
            }
        }

        if (typeVar.details.constraints.length === 1 && firstConstraintArg) {
            this.addDiagnostic(
                AnalyzerNodeInfo.getFileInfo(errorNode).diagnosticRuleSet.reportGeneralTypeIssues,
                DiagnosticRule.reportGeneralTypeIssues,
                Localizer.Diagnostic.typeVarSingleConstraint(),
                firstConstraintArg.valueExpression || errorNode
            );
        }

        // If a default is provided, make sure it is compatible with the bound
        // or constraint.
        if (typeVar.details.defaultType && defaultValueNode) {
            const typeVarContext = new TypeVarContext(WildcardTypeVarScopeId);
            const concreteDefaultType = applySolvedTypeVars(
                typeVar.details.defaultType,
                typeVarContext,
                /* unknownIfNotFound */ true
            );

            if (typeVar.details.boundType) {
                if (!this.assignType(typeVar.details.boundType, concreteDefaultType)) {
                    this.addDiagnostic(
                        AnalyzerNodeInfo.getFileInfo(errorNode).diagnosticRuleSet.reportGeneralTypeIssues,
                        DiagnosticRule.reportGeneralTypeIssues,
                        Localizer.Diagnostic.typeVarDefaultBoundMismatch(),
                        defaultValueNode
                    );
                }
            } else if (typeVar.details.constraints.length > 0) {
                if (!typeVar.details.constraints.some((constraint) => isTypeSame(constraint, concreteDefaultType))) {
                    this.addDiagnostic(
                        AnalyzerNodeInfo.getFileInfo(errorNode).diagnosticRuleSet.reportGeneralTypeIssues,
                        DiagnosticRule.reportGeneralTypeIssues,
                        Localizer.Diagnostic.typeVarDefaultConstraintMismatch(),
                        defaultValueNode
                    );
                }
            }
        }

        return typeVar;
    }

    createTypeVarTupleType(errorNode: ExpressionNode, argList: FunctionArgument[]): Type | undefined {
        let typeVarName = '';

        if (argList.length === 0) {
            this.addError(Localizer.Diagnostic.typeVarFirstArg(), errorNode);
            return undefined;
        }

        const firstArg = argList[0];
        if (firstArg.valueExpression && firstArg.valueExpression.nodeType === ParseNodeType.StringList) {
            typeVarName = firstArg.valueExpression.strings.map((s) => s.value).join('');
        } else {
            this.addError(Localizer.Diagnostic.typeVarFirstArg(), firstArg.valueExpression || errorNode);
        }

        const typeVar = TypeVarType.createInstantiable(typeVarName, /* isParamSpec */ false);
        typeVar.details.isVariadic = true;

        // Parse the remaining parameters.
        for (let i = 1; i < argList.length; i++) {
            const paramNameNode = argList[i].name;
            const paramName = paramNameNode ? paramNameNode.value : undefined;

            if (paramName) {
                if (paramName === 'default') {
                    const expr = argList[i].valueExpression;
                    if (expr) {
                        typeVar.details.defaultType = this.getTypeVarTupleDefaultType(expr);
                    }
                } else {
                    this.addError(
                        Localizer.Diagnostic.typeVarTupleUnknownParam().format({ name: argList[i].name?.value || '?' }),
                        argList[i].node?.name || argList[i].valueExpression || errorNode
                    );
                }
            }
        }

        return typeVar;
    }

    getTypeVarTupleDefaultType(node: ExpressionNode): Type | undefined {
        const argType = this.getTypeOfExpressionExpectingType(node, { allowUnpackedTuple: true }).type;
        const isUnpackedTuple = isClass(argType) && isTupleClass(argType) && argType.isUnpacked;
        const isUnpackedTypeVarTuple = isUnpackedVariadicTypeVar(argType);

        if (!isUnpackedTuple && !isUnpackedTypeVarTuple) {
            this.addDiagnostic(
                AnalyzerNodeInfo.getFileInfo(node).diagnosticRuleSet.reportGeneralTypeIssues,
                DiagnosticRule.reportGeneralTypeIssues,
                Localizer.Diagnostic.typeVarTupleDefaultNotUnpacked(),
                node
            );
            return undefined;
        }

        return convertToInstance(argType);
    }

    createParamSpecType(errorNode: ExpressionNode, argList: FunctionArgument[]): Type | undefined {
        if (argList.length === 0) {
            this.addError(Localizer.Diagnostic.paramSpecFirstArg(), errorNode);
            return undefined;
        }

        const firstArg = argList[0];
        let paramSpecName = '';
        if (firstArg.valueExpression && firstArg.valueExpression.nodeType === ParseNodeType.StringList) {
            paramSpecName = firstArg.valueExpression.strings.map((s) => s.value).join('');
        } else {
            this.addError(Localizer.Diagnostic.paramSpecFirstArg(), firstArg.valueExpression || errorNode);
        }

        const paramSpec = TypeVarType.createInstantiable(paramSpecName, /* isParamSpec */ true);

        // Parse the remaining parameters.
        for (let i = 1; i < argList.length; i++) {
            const paramNameNode = argList[i].name;
            const paramName = paramNameNode ? paramNameNode.value : undefined;

            if (paramName) {
                if (paramName === 'default') {
                    const expr = argList[i].valueExpression;
                    if (expr) {
                        paramSpec.details.defaultType = this.getParamSpecDefaultType(expr);
                    }
                } else {
                    this.addError(
                        Localizer.Diagnostic.paramSpecUnknownParam().format({ name: paramName }),
                        paramNameNode || argList[i].valueExpression || errorNode
                    );
                }
            } else {
                this.addError(Localizer.Diagnostic.paramSpecUnknownArg(), argList[i].valueExpression || errorNode);
                break;
            }
        }

        return paramSpec;
    }

    getParamSpecDefaultType(node: ExpressionNode): Type | undefined {
        const functionType = FunctionType.createSynthesizedInstance(
            '',
            FunctionTypeFlags.SkipArgsKwargsCompatibilityCheck | FunctionTypeFlags.ParamSpecValue
        );
        TypeBase.setSpecialForm(functionType);

        if (node.nodeType === ParseNodeType.Ellipsis) {
            FunctionType.addDefaultParameters(functionType);
            return functionType;
        }

        if (node.nodeType === ParseNodeType.Tuple) {
            node.expressions.forEach((paramExpr, index) => {
                const typeResult = this.getTypeOfExpressionExpectingType(paramExpr);

                FunctionType.addParameter(functionType, {
                    category: ParameterCategory.Simple,
                    name: `__p${index}`,
                    isNameSynthesized: true,
                    hasDeclaredType: true,
                    type: convertToInstance(typeResult.type),
                });
            });

            // Update the type cache so we don't attempt to re-evaluate this node.
            // The type doesn't matter, so use Any.
            this.writeTypeCache(node, AnyType.create(), /* flags */ undefined, /* isIncomplete */ false);
            return functionType;
        } else {
            const typeResult = this.getTypeOfExpressionExpectingType(node, { allowParamSpec: true });
            if (typeResult.typeErrors) {
                return undefined;
            }

            if (isParamSpec(typeResult.type)) {
                functionType.details.paramSpec = typeResult.type;
                return functionType;
            }
        }

        this.addDiagnostic(
            AnalyzerNodeInfo.getFileInfo(node).diagnosticRuleSet.reportGeneralTypeIssues,
            DiagnosticRule.reportGeneralTypeIssues,
            Localizer.Diagnostic.paramSpecDefaultNotTuple(),
            node
        );

        return undefined;
    }

    getBooleanValue(node: ExpressionNode): boolean {
        if (node.nodeType === ParseNodeType.Constant) {
            if (node.constType === KeywordType.False) {
                return false;
            } else if (node.constType === KeywordType.True) {
                return true;
            }
        }

        this.addError(Localizer.Diagnostic.expectedBoolLiteral(), node);
        return false;
    }

    getFunctionFullName(functionNode: ParseNode, moduleName: string, functionName: string): string {
        const nameParts: string[] = [functionName];

        let curNode: ParseNode | undefined = functionNode;

        // Walk the parse tree looking for classes or functions.
        while (curNode) {
            curNode = ParseTreeUtils.getEnclosingClassOrFunction(curNode);
            if (curNode) {
                nameParts.push(curNode.name.value);
            }
        }

        nameParts.push(moduleName);

        return nameParts.reverse().join('.');
    }

    // Implements the semantics of the NewType call as documented
    // in the Python specification: The static type checker will treat
    // the new type as if it were a subclass of the original type.
    createNewType(errorNode: ExpressionNode, argList: FunctionArgument[]): ClassType | undefined {
        const fileInfo = AnalyzerNodeInfo.getFileInfo(errorNode);
        let className = '_';
        if (argList.length >= 1) {
            const nameArg = argList[0];
            if (nameArg.argumentCategory === ArgumentCategory.Simple) {
                if (nameArg.valueExpression && nameArg.valueExpression.nodeType === ParseNodeType.StringList) {
                    className = nameArg.valueExpression.strings.map((s) => s.value).join('');
                }
            }
        }

        if (argList.length >= 2) {
            const baseClass = this.getTypeOfArgumentExpectingType(argList[1]).type;

            if (isInstantiableClass(baseClass)) {
                if (ClassType.isProtocolClass(baseClass)) {
                    this.addError(Localizer.Diagnostic.newTypeProtocolClass(), argList[1].node || errorNode);
                } else if (baseClass.literalValue !== undefined) {
                    this.addError(Localizer.Diagnostic.newTypeLiteral(), argList[1].node || errorNode);
                }

                const classFlags =
                    baseClass.details.flags & ~(ClassTypeFlags.BuiltInClass | ClassTypeFlags.SpecialBuiltIn);
                const classType = ClassType.createInstantiable(
                    className,
                    ParseTreeUtils.getClassFullName(errorNode, fileInfo.moduleName, className),
                    fileInfo.moduleName,
                    fileInfo.filePath,
                    classFlags,
                    ParseTreeUtils.getTypeSourceId(errorNode),
                    /* declaredMetaclass */ undefined,
                    baseClass.details.effectiveMetaclass
                );
                classType.details.baseClasses.push(baseClass);
                computeMroLinearization(classType);

                // Synthesize an __init__ method that accepts only the specified type.
                const initType = FunctionType.createSynthesizedInstance('__init__');
                FunctionType.addParameter(initType, {
                    category: ParameterCategory.Simple,
                    name: 'self',
                    type: ClassType.cloneAsInstance(classType),
                    hasDeclaredType: true,
                });
                FunctionType.addParameter(initType, {
                    category: ParameterCategory.Simple,
                    name: '_x',
                    type: ClassType.cloneAsInstance(baseClass),
                    hasDeclaredType: true,
                });
                initType.details.declaredReturnType = NoneType.createInstance();
                classType.details.fields.set('__init__', Symbol.createWithType(SymbolFlags.ClassMember, initType));

                // Synthesize a trivial __new__ method.
                const newType = FunctionType.createSynthesizedInstance('__new__', FunctionTypeFlags.ConstructorMethod);
                FunctionType.addParameter(newType, {
                    category: ParameterCategory.Simple,
                    name: 'cls',
                    type: classType,
                    hasDeclaredType: true,
                });
                FunctionType.addDefaultParameters(newType);
                newType.details.declaredReturnType = ClassType.cloneAsInstance(classType);
                classType.details.fields.set('__new__', Symbol.createWithType(SymbolFlags.ClassMember, newType));
                return classType;
            } else if (!isAnyOrUnknown(baseClass)) {
                this.addError(Localizer.Diagnostic.newTypeNotAClass(), argList[1].node || errorNode);
            }
        }

        return undefined;
    }

    // Implements the semantics of the multi-parameter variant of the "type" call.
    createType(errorNode: ExpressionNode, argList: FunctionArgument[]): ClassType | undefined {
        const fileInfo = AnalyzerNodeInfo.getFileInfo(errorNode);
        const arg0Type = this.getTypeOfArgument(argList[0]).type;
        if (!isClassInstance(arg0Type) || !ClassType.isBuiltIn(arg0Type, 'str')) {
            return undefined;
        }
        const className = (arg0Type.literalValue as string) || '_';

        const arg1Type = this.getTypeOfArgument(argList[1]).type;
        if (!isClassInstance(arg1Type) || !isTupleClass(arg1Type) || arg1Type.tupleTypeArguments === undefined) {
            return undefined;
        }

        const classType = ClassType.createInstantiable(
            className,
            ParseTreeUtils.getClassFullName(errorNode, fileInfo.moduleName, className),
            fileInfo.moduleName,
            fileInfo.filePath,
            ClassTypeFlags.None,
            ParseTreeUtils.getTypeSourceId(errorNode),
            /* declaredMetaclass */ undefined,
            arg1Type.details.effectiveMetaclass
        );
        arg1Type.tupleTypeArguments.forEach((typeArg) => {
            const specializedType = this.makeTopLevelTypeVarsConcrete(typeArg.type);

            if (
                isInstantiableClass(specializedType) ||
                isAnyOrUnknown(specializedType) ||
                (isClassInstance(specializedType) && ClassType.isBuiltIn(specializedType, 'type'))
            ) {
                classType.details.baseClasses.push(specializedType);
            } else {
                this.addExpectedClassDiagnostic(typeArg.type, argList[1].valueExpression || errorNode);
            }
        });

        if (!computeMroLinearization(classType)) {
            this.addError(Localizer.Diagnostic.methodOrdering(), errorNode);
        }

        return classType;
    }

    getTypeOfConstant(node: ConstantNode, flags: EvaluatorFlags): TypeResult | undefined {
        let type: Type | undefined;

        if (node.constType === KeywordType.None) {
            type = (flags & EvaluatorFlags.ExpectingType) !== 0 ? NoneType.createType() : NoneType.createInstance();
        } else if (
            node.constType === KeywordType.True ||
            node.constType === KeywordType.False ||
            node.constType === KeywordType.Debug
        ) {
            type = this.getBuiltInObject(node, 'bool');

            // For True and False, we can create truthy and falsy
            // versions of 'bool'.
            if (type && isClassInstance(type)) {
                if (node.constType === KeywordType.True) {
                    type = ClassType.cloneWithLiteral(type, /* value */ true);
                } else if (node.constType === KeywordType.False) {
                    type = ClassType.cloneWithLiteral(type, /* value */ false);
                }
            }
        }

        if (!type) {
            return undefined;
        }

        return { type };
    }

    getTypeOfUnaryOperation(node: UnaryOperationNode, expectedType: Type | undefined): TypeResult {
        const exprTypeResult = this.getTypeOfExpression(node.expression);
        let exprType = this.makeTopLevelTypeVarsConcrete(exprTypeResult.type);
        const isIncomplete = exprTypeResult.isIncomplete;

        if (isNever(exprType)) {
            return { type: NeverType.createNever(), isIncomplete };
        }

        // Map unary operators to magic functions. Note that the bitwise
        // invert has two magic functions that are aliases of each other.
        const unaryOperatorMap: { [operator: number]: string } = {
            [OperatorType.Add]: '__pos__',
            [OperatorType.Subtract]: '__neg__',
            [OperatorType.BitwiseInvert]: '__invert__',
        };

        let type: Type | undefined;

        if (node.operator !== OperatorType.Not) {
            if (isOptionalType(exprType)) {
                this.addDiagnostic(
                    AnalyzerNodeInfo.getFileInfo(node).diagnosticRuleSet.reportOptionalOperand,
                    DiagnosticRule.reportOptionalOperand,
                    Localizer.Diagnostic.noneOperator().format({
                        operator: ParseTreeUtils.printOperator(node.operator),
                    }),
                    node.expression
                );
                exprType = removeNoneFromUnion(exprType);
            }
        }

        // Handle certain operations on certain literal types
        // using special-case math. Do not apply this if the input type
        // is incomplete because we may be evaluating an expression within
        // a loop, so the literal value may change each time.
        if (!exprTypeResult.isIncomplete) {
            const literalClassName = getLiteralTypeClassName(exprType);
            if (literalClassName === 'int') {
                if (node.operator === OperatorType.Add) {
                    type = exprType;
                } else if (node.operator === OperatorType.Subtract) {
                    type = mapSubtypes(exprType, (subtype) => {
                        const classSubtype = subtype as ClassType;
                        return ClassType.cloneWithLiteral(
                            classSubtype,
                            -(classSubtype.literalValue as number | bigint)
                        );
                    });
                }
            } else if (literalClassName === 'bool') {
                if (node.operator === OperatorType.Not) {
                    type = mapSubtypes(exprType, (subtype) => {
                        const classSubtype = subtype as ClassType;
                        return ClassType.cloneWithLiteral(classSubtype, !(classSubtype.literalValue as boolean));
                    });
                }
            }
        }

        if (!type) {
            // __not__ always returns a boolean.
            if (node.operator === OperatorType.Not) {
                type = this.getBuiltInObject(node, 'bool');
                if (!type) {
                    type = UnknownType.create();
                }
            } else {
                if (isAnyOrUnknown(exprType)) {
                    type = exprType;
                } else {
                    const magicMethodName = unaryOperatorMap[node.operator];
                    type = this.getTypeOfMagicMethodReturn(exprType, [], magicMethodName, node, expectedType);
                }

                if (!type) {
                    const fileInfo = AnalyzerNodeInfo.getFileInfo(node);

                    if (expectedType) {
                        this.addDiagnostic(
                            fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                            DiagnosticRule.reportGeneralTypeIssues,
                            Localizer.Diagnostic.typeNotSupportUnaryOperatorBidirectional().format({
                                operator: ParseTreeUtils.printOperator(node.operator),
                                type: this.printType(exprType),
                                expectedType: this.printType(expectedType),
                            }),
                            node
                        );
                    } else {
                        this.addDiagnostic(
                            fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                            DiagnosticRule.reportGeneralTypeIssues,
                            Localizer.Diagnostic.typeNotSupportUnaryOperator().format({
                                operator: ParseTreeUtils.printOperator(node.operator),
                                type: this.printType(exprType),
                            }),
                            node
                        );
                    }
                    type = UnknownType.create();
                }
            }
        }

        return { type, isIncomplete };
    }

    getTypeOfBinaryOperation(
        node: BinaryOperationNode,
        expectedType: Type | undefined,
        flags: EvaluatorFlags
    ): TypeResult {
        const leftExpression = node.leftExpression;
        let rightExpression = node.rightExpression;
        let isIncomplete = false;

        // If this is a comparison and the left expression is also a comparison,
        // we need to change the behavior to accommodate python's "chained
        // comparisons" feature.
        if (ParseTreeUtils.operatorSupportsChaining(node.operator)) {
            if (
                rightExpression.nodeType === ParseNodeType.BinaryOperation &&
                !rightExpression.parenthesized &&
                ParseTreeUtils.operatorSupportsChaining(rightExpression.operator)
            ) {
                // Evaluate the right expression so it is type checked.
                this.getTypeOfBinaryOperation(rightExpression, expectedType, flags);

                // Use the left side of the right expression for comparison purposes.
                rightExpression = rightExpression.leftExpression;
            }
        }

        // For most binary operations, the "expected type" is applied to the output
        // of the magic method for that operation. However, the "or" and "and" operators
        // have no magic method, so we apply the expected type directly to both operands.
        let expectedOperandType =
            node.operator === OperatorType.Or || node.operator === OperatorType.And ? expectedType : undefined;

        // Handle the very special case where the expected type is a list
        // and the operator is a multiply. This comes up in the common case
        // of "x: List[Optional[X]] = [None] * y" where y is an integer literal.
        let expectedLeftOperandType: Type | undefined;
        if (
            node.operator === OperatorType.Multiply &&
            expectedType &&
            isClassInstance(expectedType) &&
            ClassType.isBuiltIn(expectedType, 'list') &&
            expectedType.typeArguments &&
            expectedType.typeArguments.length >= 1 &&
            node.leftExpression.nodeType === ParseNodeType.List
        ) {
            expectedLeftOperandType = expectedType;
        }

        const leftTypeResult = this.getTypeOfExpression(
            leftExpression,
            flags,
            expectedOperandType || expectedLeftOperandType
        );
        let leftType = leftTypeResult.type;

        if (!expectedOperandType) {
            if (node.operator === OperatorType.Or || node.operator === OperatorType.And) {
                // For "or" and "and", use the type of the left operand. This allows us to
                // infer a better type for expressions like `x or []`.
                expectedOperandType = leftType;
            } else if (node.operator === OperatorType.Add && node.rightExpression.nodeType === ParseNodeType.List) {
                // For the "+" operator , use this technique only if the right operand is
                // a list expression. This heuristic handles the common case of `my_list + [0]`.
                expectedOperandType = leftType;
            } else if (node.operator === OperatorType.BitwiseOr) {
                // If this is a bitwise or ("|"), use the type of the left operand. This allows
                // us to support the case where a TypedDict is being updated with a dict expression.
                expectedOperandType = leftType;
            }
        }

        const rightTypeResult = this.getTypeOfExpression(rightExpression, flags, expectedOperandType);
        let rightType = rightTypeResult.type;

        if (leftTypeResult.isIncomplete || rightTypeResult.isIncomplete) {
            isIncomplete = true;
        }

        // Is this a "|" operator used in a context where it is supposed to be
        // interpreted as a union operator?
        if (
            node.operator === OperatorType.BitwiseOr &&
            !this.customMetaclassSupportsMethod(leftType, '__or__') &&
            !this.customMetaclassSupportsMethod(rightType, '__ror__')
        ) {
            let adjustedRightType = rightType;
            let adjustedLeftType = leftType;
            if (!isNoneInstance(leftType) && isNoneInstance(rightType)) {
                // Handle the special case where "None" is being added to the union
                // with something else. Even though "None" will normally be interpreted
                // as the None singleton object in contexts where a type annotation isn't
                // assumed, we'll allow it here.
                adjustedRightType = NoneType.createType();
            } else if (!isNoneInstance(rightType) && isNoneInstance(leftType)) {
                adjustedLeftType = NoneType.createType();
            }

            if (isUnionableType([adjustedLeftType, adjustedRightType])) {
                const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
                const unionNotationSupported =
                    fileInfo.isStubFile ||
                    (flags & EvaluatorFlags.AllowForwardReferences) !== 0 ||
                    fileInfo.executionEnvironment.pythonVersion >= PythonVersion.V3_10;
                if (!unionNotationSupported) {
                    // If the left type is Any, we can't say for sure whether this
                    // is an illegal syntax or a valid application of the "|" operator.
                    if (!isAnyOrUnknown(adjustedLeftType)) {
                        this.addError(Localizer.Diagnostic.unionSyntaxIllegal(), node, node.operatorToken);
                    }
                }

                if (
                    !this.validateTypeArg(
                        { ...leftTypeResult, node: leftExpression },
                        { allowVariadicTypeVar: true, allowUnpackedTuples: true }
                    ) ||
                    !this.validateTypeArg(
                        { ...rightTypeResult, node: rightExpression },
                        { allowVariadicTypeVar: true, allowUnpackedTuples: true }
                    )
                ) {
                    return { type: UnknownType.create() };
                }

                const newUnion = combineTypes([adjustedLeftType, adjustedRightType]);
                if (isUnion(newUnion)) {
                    TypeBase.setSpecialForm(newUnion);
                }

                return { type: newUnion };
            }
        }

        // Optional checks apply to all operations except for boolean operations.
        let isLeftOptionalType = false;
        if (booleanOperatorMap[node.operator] === undefined) {
            // None is a valid operand for == and != even if the type stub says otherwise.
            if (node.operator === OperatorType.Equals || node.operator === OperatorType.NotEquals) {
                leftType = removeNoneFromUnion(leftType);
            } else {
                isLeftOptionalType = isOptionalType(leftType);
            }

            // None is a valid operand for == and != even if the type stub says otherwise.
            if (node.operator === OperatorType.Equals || node.operator === OperatorType.NotEquals) {
                rightType = removeNoneFromUnion(rightType);
            }
        }

        const diag = new DiagnosticAddendum();

        // Don't use literal math if either of the operand types are
        // incomplete because we may be evaluating types within a loop,
        // so the literal values may change each time.
        const isLiteralMathAllowed = !ParseTreeUtils.isWithinLoop(node);
        let type = this.validateBinaryOperation(
            node.operator,
            { type: leftType, isIncomplete: leftTypeResult.isIncomplete },
            { type: rightType, isIncomplete: rightTypeResult.isIncomplete },
            node,
            expectedType,
            diag,
            isLiteralMathAllowed
        );

        if (!diag.isEmpty() || !type) {
            if (!isIncomplete) {
                const fileInfo = AnalyzerNodeInfo.getFileInfo(node);

                if (isLeftOptionalType && diag.getMessages().length === 1) {
                    // If the left was an optional type and there is just one diagnostic,
                    // assume that it was due to a "None" not being supported. Report
                    // this as a reportOptionalOperand diagnostic rather than a
                    // reportGeneralTypeIssues diagnostic.
                    this.addDiagnostic(
                        AnalyzerNodeInfo.getFileInfo(node).diagnosticRuleSet.reportOptionalOperand,
                        DiagnosticRule.reportOptionalOperand,
                        Localizer.Diagnostic.noneOperator().format({
                            operator: ParseTreeUtils.printOperator(node.operator),
                        }),
                        node.leftExpression
                    );
                } else {
                    this.addDiagnostic(
                        fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                        DiagnosticRule.reportGeneralTypeIssues,
                        Localizer.Diagnostic.typeNotSupportBinaryOperator().format({
                            operator: ParseTreeUtils.printOperator(node.operator),
                            leftType: this.printType(leftType),
                            rightType: this.printType(rightType),
                        }) + diag.getString(),
                        node
                    );
                }
            }

            type = UnknownType.create();
        }

        return { type, isIncomplete };
    }

    customMetaclassSupportsMethod(type: Type, methodName: string): boolean {
        if (!isInstantiableClass(type)) {
            return false;
        }

        const metaclass = type.details.effectiveMetaclass;
        if (!metaclass || !isInstantiableClass(metaclass)) {
            return false;
        }

        if (ClassType.isBuiltIn(metaclass, 'type')) {
            return false;
        }

        const memberInfo = lookUpClassMember(metaclass, methodName);
        if (!memberInfo) {
            return false;
        }

        if (isInstantiableClass(memberInfo.classType) && ClassType.isBuiltIn(memberInfo.classType, 'type')) {
            return false;
        }

        return true;
    }

    getTypeOfAugmentedAssignment(node: AugmentedAssignmentNode, expectedType: Type | undefined): TypeResult {
        const operatorMap: { [operator: number]: [string, OperatorType] } = {
            [OperatorType.AddEqual]: ['__iadd__', OperatorType.Add],
            [OperatorType.SubtractEqual]: ['__isub__', OperatorType.Subtract],
            [OperatorType.MultiplyEqual]: ['__imul__', OperatorType.Multiply],
            [OperatorType.FloorDivideEqual]: ['__ifloordiv__', OperatorType.FloorDivide],
            [OperatorType.DivideEqual]: ['__itruediv__', OperatorType.Divide],
            [OperatorType.ModEqual]: ['__imod__', OperatorType.Mod],
            [OperatorType.PowerEqual]: ['__ipow__', OperatorType.Power],
            [OperatorType.MatrixMultiplyEqual]: ['__imatmul__', OperatorType.MatrixMultiply],
            [OperatorType.BitwiseAndEqual]: ['__iand__', OperatorType.BitwiseAnd],
            [OperatorType.BitwiseOrEqual]: ['__ior__', OperatorType.BitwiseOr],
            [OperatorType.BitwiseXorEqual]: ['__ixor__', OperatorType.BitwiseXor],
            [OperatorType.LeftShiftEqual]: ['__ilshift__', OperatorType.LeftShift],
            [OperatorType.RightShiftEqual]: ['__irshift__', OperatorType.RightShift],
        };

        let type: Type | undefined;
        let typeResult: TypeResult | undefined;
        const diag = new DiagnosticAddendum();

        const leftTypeResult = this.getTypeOfExpression(node.leftExpression);
        const leftType = leftTypeResult.type;

        let expectedOperandType: Type | undefined;
        if (node.operator === OperatorType.BitwiseOrEqual) {
            // If this is a bitwise or ("|="), use the type of the left operand. This allows
            // us to support the case where a TypedDict is being updated with a dict expression.
            expectedOperandType = leftType;
        }

        const rightTypeResult = this.getTypeOfExpression(
            node.rightExpression,
            /* flags */ undefined,
            expectedOperandType
        );
        const rightType = rightTypeResult.type;
        const isIncomplete = !!rightTypeResult.isIncomplete || !!leftTypeResult.isIncomplete;

        if (isNever(leftType) || isNever(rightType)) {
            typeResult = { type: NeverType.createNever(), isIncomplete };
        } else {
            type = this.mapSubtypesExpandTypeVars(
                leftType,
                /* conditionFilter */ undefined,
                (leftSubtypeExpanded, leftSubtypeUnexpanded) => {
                    return this.mapSubtypesExpandTypeVars(
                        rightType,
                        getTypeCondition(leftSubtypeExpanded),
                        (rightSubtypeExpanded, rightSubtypeUnexpanded) => {
                            if (isAnyOrUnknown(leftSubtypeUnexpanded) || isAnyOrUnknown(rightSubtypeUnexpanded)) {
                                return preserveUnknown(leftSubtypeUnexpanded, rightSubtypeUnexpanded);
                            }

                            const magicMethodName = operatorMap[node.operator][0];
                            let returnType = this.getTypeOfMagicMethodReturn(
                                leftSubtypeUnexpanded,
                                [{ type: rightSubtypeUnexpanded, isIncomplete: rightTypeResult.isIncomplete }],
                                magicMethodName,
                                node,
                                expectedType
                            );

                            if (!returnType && leftSubtypeUnexpanded !== leftSubtypeExpanded) {
                                // Try with the expanded left type.
                                returnType = this.getTypeOfMagicMethodReturn(
                                    leftSubtypeExpanded,
                                    [{ type: rightSubtypeUnexpanded, isIncomplete: rightTypeResult.isIncomplete }],
                                    magicMethodName,
                                    node,
                                    expectedType
                                );
                            }

                            if (!returnType && rightSubtypeUnexpanded !== rightSubtypeExpanded) {
                                // Try with the expanded left and right type.
                                returnType = this.getTypeOfMagicMethodReturn(
                                    leftSubtypeExpanded,
                                    [{ type: rightSubtypeExpanded, isIncomplete: rightTypeResult.isIncomplete }],
                                    magicMethodName,
                                    node,
                                    expectedType
                                );
                            }

                            if (!returnType) {
                                // If the LHS class didn't support the magic method for augmented
                                // assignment, fall back on the normal binary expression evaluator.
                                const binaryOperator = operatorMap[node.operator][1];

                                // Don't use literal math if either of the operand types are
                                // incomplete because we may be evaluating types within a loop,
                                // so the literal values may change each time.
                                const isLiteralMathAllowed =
                                    !leftTypeResult.isIncomplete &&
                                    !rightTypeResult.isIncomplete &&
                                    getUnionSubtypeCount(leftType) * getUnionSubtypeCount(rightType) <
                                        maxLiteralMathSubtypeCount;

                                returnType = this.validateBinaryOperation(
                                    binaryOperator,
                                    { type: leftSubtypeUnexpanded, isIncomplete: leftTypeResult.isIncomplete },
                                    { type: rightSubtypeUnexpanded, isIncomplete: rightTypeResult.isIncomplete },
                                    node,
                                    expectedType,
                                    diag,
                                    isLiteralMathAllowed
                                );
                            }

                            return returnType;
                        }
                    );
                }
            );

            // If the LHS class didn't support the magic method for augmented
            // assignment, fall back on the normal binary expression evaluator.
            if (!diag.isEmpty() || !type || isNever(type)) {
                if (!isIncomplete) {
                    const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
                    this.addDiagnostic(
                        fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                        DiagnosticRule.reportGeneralTypeIssues,
                        Localizer.Diagnostic.typeNotSupportBinaryOperator().format({
                            operator: ParseTreeUtils.printOperator(node.operator),
                            leftType: this.printType(leftType),
                            rightType: this.printType(rightType),
                        }) + diag.getString(),
                        node
                    );
                }

                type = UnknownType.create();
            }

            typeResult = { type, isIncomplete };
        }

        this.assignTypeToExpression(
            node.destExpression,
            typeResult.type,
            !!typeResult.isIncomplete,
            node.rightExpression
        );

        return typeResult;
    }

    validateBinaryOperation(
        operator: OperatorType,
        leftTypeResult: TypeResult,
        rightTypeResult: TypeResult,
        errorNode: ExpressionNode,
        expectedType: Type | undefined,
        diag: DiagnosticAddendum,
        isLiteralMathAllowed: boolean
    ): Type | undefined {
        const leftType = leftTypeResult.type;
        const rightType = rightTypeResult.type;
        let type: Type | undefined;
        let concreteLeftType = this.makeTopLevelTypeVarsConcrete(leftType);

        if (booleanOperatorMap[operator] !== undefined) {
            // If it's an AND or OR, we need to handle short-circuiting by
            // eliminating any known-truthy or known-falsy types.
            if (operator === OperatorType.And) {
                // If the LHS evaluates to falsy, the And expression will
                // always return the type of the left-hand side.
                if (!this.canBeTruthy(concreteLeftType)) {
                    return leftType;
                }

                // If the LHS evaluates to truthy, the And expression will
                // always return the type of the right-hand side.
                if (!this.canBeFalsy(concreteLeftType)) {
                    return rightType;
                }

                concreteLeftType = this.removeTruthinessFromType(concreteLeftType);

                if (isNever(rightType)) {
                    return concreteLeftType;
                }
            } else if (operator === OperatorType.Or) {
                // If the LHS evaluates to truthy, the Or expression will
                // always return the type of the left-hand side.
                if (!this.canBeFalsy(concreteLeftType)) {
                    return leftType;
                }

                // If the LHS evaluates to falsy, the Or expression will
                // always return the type of the right-hand side.
                if (!this.canBeTruthy(concreteLeftType)) {
                    return rightType;
                }

                concreteLeftType = this.removeFalsinessFromType(concreteLeftType);

                if (isNever(rightType)) {
                    return concreteLeftType;
                }
            }

            if (isNever(leftType) || isNever(rightType)) {
                return NeverType.createNever();
            }

            // The "in" and "not in" operators make use of the __contains__
            // magic method.
            if (operator === OperatorType.In || operator === OperatorType.NotIn) {
                type = this.mapSubtypesExpandTypeVars(
                    rightType,
                    /* conditionFilter */ undefined,
                    (rightSubtypeExpanded, rightSubtypeUnexpanded) => {
                        return this.mapSubtypesExpandTypeVars(
                            concreteLeftType,
                            getTypeCondition(rightSubtypeExpanded),
                            (leftSubtype) => {
                                if (isAnyOrUnknown(leftSubtype) || isAnyOrUnknown(rightSubtypeUnexpanded)) {
                                    return preserveUnknown(leftSubtype, rightSubtypeExpanded);
                                }

                                let returnType = this.getTypeOfMagicMethodReturn(
                                    rightSubtypeExpanded,
                                    [{ type: leftSubtype, isIncomplete: leftTypeResult.isIncomplete }],
                                    '__contains__',
                                    errorNode,
                                    /* expectedType */ undefined
                                );

                                if (!returnType) {
                                    // If __contains__ was not supported, fall back
                                    // on an iterable.
                                    const iteratorType = this.getTypeOfIterator(
                                        { type: rightSubtypeExpanded, isIncomplete: rightTypeResult.isIncomplete },
                                        /* isAsync */ false,
                                        /* errorNode */ undefined
                                    )?.type;

                                    if (iteratorType && this.assignType(iteratorType, leftSubtype)) {
                                        returnType = this.getBuiltInObject(errorNode, 'bool');
                                    }
                                }

                                if (!returnType) {
                                    diag.addMessage(
                                        Localizer.Diagnostic.typeNotSupportBinaryOperator().format({
                                            operator: ParseTreeUtils.printOperator(operator),
                                            leftType: this.printType(leftSubtype),
                                            rightType: this.printType(rightSubtypeExpanded),
                                        })
                                    );
                                }

                                return returnType;
                            }
                        );
                    }
                );

                // Assume that a bool is returned even if the type is unknown
                if (type && !isNever(type)) {
                    type = this.getBuiltInObject(errorNode, 'bool');
                }
            } else {
                type = this.mapSubtypesExpandTypeVars(
                    concreteLeftType,
                    /* conditionFilter */ undefined,
                    (leftSubtypeExpanded, leftSubtypeUnexpanded) => {
                        return this.mapSubtypesExpandTypeVars(
                            rightType,
                            getTypeCondition(leftSubtypeExpanded),
                            (rightSubtypeExpanded, rightSubtypeUnexpanded) => {
                                // If the operator is an AND or OR, we need to combine the two types.
                                if (operator === OperatorType.And || operator === OperatorType.Or) {
                                    return combineTypes([leftSubtypeUnexpanded, rightSubtypeUnexpanded]);
                                }
                                // The other boolean operators always return a bool value.
                                return this.getBuiltInObject(errorNode, 'bool');
                            }
                        );
                    }
                );
            }
        } else if (binaryOperatorMap[operator]) {
            if (isNever(leftType) || isNever(rightType)) {
                return NeverType.createNever();
            }

            // Handle certain operations on certain homogenous literal types
            // using special-case math. For example, Literal[1, 2] + Literal[3, 4]
            // should result in Literal[4, 5, 6].
            if (isLiteralMathAllowed) {
                const leftLiteralClassName = getLiteralTypeClassName(leftType);
                if (leftLiteralClassName && !getTypeCondition(leftType)) {
                    const rightLiteralClassName = getLiteralTypeClassName(rightType);

                    if (
                        leftLiteralClassName === rightLiteralClassName &&
                        !getTypeCondition(rightType) &&
                        getUnionSubtypeCount(leftType) * getUnionSubtypeCount(rightType) < maxLiteralMathSubtypeCount
                    ) {
                        if (leftLiteralClassName === 'str' || leftLiteralClassName === 'bytes') {
                            if (operator === OperatorType.Add) {
                                type = mapSubtypes(leftType, (leftSubtype) => {
                                    return mapSubtypes(rightType, (rightSubtype) => {
                                        const leftClassSubtype = leftSubtype as ClassType;
                                        const rightClassSubtype = rightSubtype as ClassType;

                                        return ClassType.cloneWithLiteral(
                                            leftClassSubtype,
                                            ((leftClassSubtype.literalValue as string) +
                                                rightClassSubtype.literalValue) as string
                                        );
                                    });
                                });
                            }
                        } else if (leftLiteralClassName === 'int') {
                            if (
                                operator === OperatorType.Add ||
                                operator === OperatorType.Subtract ||
                                operator === OperatorType.Multiply ||
                                operator === OperatorType.FloorDivide ||
                                operator === OperatorType.Mod
                            ) {
                                let isValidResult = true;

                                type = mapSubtypes(leftType, (leftSubtype) => {
                                    return mapSubtypes(rightType, (rightSubtype) => {
                                        try {
                                            const leftClassSubtype = leftSubtype as ClassType;
                                            const rightClassSubtype = rightSubtype as ClassType;
                                            const leftLiteralValue = BigInt(
                                                leftClassSubtype.literalValue as number | bigint
                                            );
                                            const rightLiteralValue = BigInt(
                                                rightClassSubtype.literalValue as number | bigint
                                            );

                                            let newValue: number | bigint | undefined;
                                            if (operator === OperatorType.Add) {
                                                newValue = leftLiteralValue + rightLiteralValue;
                                            } else if (operator === OperatorType.Subtract) {
                                                newValue = leftLiteralValue - rightLiteralValue;
                                            } else if (operator === OperatorType.Multiply) {
                                                newValue = leftLiteralValue * rightLiteralValue;
                                            } else if (operator === OperatorType.FloorDivide) {
                                                if (rightLiteralValue !== BigInt(0)) {
                                                    newValue = leftLiteralValue / rightLiteralValue;
                                                }
                                            } else if (operator === OperatorType.Mod) {
                                                if (rightLiteralValue !== BigInt(0)) {
                                                    newValue = leftLiteralValue % rightLiteralValue;
                                                }
                                            }

                                            if (newValue === undefined) {
                                                isValidResult = false;
                                                return undefined;
                                            } else if (typeof newValue === 'number' && isNaN(newValue)) {
                                                isValidResult = false;
                                                return undefined;
                                            } else {
                                                // Convert back to a simple number if it fits. Leave as a bigint
                                                // if it doesn't.
                                                if (newValue === BigInt(Number(newValue))) {
                                                    newValue = Number(newValue);
                                                }

                                                return ClassType.cloneWithLiteral(leftClassSubtype, newValue);
                                            }
                                        } catch {
                                            isValidResult = false;
                                            return undefined;
                                        }
                                    });
                                });

                                if (!isValidResult) {
                                    type = undefined;
                                }
                            }
                        }
                    }
                }
            }

            if (!type) {
                type = this.mapSubtypesExpandTypeVars(
                    leftType,
                    /* conditionFilter */ undefined,
                    (leftSubtypeExpanded, leftSubtypeUnexpanded) => {
                        return this.mapSubtypesExpandTypeVars(
                            rightType,
                            getTypeCondition(leftSubtypeExpanded),
                            (rightSubtypeExpanded, rightSubtypeUnexpanded) => {
                                if (isAnyOrUnknown(leftSubtypeUnexpanded) || isAnyOrUnknown(rightSubtypeUnexpanded)) {
                                    return preserveUnknown(leftSubtypeUnexpanded, rightSubtypeUnexpanded);
                                }

                                // Special-case __add__ for tuples when the types for both tuples are known.
                                if (
                                    operator === OperatorType.Add &&
                                    isClassInstance(leftSubtypeExpanded) &&
                                    isTupleClass(leftSubtypeExpanded) &&
                                    leftSubtypeExpanded.tupleTypeArguments &&
                                    !isUnboundedTupleClass(leftSubtypeExpanded) &&
                                    isClassInstance(rightSubtypeExpanded) &&
                                    isTupleClass(rightSubtypeExpanded) &&
                                    rightSubtypeExpanded.tupleTypeArguments &&
                                    !isUnboundedTupleClass(rightSubtypeExpanded) &&
                                    this._tupleClassType &&
                                    isInstantiableClass(this._tupleClassType)
                                ) {
                                    return ClassType.cloneAsInstance(
                                        specializeTupleClass(this._tupleClassType, [
                                            ...leftSubtypeExpanded.tupleTypeArguments,
                                            ...rightSubtypeExpanded.tupleTypeArguments,
                                        ])
                                    );
                                }

                                const magicMethodName = binaryOperatorMap[operator][0];
                                let resultType = this.getTypeOfMagicMethodReturn(
                                    this.convertFunctionToObject(leftSubtypeUnexpanded),
                                    [{ type: rightSubtypeUnexpanded, isIncomplete: rightTypeResult.isIncomplete }],
                                    magicMethodName,
                                    errorNode,
                                    expectedType
                                );

                                if (!resultType && leftSubtypeUnexpanded !== leftSubtypeExpanded) {
                                    // Try the expanded left type.
                                    resultType = this.getTypeOfMagicMethodReturn(
                                        this.convertFunctionToObject(leftSubtypeExpanded),
                                        [{ type: rightSubtypeUnexpanded, isIncomplete: rightTypeResult.isIncomplete }],
                                        magicMethodName,
                                        errorNode,
                                        expectedType
                                    );
                                }

                                if (!resultType && rightSubtypeUnexpanded !== rightSubtypeExpanded) {
                                    // Try the expanded left and right type.
                                    resultType = this.getTypeOfMagicMethodReturn(
                                        this.convertFunctionToObject(leftSubtypeExpanded),
                                        [{ type: rightSubtypeExpanded, isIncomplete: rightTypeResult.isIncomplete }],
                                        magicMethodName,
                                        errorNode,
                                        expectedType
                                    );
                                }

                                if (!resultType) {
                                    // Try the alternate form (swapping right and left).
                                    const altMagicMethodName = binaryOperatorMap[operator][1];
                                    resultType = this.getTypeOfMagicMethodReturn(
                                        this.convertFunctionToObject(rightSubtypeUnexpanded),
                                        [{ type: leftSubtypeUnexpanded, isIncomplete: leftTypeResult.isIncomplete }],
                                        altMagicMethodName,
                                        errorNode,
                                        expectedType
                                    );

                                    if (!resultType && rightSubtypeUnexpanded !== rightSubtypeExpanded) {
                                        // Try the expanded right type.
                                        resultType = this.getTypeOfMagicMethodReturn(
                                            this.convertFunctionToObject(rightSubtypeExpanded),
                                            [
                                                {
                                                    type: leftSubtypeUnexpanded,
                                                    isIncomplete: leftTypeResult.isIncomplete,
                                                },
                                            ],
                                            altMagicMethodName,
                                            errorNode,
                                            expectedType
                                        );
                                    }

                                    if (!resultType && leftSubtypeUnexpanded !== leftSubtypeExpanded) {
                                        // Try the expanded right and left type.
                                        resultType = this.getTypeOfMagicMethodReturn(
                                            this.convertFunctionToObject(rightSubtypeExpanded),
                                            [{ type: leftSubtypeExpanded, isIncomplete: leftTypeResult.isIncomplete }],
                                            altMagicMethodName,
                                            errorNode,
                                            expectedType
                                        );
                                    }
                                }

                                if (!resultType) {
                                    if (expectedType) {
                                        diag.addMessage(
                                            Localizer.Diagnostic.typeNotSupportBinaryOperatorBidirectional().format({
                                                operator: ParseTreeUtils.printOperator(operator),
                                                leftType: this.printType(leftSubtypeExpanded),
                                                rightType: this.printType(rightSubtypeExpanded),
                                                expectedType: this.printType(expectedType),
                                            })
                                        );
                                    } else {
                                        diag.addMessage(
                                            Localizer.Diagnostic.typeNotSupportBinaryOperator().format({
                                                operator: ParseTreeUtils.printOperator(operator),
                                                leftType: this.printType(leftSubtypeExpanded),
                                                rightType: this.printType(rightSubtypeExpanded),
                                            })
                                        );
                                    }
                                }
                                return resultType;
                            }
                        );
                    }
                );
            }
        }

        return type && isNever(type) ? undefined : type;
    }

    getTypeOfMagicMethodReturn(
        objType: Type,
        args: TypeResult[],
        magicMethodName: string,
        errorNode: ExpressionNode,
        expectedType: Type | undefined
    ): Type | undefined {
        let magicMethodSupported = true;

        // Create a helper lambda for object subtypes.
        const handleSubtype = (subtype: ClassType | TypeVarType) => {
            let magicMethodType: Type | undefined;
            const concreteSubtype = this.makeTopLevelTypeVarsConcrete(subtype);

            if (isClassInstance(concreteSubtype)) {
                magicMethodType = this.getTypeOfObjectMember(
                    errorNode,
                    concreteSubtype,
                    magicMethodName,
                    /* usage */ undefined,
                    /* diag */ undefined,
                    MemberAccessFlags.SkipAttributeAccessOverride | MemberAccessFlags.AccessClassMembersOnly,
                    subtype
                )?.type;
            } else if (isInstantiableClass(concreteSubtype)) {
                magicMethodType = this.getTypeOfClassMember(
                    errorNode,
                    concreteSubtype,
                    magicMethodName,
                    /* usage */ undefined,
                    /* diag */ undefined,
                    MemberAccessFlags.SkipAttributeAccessOverride | MemberAccessFlags.ConsiderMetaclassOnly
                )?.type;
            }

            if (magicMethodType) {
                const functionArgs: FunctionArgument[] = args.map((arg) => {
                    return {
                        argumentCategory: ArgumentCategory.Simple,
                        typeResult: arg,
                    };
                });

                let callResult: CallResult | undefined;

                this.useSpeculativeMode(errorNode, () => {
                    callResult = this.validateCallArguments(
                        errorNode,
                        functionArgs,
                        { type: magicMethodType! },
                        /* typeVarContext */ undefined,
                        /* skipUnknownArgCheck */ true,
                        expectedType
                    );
                });

                if (callResult!.argumentErrors) {
                    magicMethodSupported = false;
                }

                return callResult!.returnType;
            }

            magicMethodSupported = false;
            return undefined;
        };

        const returnType = mapSubtypes(objType, (subtype) => {
            if (isAnyOrUnknown(subtype)) {
                return subtype;
            }

            if (isClassInstance(subtype) || isInstantiableClass(subtype) || isTypeVar(subtype)) {
                return handleSubtype(subtype);
            }

            if (isNoneInstance(subtype)) {
                if (this._objectType && isClassInstance(this._objectType)) {
                    // Use 'object' for 'None'.
                    return handleSubtype(this._objectType);
                }
            }

            if (isNoneTypeClass(subtype)) {
                if (this._typeClassType && isInstantiableClass(this._typeClassType)) {
                    // Use 'type' for 'type[None]'.
                    return handleSubtype(ClassType.cloneAsInstance(this._typeClassType));
                }
            }

            magicMethodSupported = false;
            return undefined;
        });

        if (!magicMethodSupported) {
            return undefined;
        }

        return returnType;
    }

    // All functions in Python derive from object, so they inherit all
    // of the capabilities of an object. This function converts a function
    // to an object instance.
    convertFunctionToObject(type: Type) {
        if (isFunction(type) || isOverloadedFunction(type)) {
            if (this._objectType) {
                return this._objectType;
            }
        }

        return type;
    }

    getTypeOfDictionary(node: DictionaryNode, expectedType: Type | undefined): TypeResult {
        // If the expected type is a union, analyze for each of the subtypes
        // to find one that matches.
        let effectiveExpectedType = expectedType;

        if (expectedType && isUnion(expectedType)) {
            let matchingSubtype: Type | undefined;
            let matchingSubtypeResult: TypeResult | undefined;

            doForEachSubtype(expectedType, (subtype) => {
                // Use shortcut if we've already found a match.
                if (matchingSubtypeResult && !matchingSubtypeResult.typeErrors) {
                    return;
                }

                const subtypeResult = this.useSpeculativeMode(node, () => {
                    return this.getTypeOfDictionaryExpected(node, subtype);
                });

                if (subtypeResult && this.assignType(subtype, subtypeResult.type)) {
                    // If this is the first result we're seeing or it's the first result
                    // without errors, select it as the match.
                    if (!matchingSubtypeResult || (matchingSubtypeResult.typeErrors && !subtypeResult.typeErrors)) {
                        matchingSubtype = subtype;
                        matchingSubtypeResult = subtypeResult;
                    }
                }
            });

            effectiveExpectedType = matchingSubtype;
        }

        let expectedTypeDiagAddendum = undefined;
        if (effectiveExpectedType) {
            expectedTypeDiagAddendum = new DiagnosticAddendum();
            const result = this.getTypeOfDictionaryExpected(node, effectiveExpectedType, expectedTypeDiagAddendum);
            if (result) {
                return result;
            }
        }

        const result = this.getTypeOfDictionaryInferred(node, /* hasExpectedType */ !!expectedType);
        return { ...result, expectedTypeDiagAddendum };
    }

    // Attempts to infer the type of a dictionary statement. If an expectedType
    // is provided, the resulting type must be compatible with the expected type.
    // If this isn't possible, undefined is returned.
    getTypeOfDictionaryExpected(
        node: DictionaryNode,
        expectedType: Type,
        expectedDiagAddendum?: DiagnosticAddendum
    ): TypeResult | undefined {
        expectedType = transformPossibleRecursiveTypeAlias(expectedType);

        if (!isClassInstance(expectedType)) {
            return undefined;
        }

        const keyTypes: TypeResultWithNode[] = [];
        const valueTypes: TypeResultWithNode[] = [];
        let isIncomplete = false;

        // Handle TypedDict's as a special case.
        if (ClassType.isTypedDictClass(expectedType)) {
            const expectedTypedDictEntries = getTypedDictMembersForClass(this, expectedType);

            // Infer the key and value types if possible.
            if (
                this.getKeyAndValueTypesFromDictionary(
                    node,
                    keyTypes,
                    valueTypes,
                    /* forceStrictInference */ true,
                    /* expectedKeyType */ undefined,
                    /* expectedValueType */ undefined,
                    expectedTypedDictEntries,
                    expectedDiagAddendum
                )
            ) {
                isIncomplete = true;
            }

            if (ClassType.isTypedDictClass(expectedType)) {
                const resultTypedDict = assignToTypedDict(
                    this,
                    expectedType,
                    keyTypes,
                    valueTypes,
                    // Don't overwrite existing expectedDiagAddendum messages if they were
                    // already provided by getKeyValueTypesFromDictionary.
                    expectedDiagAddendum?.isEmpty() ? expectedDiagAddendum : undefined
                );
                if (resultTypedDict) {
                    return {
                        type: resultTypedDict,
                        isIncomplete,
                    };
                }
            }

            return undefined;
        }

        const builtInDict = this.getBuiltInObject(node, 'dict');
        if (!isClassInstance(builtInDict)) {
            return undefined;
        }

        const dictTypeVarContext = new TypeVarContext(getTypeVarScopeId(builtInDict));
        if (
            !populateTypeVarContextBasedOnExpectedType(
                this,
                builtInDict,
                expectedType,
                dictTypeVarContext,
                this.getTypeVarScopesForNode(node)
            )
        ) {
            return undefined;
        }

        const specializedDict = applySolvedTypeVars(
            ClassType.cloneAsInstantiable(builtInDict),
            dictTypeVarContext
        ) as ClassType;
        if (!specializedDict.typeArguments || specializedDict.typeArguments.length !== 2) {
            return undefined;
        }

        const expectedKeyType = specializedDict.typeArguments[0];
        const expectedValueType = specializedDict.typeArguments[1];

        // Infer the key and value types if possible.
        if (
            this.getKeyAndValueTypesFromDictionary(
                node,
                keyTypes,
                valueTypes,
                /* forceStrictInference */ true,
                expectedKeyType,
                expectedValueType,
                undefined,
                expectedDiagAddendum
            )
        ) {
            isIncomplete = true;
        }

        // Dict and MutableMapping types have invariant value types, so they
        // cannot be narrowed further. Other super-types like Mapping, Collection,
        // and Iterable use covariant value types, so they can be narrowed.
        const isValueTypeInvariant =
            isClassInstance(expectedType) &&
            (ClassType.isBuiltIn(expectedType, 'dict') || ClassType.isBuiltIn(expectedType, 'MutableMapping'));

        const specializedKeyType = this.inferTypeArgFromExpectedType(
            expectedKeyType,
            keyTypes.map((result) => result.type),
            /* isNarrowable */ false
        );
        const specializedValueType = this.inferTypeArgFromExpectedType(
            expectedValueType,
            valueTypes.map((result) => result.type),
            /* isNarrowable */ !isValueTypeInvariant
        );
        if (!specializedKeyType || !specializedValueType) {
            return undefined;
        }

        const type = this.getBuiltInObject(node, 'dict', [specializedKeyType, specializedValueType]);
        return { type, isIncomplete };
    }

    // Attempts to infer the type of a dictionary statement. If hasExpectedType
    // is true, strict inference is used for the subexpressions.
    getTypeOfDictionaryInferred(node: DictionaryNode, hasExpectedType: boolean): TypeResult {
        const fallbackType = hasExpectedType ? AnyType.create() : UnknownType.create();
        let keyType: Type = fallbackType;
        let valueType: Type = fallbackType;

        const keyTypeResults: TypeResultWithNode[] = [];
        const valueTypeResults: TypeResultWithNode[] = [];

        let isEmptyContainer = false;
        let isIncomplete = false;

        // Infer the key and value types if possible.
        if (
            this.getKeyAndValueTypesFromDictionary(
                node,
                keyTypeResults,
                valueTypeResults,
                /* forceStrictInference */ hasExpectedType
            )
        ) {
            isIncomplete = true;
        }

        // Strip any literal values.
        const keyTypes = keyTypeResults.map((t) => this.stripLiteralValue(t.type));
        const valueTypes = valueTypeResults.map((t) => this.stripLiteralValue(t.type));

        keyType = keyTypes.length > 0 ? combineTypes(keyTypes) : fallbackType;

        // If the value type differs and we're not using "strict inference mode",
        // we need to back off because we can't properly represent the mappings
        // between different keys and associated value types. If all the values
        // are the same type, we'll assume that all values in this dictionary should
        // be the same.
        if (valueTypes.length > 0) {
            if (AnalyzerNodeInfo.getFileInfo(node).diagnosticRuleSet.strictDictionaryInference || hasExpectedType) {
                valueType = combineTypes(valueTypes);
            } else {
                valueType = areTypesSame(valueTypes, { ignorePseudoGeneric: true }) ? valueTypes[0] : fallbackType;
            }
        } else {
            valueType = fallbackType;
            isEmptyContainer = true;
        }

        const dictClass = this.getBuiltInType(node, 'dict');
        const type = isInstantiableClass(dictClass)
            ? ClassType.cloneAsInstance(
                  ClassType.cloneForSpecialization(
                      dictClass,
                      [keyType, valueType],
                      /* isTypeArgumentExplicit */ true,
                      /* includeSubclasses */ undefined,
                      /* TupleTypeArguments */ undefined,
                      isEmptyContainer
                  )
              )
            : UnknownType.create();

        return { type, isIncomplete };
    }

    getKeyAndValueTypesFromDictionary(
        node: DictionaryNode,
        keyTypes: TypeResultWithNode[],
        valueTypes: TypeResultWithNode[],
        forceStrictInference: boolean,
        expectedKeyType?: Type,
        expectedValueType?: Type,
        expectedTypedDictEntries?: Map<string, TypedDictEntry>,
        expectedDiagAddendum?: DiagnosticAddendum
    ): boolean {
        let isIncomplete = false;

        // Infer the key and value types if possible.
        node.entries.forEach((entryNode, index) => {
            let addUnknown = true;

            if (entryNode.nodeType === ParseNodeType.DictionaryKeyEntry) {
                const keyTypeResult = this.getTypeOfExpression(
                    entryNode.keyExpression,
                    /* flags */ undefined,
                    expectedKeyType ?? (forceStrictInference ? NeverType.createNever() : undefined)
                );

                if (keyTypeResult.isIncomplete) {
                    isIncomplete = true;
                }

                const keyType = keyTypeResult.type;

                if (!keyTypeResult.isIncomplete && !keyTypeResult.typeErrors) {
                    this.verifySetEntryOrDictKeyIsHashable(entryNode.keyExpression, keyType, /* isDictKey */ true);
                }

                let valueTypeResult: TypeResult;

                if (
                    expectedTypedDictEntries &&
                    isClassInstance(keyType) &&
                    ClassType.isBuiltIn(keyType, 'str') &&
                    isLiteralType(keyType) &&
                    expectedTypedDictEntries.has(keyType.literalValue as string)
                ) {
                    valueTypeResult = this.getTypeOfExpression(
                        entryNode.valueExpression,
                        /* flags */ undefined,
                        expectedTypedDictEntries.get(keyType.literalValue as string)!.valueType
                    );
                } else {
                    valueTypeResult = this.getTypeOfExpression(
                        entryNode.valueExpression,
                        /* flags */ undefined,
                        expectedValueType ?? (forceStrictInference ? NeverType.createNever() : undefined)
                    );
                }

                if (expectedDiagAddendum && valueTypeResult.expectedTypeDiagAddendum) {
                    expectedDiagAddendum.addAddendum(valueTypeResult.expectedTypeDiagAddendum);
                }

                const valueType = valueTypeResult.type;
                if (valueTypeResult.isIncomplete) {
                    isIncomplete = true;
                }

                if (forceStrictInference || index < maxEntriesToUseForInference) {
                    keyTypes.push({ node: entryNode.keyExpression, type: keyType });
                    valueTypes.push({ node: entryNode.valueExpression, type: valueType });
                }

                addUnknown = false;
            } else if (entryNode.nodeType === ParseNodeType.DictionaryExpandEntry) {
                const unexpandedTypeResult = this.getTypeOfExpression(entryNode.expandExpression);
                if (unexpandedTypeResult.isIncomplete) {
                    isIncomplete = true;
                }

                const unexpandedType = unexpandedTypeResult.type;
                if (isAnyOrUnknown(unexpandedType)) {
                    addUnknown = false;
                } else if (isClassInstance(unexpandedType) && ClassType.isTypedDictClass(unexpandedType)) {
                    // Handle dictionary expansion for a TypedDict.
                    if (this._strClassType && isInstantiableClass(this._strClassType)) {
                        const strObject = ClassType.cloneAsInstance(this._strClassType);
                        const tdEntries = getTypedDictMembersForClass(this, unexpandedType, /* allowNarrowed */ true);

                        tdEntries.forEach((entry, name) => {
                            if (entry.isRequired || entry.isProvided) {
                                keyTypes.push({ node: entryNode, type: ClassType.cloneWithLiteral(strObject, name) });
                                valueTypes.push({ node: entryNode, type: entry.valueType });
                            }
                        });

                        addUnknown = false;
                    }
                } else {
                    // Verify that the type supports the `keys` and `__getitem__` methods.
                    // This protocol is defined in the _typeshed stub. If we can't find
                    // it there, fall back on typing.Mapping.
                    let mappingType = this.getTypeshedType(node, 'SupportsKeysAndGetItem');
                    if (!mappingType) {
                        mappingType = this.getTypingType(node, 'Mapping');
                    }
                    if (mappingType && isInstantiableClass(mappingType)) {
                        const mappingTypeVarContext = new TypeVarContext(getTypeVarScopeId(mappingType));

                        // Self-specialize the class.
                        mappingType = ClassType.cloneForSpecialization(
                            mappingType,
                            mappingType.details.typeParameters,
                            /* isTypeArgumentExplicit */ true
                        );

                        if (
                            this.assignType(
                                ClassType.cloneAsInstance(mappingType),
                                unexpandedType,
                                /* diag */ undefined,
                                mappingTypeVarContext
                            )
                        ) {
                            const specializedMapping = applySolvedTypeVars(
                                mappingType,
                                mappingTypeVarContext
                            ) as ClassType;
                            const typeArgs = specializedMapping.typeArguments;
                            if (typeArgs && typeArgs.length >= 2) {
                                if (forceStrictInference || index < maxEntriesToUseForInference) {
                                    keyTypes.push({ node: entryNode, type: typeArgs[0] });
                                    valueTypes.push({ node: entryNode, type: typeArgs[1] });
                                }
                                addUnknown = false;
                            }
                        } else {
                            const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
                            this.addDiagnostic(
                                fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                                DiagnosticRule.reportGeneralTypeIssues,
                                Localizer.Diagnostic.dictUnpackIsNotMapping(),
                                entryNode
                            );
                        }
                    }
                }
            } else if (entryNode.nodeType === ParseNodeType.ListComprehension) {
                const dictEntryTypeResult = this.getElementTypeFromListComprehension(
                    entryNode,
                    expectedValueType,
                    expectedKeyType
                );
                const dictEntryType = dictEntryTypeResult.type;
                if (dictEntryTypeResult.isIncomplete) {
                    isIncomplete = true;
                }

                // The result should be a tuple.
                if (isClassInstance(dictEntryType) && isTupleClass(dictEntryType)) {
                    const typeArgs = dictEntryType.tupleTypeArguments?.map((t) => t.type);
                    if (typeArgs && typeArgs.length === 2) {
                        if (forceStrictInference || index < maxEntriesToUseForInference) {
                            keyTypes.push({ node: entryNode, type: typeArgs[0] });
                            valueTypes.push({ node: entryNode, type: typeArgs[1] });
                        }
                        addUnknown = false;
                    }
                }
            }

            if (addUnknown) {
                if (forceStrictInference || index < maxEntriesToUseForInference) {
                    keyTypes.push({ node: entryNode, type: UnknownType.create() });
                    valueTypes.push({ node: entryNode, type: UnknownType.create() });
                }
            }
        });

        return isIncomplete;
    }

    getTypeOfListOrSet(node: ListNode | SetNode, expectedType: Type | undefined): TypeResult {
        // If the expected type is a union, recursively call for each of the subtypes
        // to find one that matches.
        let effectiveExpectedType = expectedType;

        if (expectedType && isUnion(expectedType)) {
            let matchingSubtype: Type | undefined;
            let matchingSubtypeResult: TypeResult | undefined;

            doForEachSubtype(expectedType, (subtype) => {
                // Use shortcut if we've already found a match.
                if (matchingSubtypeResult && !matchingSubtypeResult.typeErrors) {
                    return;
                }

                const subtypeResult = this.useSpeculativeMode(node, () => {
                    return this.getTypeOfListOrSetExpected(node, subtype);
                });

                if (subtypeResult && this.assignType(subtype, subtypeResult.type)) {
                    // If this is the first result we're seeing or it's the first result
                    // without errors, select it as the match.
                    if (!matchingSubtypeResult || (matchingSubtypeResult.typeErrors && !subtypeResult.typeErrors)) {
                        matchingSubtype = subtype;
                        matchingSubtypeResult = subtypeResult;
                    }
                }
            });

            effectiveExpectedType = matchingSubtype;
        }

        let expectedTypeDiagAddendum: DiagnosticAddendum | undefined;
        if (effectiveExpectedType) {
            const result = this.getTypeOfListOrSetExpected(node, effectiveExpectedType);
            if (result && !result.typeErrors) {
                return result;
            }

            expectedTypeDiagAddendum = result?.expectedTypeDiagAddendum;
        }

        const typeResult = this.getTypeOfListOrSetInferred(node, /* hasExpectedType */ expectedType !== undefined);
        return { ...typeResult, expectedTypeDiagAddendum };
    }

    // Attempts to determine the type of a list or set statement based on an expected type.
    // Returns undefined if that type cannot be honored.
    getTypeOfListOrSetExpected(node: ListNode | SetNode, expectedType: Type): TypeResult | undefined {
        const builtInClassName = node.nodeType === ParseNodeType.List ? 'list' : 'set';
        expectedType = transformPossibleRecursiveTypeAlias(expectedType);
        let isIncomplete = false;
        let typeErrors = false;
        const verifyHashable = node.nodeType === ParseNodeType.Set;

        if (!isClassInstance(expectedType)) {
            return undefined;
        }

        const builtInListOrSet = this.getBuiltInObject(node, builtInClassName);
        if (!isClassInstance(builtInListOrSet)) {
            return undefined;
        }

        const typeVarContext = new TypeVarContext(getTypeVarScopeId(builtInListOrSet));
        if (
            !populateTypeVarContextBasedOnExpectedType(
                this,
                builtInListOrSet,
                expectedType,
                typeVarContext,
                this.getTypeVarScopesForNode(node)
            )
        ) {
            return undefined;
        }

        const specializedListOrSet = applySolvedTypeVars(
            ClassType.cloneAsInstantiable(builtInListOrSet),
            typeVarContext
        ) as ClassType;
        if (!specializedListOrSet.typeArguments || specializedListOrSet.typeArguments.length !== 1) {
            return undefined;
        }

        const expectedEntryType = specializedListOrSet.typeArguments[0];

        const entryTypes: Type[] = [];
        const expectedTypeDiagAddendum = new DiagnosticAddendum();
        node.entries.forEach((entry) => {
            let entryTypeResult: TypeResult;

            if (entry.nodeType === ParseNodeType.ListComprehension) {
                entryTypeResult = this.getElementTypeFromListComprehension(entry, expectedEntryType);
            } else {
                entryTypeResult = this.getTypeOfExpression(entry, /* flags */ undefined, expectedEntryType);
            }

            entryTypes.push(entryTypeResult.type);

            if (entryTypeResult.isIncomplete) {
                isIncomplete = true;
            }

            if (entryTypeResult.typeErrors) {
                typeErrors = true;
            }

            if (entryTypeResult.expectedTypeDiagAddendum) {
                expectedTypeDiagAddendum.addAddendum(entryTypeResult.expectedTypeDiagAddendum);
            }

            if (verifyHashable && !entryTypeResult.isIncomplete && !entryTypeResult.typeErrors) {
                this.verifySetEntryOrDictKeyIsHashable(entry, entryTypeResult.type, /* isDictKey */ false);
            }
        });

        const isExpectedTypeListOrSet =
            isClassInstance(expectedType) && ClassType.isBuiltIn(expectedType, builtInClassName);
        const specializedEntryType = this.inferTypeArgFromExpectedType(
            expectedEntryType,
            entryTypes,
            /* isNarrowable */ !isExpectedTypeListOrSet
        );
        if (!specializedEntryType) {
            return { type: UnknownType.create(), isIncomplete, typeErrors: true, expectedTypeDiagAddendum };
        }

        const type = this.getBuiltInObject(node, builtInClassName, [specializedEntryType]);
        return { type, isIncomplete, typeErrors, expectedTypeDiagAddendum };
    }

    // Attempts to infer the type of a list or set statement with no "expected type".
    getTypeOfListOrSetInferred(node: ListNode | SetNode, hasExpectedType: boolean): TypeResult {
        const builtInClassName = node.nodeType === ParseNodeType.List ? 'list' : 'set';
        const verifyHashable = node.nodeType === ParseNodeType.Set;
        let isEmptyContainer = false;
        let isIncomplete = false;
        let typeErrors = false;

        let entryTypes: Type[] = [];
        node.entries.forEach((entry, index) => {
            let entryTypeResult: TypeResult;

            if (entry.nodeType === ParseNodeType.ListComprehension) {
                entryTypeResult = this.getElementTypeFromListComprehension(entry);
            } else {
                entryTypeResult = this.getTypeOfExpression(entry);
            }

            if (entryTypeResult.isIncomplete) {
                isIncomplete = true;
            }

            if (entryTypeResult.typeErrors) {
                typeErrors = true;
            }

            if (index < maxEntriesToUseForInference) {
                entryTypes.push(entryTypeResult.type);
            }

            if (verifyHashable && !entryTypeResult.isIncomplete && !entryTypeResult.typeErrors) {
                this.verifySetEntryOrDictKeyIsHashable(entry, entryTypeResult.type, /* isDictKey */ false);
            }
        });

        entryTypes = entryTypes.map((t) => this.stripLiteralValue(t));

        let inferredEntryType: Type = hasExpectedType ? AnyType.create() : UnknownType.create();
        if (entryTypes.length > 0) {
            const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
            // If there was an expected type or we're using strict list inference,
            // combine the types into a union.
            if (
                (builtInClassName === 'list' && fileInfo.diagnosticRuleSet.strictListInference) ||
                (builtInClassName === 'set' && fileInfo.diagnosticRuleSet.strictSetInference) ||
                hasExpectedType
            ) {
                inferredEntryType = combineTypes(entryTypes, maxSubtypesForInferredType);
            } else {
                // Is the list or set homogeneous? If so, use stricter rules. Otherwise relax the rules.
                inferredEntryType = areTypesSame(entryTypes, { ignorePseudoGeneric: true })
                    ? entryTypes[0]
                    : inferredEntryType;
            }
        } else {
            isEmptyContainer = true;
        }

        const listOrSetClass = this.getBuiltInType(node, builtInClassName);
        const type = isInstantiableClass(listOrSetClass)
            ? ClassType.cloneAsInstance(
                  ClassType.cloneForSpecialization(
                      listOrSetClass,
                      [inferredEntryType],
                      /* isTypeArgumentExplicit */ true,
                      /* includeSubclasses */ undefined,
                      /* TupleTypeArguments */ undefined,
                      isEmptyContainer
                  )
              )
            : UnknownType.create();

        return { type, isIncomplete, typeErrors };
    }

    verifySetEntryOrDictKeyIsHashable(entry: ExpressionNode, type: Type, isDictKey: boolean) {
        // Verify that the type is hashable.
        if (!this.isTypeHashable(type)) {
            const fileInfo = AnalyzerNodeInfo.getFileInfo(entry);
            const diag = new DiagnosticAddendum();
            diag.addMessage(Localizer.DiagnosticAddendum.unhashableType().format({ type: this.printType(type) }));

            const message = isDictKey
                ? Localizer.Diagnostic.unhashableDictKey()
                : Localizer.Diagnostic.unhashableSetEntry();

            this.addDiagnostic(
                fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                DiagnosticRule.reportGeneralTypeIssues,
                message + diag.getString(),
                entry
            );
        }
    }

    inferTypeArgFromExpectedType(expectedType: Type, entryTypes: Type[], isNarrowable: boolean): Type | undefined {
        let targetTypeVar: TypeVarType;
        let useSynthesizedTypeVar = false;

        // If the expected type is a TypeVar, use it as a target to find
        // a common (narrowest) type among the entry types.
        if (isTypeVar(expectedType)) {
            if (expectedType.details.isParamSpec || expectedType.details.isVariadic) {
                return undefined;
            }

            targetTypeVar = expectedType;
        } else {
            // Synthesize a temporary bound type var. We will attempt to assign all list
            // entries to this type var, possibly narrowing the type in the process.
            targetTypeVar = TypeVarType.createInstance('__typeArg');
            targetTypeVar.details.isSynthesized = true;
            targetTypeVar.details.boundType = this.makeTopLevelTypeVarsConcrete(expectedType);

            // Use a dummy scope ID. It needs to be a non-empty string.
            targetTypeVar.scopeId = '__typeArgScopeId';
            useSynthesizedTypeVar = true;
        }

        // First, try to assign entries with their literal values stripped.
        // The only time we don't want to strip them is if the expected
        // type explicitly includes literals.
        let typeVarContext = new TypeVarContext(targetTypeVar.scopeId);

        if (useSynthesizedTypeVar) {
            typeVarContext.setTypeVarType(targetTypeVar, isNarrowable ? undefined : expectedType, expectedType);
        }

        if (
            entryTypes.every((entryType) =>
                this.assignType(targetTypeVar, this.stripLiteralValue(entryType), /* diag */ undefined, typeVarContext)
            )
        ) {
            return applySolvedTypeVars(targetTypeVar, typeVarContext);
        }

        // Allocate a fresh typeVarContext before we try again with literals not stripped.
        typeVarContext = new TypeVarContext(targetTypeVar.scopeId);

        if (useSynthesizedTypeVar) {
            typeVarContext.setTypeVarType(
                targetTypeVar,
                isNarrowable ? undefined : expectedType,
                expectedType,
                /* retainLiteral */ true
            );
        }

        if (
            entryTypes.every((entryType) =>
                this.assignType(targetTypeVar!, entryType, /* diag */ undefined, typeVarContext)
            )
        ) {
            return applySolvedTypeVars(targetTypeVar, typeVarContext);
        }

        return undefined;
    }

    getTypeOfTernary(node: TernaryNode, flags: EvaluatorFlags, expectedType: Type | undefined): TypeResult {
        this.getTypeOfExpression(node.testExpression);

        const typesToCombine: Type[] = [];
        let isIncomplete = false;
        let typeErrors = false;

        if (this.isNodeReachable(node.ifExpression)) {
            const ifType = this.getTypeOfExpression(node.ifExpression, flags, expectedType);
            typesToCombine.push(ifType.type);
            if (ifType.isIncomplete) {
                isIncomplete = true;
            }
            if (ifType.typeErrors) {
                typeErrors = true;
            }
        }

        if (this.isNodeReachable(node.elseExpression)) {
            const elseType = this.getTypeOfExpression(node.elseExpression, flags, expectedType);
            typesToCombine.push(elseType.type);
            if (elseType.isIncomplete) {
                isIncomplete = true;
            }
            if (elseType.typeErrors) {
                typeErrors = true;
            }
        }

        return { type: combineTypes(typesToCombine), isIncomplete, typeErrors };
    }

    getTypeOfYield(node: YieldNode): TypeResult {
        let expectedYieldType: Type | undefined;
        let sentType: Type | undefined;
        let isIncomplete = false;

        const enclosingFunction = ParseTreeUtils.getEnclosingFunction(node);
        if (enclosingFunction) {
            const functionTypeInfo = this.getTypeOfFunction(enclosingFunction);
            if (functionTypeInfo) {
                const returnType = FunctionType.getSpecializedReturnType(functionTypeInfo.functionType);
                if (returnType) {
                    const generatorTypeArgs = getGeneratorTypeArgs(returnType);

                    if (generatorTypeArgs) {
                        if (generatorTypeArgs.length >= 1) {
                            expectedYieldType = generatorTypeArgs[0];
                        }

                        if (generatorTypeArgs.length >= 2) {
                            sentType = generatorTypeArgs[1];
                        }
                    }
                }
            }
        }

        if (node.expression) {
            const exprResult = this.getTypeOfExpression(node.expression, /* flags */ undefined, expectedYieldType);
            if (exprResult.isIncomplete) {
                isIncomplete = true;
            }
        }

        return { type: sentType || UnknownType.create(), isIncomplete };
    }

    getTypeOfYieldFrom(node: YieldFromNode): TypeResult {
        const yieldFromTypeResult = this.getTypeOfExpression(node.expression);
        const yieldFromType = yieldFromTypeResult.type;
        let generatorTypeArgs = getGeneratorTypeArgs(yieldFromType);

        let returnedType: Type | undefined;

        // Is the expression a Generator type?
        if (generatorTypeArgs) {
            returnedType = generatorTypeArgs.length >= 2 ? generatorTypeArgs[2] : UnknownType.create();
        } else if (isClassInstance(yieldFromType) && ClassType.isBuiltIn(yieldFromType, 'Coroutine')) {
            // Handle old-style (pre-await) Coroutines as a special case.
            returnedType = UnknownType.create();
        } else {
            const iterableType =
                this.getTypeOfIterable(yieldFromTypeResult, /* isAsync */ false, node)?.type ?? UnknownType.create();

            // Does the iterable return a Generator?
            generatorTypeArgs = getGeneratorTypeArgs(iterableType);
            if (generatorTypeArgs) {
                returnedType = generatorTypeArgs.length >= 2 ? generatorTypeArgs[2] : UnknownType.create();
            }
        }

        return { type: returnedType || UnknownType.create() };
    }

    getTypeOfLambda(node: LambdaNode, expectedType: Type | undefined): TypeResult {
        let isIncomplete = false;
        const functionType = FunctionType.createInstance('', '', '', FunctionTypeFlags.PartiallyEvaluated);
        functionType.details.typeVarScopeId = this.getScopeIdForNode(node);

        // Pre-cache the incomplete function type in case the evaluation of the
        // lambda depends on itself.
        this.writeTypeCache(node, functionType, EvaluatorFlags.None, /* isIncomplete */ true);

        let expectedFunctionTypes: FunctionType[] = [];
        if (expectedType) {
            mapSubtypes(expectedType, (subtype) => {
                if (isFunction(subtype)) {
                    expectedFunctionTypes.push(subtype);
                }

                if (isClassInstance(subtype)) {
                    const boundMethod = this.getBoundMethod(subtype, '__call__');
                    if (boundMethod && isFunction(boundMethod)) {
                        expectedFunctionTypes.push(boundMethod as FunctionType);
                    }
                }

                return undefined;
            });

            // Determine the minimum number of parameters that are required to
            // satisfy the lambda.
            const minLambdaParamCount = node.parameters.filter(
                (param) => param.category === ParameterCategory.Simple && param.defaultValue === undefined
            ).length;
            const maxLambdaParamCount = node.parameters.filter(
                (param) => param.category === ParameterCategory.Simple
            ).length;

            // Remove any expected subtypes that don't satisfy the minimum
            // parameter count requirement.
            expectedFunctionTypes = expectedFunctionTypes.filter((functionType) => {
                const functionParamCount = functionType.details.parameters.filter(
                    (param) => !!param.name && !param.hasDefault
                ).length;
                const hasVarArgs = functionType.details.parameters.some(
                    (param) => !!param.name && param.category !== ParameterCategory.Simple
                );
                return (
                    hasVarArgs ||
                    (functionParamCount >= minLambdaParamCount && functionParamCount <= maxLambdaParamCount)
                );
            });
        }

        // For now, use only the first expected type.
        const expectedFunctionType = expectedFunctionTypes.length > 0 ? expectedFunctionTypes[0] : undefined;
        let paramsArePositionOnly = true;

        node.parameters.forEach((param, index) => {
            let paramType: Type = UnknownType.create();
            if (expectedFunctionType && index < expectedFunctionType.details.parameters.length) {
                paramType = FunctionType.getEffectiveParameterType(expectedFunctionType, index);
            }

            if (param.name) {
                this.writeTypeCache(
                    param.name,
                    this.transformVariadicParamType(node, param.category, paramType),
                    EvaluatorFlags.None,
                    /* isIncomplete */ false
                );
            }

            if (param.defaultValue) {
                // Evaluate the default value if it's present.
                this.getTypeOfExpression(param.defaultValue, EvaluatorFlags.ConvertEllipsisToAny);
            }

            // Determine whether we need to insert an implied position-only parameter.
            // This is needed when a function's parameters are named using the old-style
            // way of specifying position-only parameters.
            if (index >= 0) {
                let isImplicitPositionOnlyParam = false;

                if (param.category === ParameterCategory.Simple && param.name) {
                    if (isPrivateName(param.name.value)) {
                        isImplicitPositionOnlyParam = true;
                    }
                } else {
                    paramsArePositionOnly = false;
                }

                if (
                    paramsArePositionOnly &&
                    !isImplicitPositionOnlyParam &&
                    functionType.details.parameters.length > 0
                ) {
                    // Insert an implicit "position-only parameter" separator.
                    FunctionType.addParameter(functionType, {
                        category: ParameterCategory.Simple,
                        type: UnknownType.create(),
                    });
                }

                if (!isImplicitPositionOnlyParam) {
                    paramsArePositionOnly = false;
                }
            }

            const functionParam: FunctionParameter = {
                category: param.category,
                name: param.name ? param.name.value : undefined,
                hasDefault: !!param.defaultValue,
                defaultValueExpression: param.defaultValue,
                hasDeclaredType: true,
                type: paramType,
            };
            FunctionType.addParameter(functionType, functionParam);
        });

        if (paramsArePositionOnly && functionType.details.parameters.length > 0) {
            // Insert an implicit "position-only parameter" separator.
            FunctionType.addParameter(functionType, {
                category: ParameterCategory.Simple,
                type: UnknownType.create(),
            });
        }

        const expectedReturnType = expectedFunctionType
            ? this.getFunctionEffectiveReturnType(expectedFunctionType)
            : undefined;

        // If we're speculatively evaluating the lambda, create another speculative
        // evaluation scope for the return expression and do not allow retention
        // of the cached types.
        const inferLambdaReturnType = () => {
            const returnTypeResult = this.getTypeOfExpression(
                node.expression,
                /* flags */ undefined,
                expectedReturnType
            );
            functionType.inferredReturnType = returnTypeResult.type;
            if (returnTypeResult.isIncomplete) {
                isIncomplete = true;
            }
        };

        if (this._speculativeTypeTracker.isSpeculative(node)) {
            this.useSpeculativeMode(
                node.expression,
                () => {
                    inferLambdaReturnType();
                },
                /* allowCacheRetention */ false
            );
        } else {
            inferLambdaReturnType();
        }

        // Mark the function type as no longer being evaluated.
        functionType.details.flags &= ~FunctionTypeFlags.PartiallyEvaluated;

        return { type: functionType, isIncomplete };
    }

    getTypeOfListComprehension(node: ListComprehensionNode, expectedType?: Type): TypeResult {
        let isIncomplete = false;
        let typeErrors = false;

        let isAsync = node.forIfNodes.some((comp) => {
            return (
                (comp.nodeType === ParseNodeType.ListComprehensionFor && comp.isAsync) ||
                (comp.nodeType === ParseNodeType.ListComprehensionIf &&
                    comp.testExpression.nodeType === ParseNodeType.Await)
            );
        });
        let type: Type = UnknownType.create();

        if (node.expression.nodeType === ParseNodeType.Await) {
            isAsync = true;
        }

        let expectedElementType: Type | undefined;
        if (expectedType) {
            expectedElementType = this.getTypeOfIterator(
                { type: expectedType },
                isAsync,
                /* errorNode */ undefined
            )?.type;
        }

        const elementTypeResult = this.getElementTypeFromListComprehension(node, expectedElementType);
        if (elementTypeResult.isIncomplete) {
            isIncomplete = true;
        }
        if (elementTypeResult.typeErrors) {
            typeErrors = true;
        }
        const elementType = elementTypeResult.type;

        // Handle the special case where a generator function (e.g. `(await x for x in y)`)
        // is expected to be an AsyncGenerator.
        if (
            !isAsync &&
            expectedType &&
            isClassInstance(expectedType) &&
            ClassType.isBuiltIn(expectedType, 'AsyncGenerator')
        ) {
            isAsync = true;
        }
        const builtInIteratorType = this.getTypingType(node, isAsync ? 'AsyncGenerator' : 'Generator');

        if (builtInIteratorType && isInstantiableClass(builtInIteratorType)) {
            type = ClassType.cloneAsInstance(
                ClassType.cloneForSpecialization(
                    builtInIteratorType,
                    isAsync
                        ? [elementType, NoneType.createInstance()]
                        : [elementType, NoneType.createInstance(), NoneType.createInstance()],
                    /* isTypeArgumentExplicit */ true
                )
            );
        }

        return { type, isIncomplete, typeErrors };
    }

    reportPossibleUnknownAssignment(
        diagLevel: DiagnosticLevel,
        rule: string,
        target: NameNode,
        type: Type,
        errorNode: ExpressionNode,
        ignoreEmptyContainers: boolean
    ) {
        // Don't bother if the feature is disabled.
        if (diagLevel === 'none') {
            return;
        }

        const nameValue = target.value;

        // Sometimes variables contain an "unbound" type if they're
        // assigned only within conditional statements. Remove this
        // to avoid confusion.
        const simplifiedType = removeUnbound(type);

        if (isUnknown(simplifiedType)) {
            this.addDiagnostic(
                diagLevel,
                rule,
                Localizer.Diagnostic.typeUnknown().format({ name: nameValue }),
                errorNode
            );
        } else if (isPartlyUnknown(simplifiedType)) {
            // If ignoreEmptyContainers is true, don't report the problem for
            // empty containers (lists or dictionaries). We'll report the problem
            // only if the assigned value is used later.
            if (!ignoreEmptyContainers || !isClassInstance(type) || !type.isEmptyContainer) {
                const diagAddendum = new DiagnosticAddendum();
                diagAddendum.addMessage(
                    Localizer.DiagnosticAddendum.typeOfSymbol().format({
                        name: nameValue,
                        type: this.printType(simplifiedType, { expandTypeAlias: true }),
                    })
                );
                this.addDiagnostic(
                    diagLevel,
                    rule,
                    Localizer.Diagnostic.typePartiallyUnknown().format({ name: nameValue }) + diagAddendum.getString(),
                    errorNode
                );
            }
        }
    }

    evaluateListComprehensionForIf(node: ListComprehensionForIfNode) {
        let isIncomplete = false;

        if (node.nodeType === ParseNodeType.ListComprehensionFor) {
            const iterableTypeResult = this.getTypeOfExpression(node.iterableExpression);
            if (iterableTypeResult.isIncomplete) {
                isIncomplete = true;
            }
            const iterableType = this.stripLiteralValue(iterableTypeResult.type);
            const itemTypeResult = this.getTypeOfIterator(
                { type: iterableType, isIncomplete: iterableTypeResult.isIncomplete },
                !!node.isAsync,
                node.iterableExpression
            ) ?? { type: UnknownType.create(), isIncomplete: iterableTypeResult.isIncomplete };

            const targetExpr = node.targetExpression;
            this.assignTypeToExpression(
                targetExpr,
                itemTypeResult.type,
                !!itemTypeResult.isIncomplete,
                node.iterableExpression
            );
        } else {
            assert(node.nodeType === ParseNodeType.ListComprehensionIf);

            // Evaluate the test expression to validate it and mark symbols
            // as referenced. Don't bother doing this if we're in speculative
            // mode because it doesn't affect the element type.
            if (!this._speculativeTypeTracker.isSpeculative(node.testExpression)) {
                this.getTypeOfExpression(node.testExpression);
            }
        }

        return isIncomplete;
    }

    // Returns the type of one entry returned by the list comprehension,
    // as opposed to the entire list.
    getElementTypeFromListComprehension(
        node: ListComprehensionNode,
        expectedValueOrElementType?: Type,
        expectedKeyType?: Type
    ): TypeResult {
        let isIncomplete = false;
        let typeErrors = false;

        // "Execute" the list comprehensions from start to finish.
        for (const forIfNode of node.forIfNodes) {
            if (this.evaluateListComprehensionForIf(forIfNode)) {
                isIncomplete = true;
            }
        }

        let type: Type = UnknownType.create();
        if (node.expression.nodeType === ParseNodeType.DictionaryKeyEntry) {
            // Create a tuple with the key/value types.
            const keyTypeResult = this.getTypeOfExpression(
                node.expression.keyExpression,
                /* flags */ undefined,
                expectedKeyType
            );
            if (keyTypeResult.isIncomplete) {
                isIncomplete = true;
            }
            if (keyTypeResult.typeErrors) {
                typeErrors = true;
            }
            let keyType = keyTypeResult.type;
            if (!expectedKeyType || !containsLiteralType(expectedKeyType)) {
                keyType = this.stripLiteralValue(keyType);
            }

            const valueTypeResult = this.getTypeOfExpression(
                node.expression.valueExpression,
                /* flags */ undefined,
                expectedValueOrElementType
            );
            if (valueTypeResult.isIncomplete) {
                isIncomplete = true;
            }
            if (valueTypeResult.typeErrors) {
                typeErrors = true;
            }
            let valueType = valueTypeResult.type;
            if (!expectedValueOrElementType || !containsLiteralType(expectedValueOrElementType)) {
                valueType = this.stripLiteralValue(valueType);
            }

            type = this.makeTupleObject([keyType, valueType]);
        } else if (node.expression.nodeType === ParseNodeType.DictionaryExpandEntry) {
            // The parser should have reported an error in this case because it's not allowed.
            this.getTypeOfExpression(
                node.expression.expandExpression,
                /* flags */ undefined,
                expectedValueOrElementType
            );
        } else if (isExpressionNode(node)) {
            const exprTypeResult = this.getTypeOfExpression(
                node.expression as ExpressionNode,
                /* flags */ undefined,
                expectedValueOrElementType
            );
            if (exprTypeResult.isIncomplete) {
                isIncomplete = true;
            }
            if (exprTypeResult.typeErrors) {
                typeErrors = true;
            }
            type = exprTypeResult.type;
        }

        return { type, isIncomplete, typeErrors };
    }

    getTypeOfSlice(node: SliceNode): TypeResult {
        // Evaluate the expressions to report errors and record symbol
        // references. We can skip this if we're executing speculatively.
        if (!this._speculativeTypeTracker.isSpeculative(node)) {
            if (node.startValue) {
                this.getTypeOfExpression(node.startValue);
            }

            if (node.endValue) {
                this.getTypeOfExpression(node.endValue);
            }

            if (node.stepValue) {
                this.getTypeOfExpression(node.stepValue);
            }
        }

        return { type: this.getBuiltInObject(node, 'slice') };
    }

    // Verifies that a type argument's type is not disallowed.
    validateTypeArg(argResult: TypeResultWithNode, options?: ValidateTypeArgsOptions): boolean {
        if (argResult.typeList) {
            if (!options?.allowTypeArgList) {
                this.addError(Localizer.Diagnostic.typeArgListNotAllowed(), argResult.node);
                return false;
            } else {
                argResult.typeList!.forEach((typeArg) => {
                    this.validateTypeArg(typeArg);
                });
            }
        }

        if (isEllipsisType(argResult.type)) {
            if (!options?.allowTypeArgList) {
                this.addError(Localizer.Diagnostic.ellipsisContext(), argResult.node);
                return false;
            }
        }

        if (isModule(argResult.type)) {
            this.addError(Localizer.Diagnostic.moduleAsType(), argResult.node);
            return false;
        }

        if (isParamSpec(argResult.type)) {
            if (!options?.allowParamSpec) {
                this.addError(Localizer.Diagnostic.paramSpecContext(), argResult.node);
                return false;
            }
        }

        if (isVariadicTypeVar(argResult.type) && !argResult.type.isVariadicInUnion) {
            if (!options?.allowVariadicTypeVar) {
                this.addError(Localizer.Diagnostic.typeVarTupleContext(), argResult.node);
                return false;
            } else {
                this.validateVariadicTypeVarIsUnpacked(argResult.type, argResult.node);
            }
        }

        if (!options?.allowEmptyTuple && argResult.isEmptyTupleShorthand) {
            this.addError(Localizer.Diagnostic.zeroLengthTupleNotAllowed(), argResult.node);
            return false;
        }

        if (isUnpackedClass(argResult.type)) {
            if (!options?.allowUnpackedTuples) {
                this.addError(Localizer.Diagnostic.unpackedArgInTypeArgument(), argResult.node);
                return false;
            }
        }

        return true;
    }

    // Converts the type parameters for a Callable type. It should
    // have zero to two parameters. The first parameter, if present, should be
    // either an ellipsis or a list of parameter types. The second parameter, if
    // present, should specify the return type.
    createCallableType(typeArgs: TypeResultWithNode[] | undefined, errorNode: ParseNode): FunctionType {
        // Create a new function that is marked as "static" so there is later
        // no attempt to bind it as though it's an instance or class method.
        const functionType = FunctionType.createInstantiable(FunctionTypeFlags.None);
        TypeBase.setSpecialForm(functionType);
        functionType.details.declaredReturnType = UnknownType.create();
        functionType.details.typeVarScopeId = this.getScopeIdForNode(errorNode);

        if (typeArgs && typeArgs.length > 0) {
            if (typeArgs[0].typeList) {
                const typeList = typeArgs[0].typeList;
                let sawUnpacked = false;
                let reportedUnpackedError = false;
                const noteSawUnpacked = (entry: TypeResultWithNode) => {
                    // Make sure we have at most one unpacked variadic type variable.
                    if (sawUnpacked) {
                        if (!reportedUnpackedError) {
                            this.addError(Localizer.Diagnostic.variadicTypeArgsTooMany(), entry.node);
                            reportedUnpackedError = true;
                        }
                    }
                    sawUnpacked = true;
                };

                typeList.forEach((entry, index) => {
                    let entryType = entry.type;
                    let paramCategory: ParameterCategory = ParameterCategory.Simple;
                    const paramName = `__p${index.toString()}`;

                    if (isVariadicTypeVar(entryType)) {
                        this.validateVariadicTypeVarIsUnpacked(entryType, entry.node);
                        paramCategory = ParameterCategory.VarArgList;
                        noteSawUnpacked(entry);
                    } else if (this.validateTypeArg(entry, { allowUnpackedTuples: true })) {
                        if (isUnpackedClass(entryType)) {
                            paramCategory = ParameterCategory.VarArgList;
                            noteSawUnpacked(entry);
                        }
                    } else {
                        entryType = UnknownType.create();
                    }

                    FunctionType.addParameter(functionType, {
                        category: paramCategory,
                        name: paramName,
                        isNameSynthesized: true,
                        type: convertToInstance(entryType),
                        hasDeclaredType: true,
                    });
                });

                FunctionType.addParameter(functionType, {
                    category: ParameterCategory.Simple,
                    isNameSynthesized: false,
                    type: UnknownType.create(),
                });
            } else if (isEllipsisType(typeArgs[0].type)) {
                FunctionType.addDefaultParameters(functionType);
                functionType.details.flags |= FunctionTypeFlags.SkipArgsKwargsCompatibilityCheck;
            } else if (isParamSpec(typeArgs[0].type)) {
                functionType.details.paramSpec = typeArgs[0].type;
            } else {
                if (isInstantiableClass(typeArgs[0].type) && ClassType.isBuiltIn(typeArgs[0].type, 'Concatenate')) {
                    const concatTypeArgs = typeArgs[0].type.typeArguments;
                    if (concatTypeArgs && concatTypeArgs.length > 0) {
                        concatTypeArgs.forEach((typeArg, index) => {
                            if (index === concatTypeArgs.length - 1) {
                                // Add a position-only separator
                                FunctionType.addParameter(functionType, {
                                    category: ParameterCategory.Simple,
                                    isNameSynthesized: false,
                                    type: UnknownType.create(),
                                });

                                if (isParamSpec(typeArg)) {
                                    functionType.details.paramSpec = typeArg;
                                }
                            } else {
                                FunctionType.addParameter(functionType, {
                                    category: ParameterCategory.Simple,
                                    name: `__p${index}`,
                                    isNameSynthesized: true,
                                    hasDeclaredType: true,
                                    type: typeArg,
                                });
                            }
                        });
                    }
                } else {
                    this.addError(Localizer.Diagnostic.callableFirstArg(), typeArgs[0].node);
                }
            }

            if (typeArgs.length > 1) {
                let typeArg1Type = typeArgs[1].type;
                if (!this.validateTypeArg(typeArgs[1])) {
                    typeArg1Type = UnknownType.create();
                }
                functionType.details.declaredReturnType = convertToInstance(typeArg1Type);
            } else {
                const fileInfo = AnalyzerNodeInfo.getFileInfo(errorNode);
                this.addDiagnostic(
                    fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                    DiagnosticRule.reportGeneralTypeIssues,
                    Localizer.Diagnostic.callableSecondArg(),
                    errorNode
                );

                functionType.details.declaredReturnType = UnknownType.create();
            }

            if (typeArgs.length > 2) {
                this.addError(Localizer.Diagnostic.callableExtraArgs(), typeArgs[2].node);
            }
        } else {
            FunctionType.addDefaultParameters(functionType, /* useUnknown */ true);
            functionType.details.flags |= FunctionTypeFlags.SkipArgsKwargsCompatibilityCheck;
        }

        return functionType;
    }

    // Creates an Optional[X] type.
    createOptionalType(
        classType: ClassType,
        errorNode: ParseNode,
        typeArgs: TypeResultWithNode[] | undefined,
        flags: EvaluatorFlags
    ): Type {
        if (!typeArgs) {
            // If no type arguments are provided, the resulting type
            // depends on whether we're evaluating a type annotation or
            // we're in some other context.
            if ((flags & EvaluatorFlags.ExpectingTypeAnnotation) !== 0) {
                this.addError(Localizer.Diagnostic.optionalExtraArgs(), errorNode);
                return UnknownType.create();
            }

            return classType;
        }

        if (typeArgs.length > 1) {
            this.addError(Localizer.Diagnostic.optionalExtraArgs(), errorNode);
            return UnknownType.create();
        }

        let typeArg0Type = typeArgs[0].type;
        if (!this.validateTypeArg(typeArgs[0])) {
            typeArg0Type = UnknownType.create();
        } else if (!TypeBase.isInstantiable(typeArg0Type)) {
            this.addExpectedClassDiagnostic(typeArg0Type, typeArgs[0].node);
            typeArg0Type = UnknownType.create();
        }

        const optionalType = combineTypes([typeArg0Type, NoneType.createType()]);

        if (isUnion(optionalType)) {
            TypeBase.setSpecialForm(optionalType);
        }

        return optionalType;
    }

    cloneBuiltinObjectWithLiteral(node: ParseNode, builtInName: string, value: LiteralValue): Type {
        const type = this.getBuiltInObject(node, builtInName);
        if (isClassInstance(type)) {
            return ClassType.cloneWithLiteral(type, value);
        }

        return UnknownType.create();
    }

    cloneBuiltinClassWithLiteral(node: ParseNode, builtInName: string, value: LiteralValue): Type {
        const type = this.getBuiltInType(node, builtInName);
        if (isInstantiableClass(type)) {
            return ClassType.cloneWithLiteral(type, value);
        }

        return UnknownType.create();
    }

    // Creates a type that represents a Literal.
    createLiteralType(node: IndexNode, flags: EvaluatorFlags): Type {
        if (node.items.length === 0) {
            this.addError(Localizer.Diagnostic.literalEmptyArgs(), node.baseExpression);
            return UnknownType.create();
        }

        // As per the specification, we support None, int, bool, str, bytes literals
        // plus enum values.
        const literalTypes: Type[] = [];

        for (const item of node.items) {
            let type: Type | undefined;
            const itemExpr = item.valueExpression;

            if (item.argumentCategory !== ArgumentCategory.Simple) {
                this.addError(Localizer.Diagnostic.unpackedArgInTypeArgument(), itemExpr);
                type = UnknownType.create();
            } else if (item.name) {
                this.addError(Localizer.Diagnostic.keywordArgInTypeArgument(), itemExpr);
                type = UnknownType.create();
            } else if (itemExpr.nodeType === ParseNodeType.StringList) {
                const isBytes = (itemExpr.strings[0].token.flags & StringTokenFlags.Bytes) !== 0;
                const value = itemExpr.strings.map((s) => s.value).join('');
                if (isBytes) {
                    type = this.cloneBuiltinClassWithLiteral(node, 'bytes', value);
                } else {
                    type = this.cloneBuiltinClassWithLiteral(node, 'str', value);
                }
            } else if (itemExpr.nodeType === ParseNodeType.Number) {
                if (!itemExpr.isImaginary && itemExpr.isInteger) {
                    type = this.cloneBuiltinClassWithLiteral(node, 'int', itemExpr.value);
                }
            } else if (itemExpr.nodeType === ParseNodeType.Constant) {
                if (itemExpr.constType === KeywordType.True) {
                    type = this.cloneBuiltinClassWithLiteral(node, 'bool', true);
                } else if (itemExpr.constType === KeywordType.False) {
                    type = this.cloneBuiltinClassWithLiteral(node, 'bool', false);
                } else if (itemExpr.constType === KeywordType.None) {
                    type = NoneType.createType();
                }
            } else if (
                itemExpr.nodeType === ParseNodeType.UnaryOperation &&
                itemExpr.operator === OperatorType.Subtract
            ) {
                if (itemExpr.expression.nodeType === ParseNodeType.Number) {
                    if (!itemExpr.expression.isImaginary && itemExpr.expression.isInteger) {
                        type = this.cloneBuiltinClassWithLiteral(node, 'int', -itemExpr.expression.value);
                    }
                }
            }

            if (!type) {
                const exprType = this.getTypeOfExpression(itemExpr);

                // Is this an enum type?
                if (
                    isClassInstance(exprType.type) &&
                    ClassType.isEnumClass(exprType.type) &&
                    exprType.type.literalValue !== undefined
                ) {
                    type = ClassType.cloneAsInstantiable(exprType.type);
                } else {
                    // Is this a type alias to an existing literal type?
                    let isLiteralType = true;

                    doForEachSubtype(exprType.type, (subtype) => {
                        if (!isInstantiableClass(subtype) || subtype.literalValue === undefined) {
                            isLiteralType = false;
                        }
                    });

                    if (isLiteralType) {
                        type = exprType.type;
                    }
                }
            }

            if (!type) {
                this.addError(Localizer.Diagnostic.literalUnsupportedType(), item);
                type = UnknownType.create();
            }

            literalTypes.push(type);
        }

        return combineTypes(literalTypes);
    }

    // Creates a ClassVar type.
    createClassVarType(
        classType: ClassType,
        errorNode: ParseNode,
        typeArgs: TypeResultWithNode[] | undefined,
        flags: EvaluatorFlags
    ): Type {
        if (flags & EvaluatorFlags.ClassVarDisallowed) {
            this.addError(Localizer.Diagnostic.classVarNotAllowed(), errorNode);
            return AnyType.create();
        }

        if (!typeArgs) {
            return classType;
        } else if (typeArgs.length === 0) {
            this.addError(Localizer.Diagnostic.classVarFirstArgMissing(), errorNode);
            return UnknownType.create();
        } else if (typeArgs.length > 1) {
            this.addError(Localizer.Diagnostic.classVarTooManyArgs(), typeArgs[1].node);
            return UnknownType.create();
        }

        const type = typeArgs[0].type;

        // A ClassVar should not allow TypeVars or generic types parameterized
        // by TypeVars.
        if (requiresSpecialization(type, /* ignorePseudoGeneric */ true, /* ignoreSelf */ true)) {
            const fileInfo = AnalyzerNodeInfo.getFileInfo(errorNode);

            this.addDiagnostic(
                fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                DiagnosticRule.reportGeneralTypeIssues,
                Localizer.Diagnostic.classVarWithTypeVar(),
                typeArgs[0].node ?? errorNode
            );
        }

        return type;
    }

    // Creates a "TypeGuard" type. This is an alias for 'bool', which
    // isn't a generic type and therefore doesn't have a typeParameter.
    // We'll abuse our internal types a bit by specializing it with
    // a type argument anyway.
    createTypeGuardType(
        errorNode: ParseNode,
        classType: ClassType,
        typeArgs: TypeResultWithNode[] | undefined,
        flags: EvaluatorFlags
    ): Type {
        // If no type arguments are provided, the resulting type
        // depends on whether we're evaluating a type annotation or
        // we're in some other context.
        if (!typeArgs) {
            if ((flags & EvaluatorFlags.ExpectingTypeAnnotation) !== 0) {
                this.addError(Localizer.Diagnostic.typeGuardArgCount(), errorNode);
            }

            return classType;
        } else if (typeArgs.length !== 1) {
            this.addError(Localizer.Diagnostic.typeGuardArgCount(), errorNode);
            return UnknownType.create();
        }

        const convertedTypeArgs = typeArgs.map((typeArg) => {
            return convertToInstance(this.validateTypeArg(typeArg) ? typeArg.type : UnknownType.create());
        });

        return ClassType.cloneForSpecialization(classType, convertedTypeArgs, /* isTypeArgumentExplicit */ true);
    }

    createSelfType(classType: ClassType, errorNode: ParseNode, typeArgs: TypeResultWithNode[] | undefined) {
        const fileInfo = AnalyzerNodeInfo.getFileInfo(errorNode);

        // Self doesn't support any type arguments.
        if (typeArgs) {
            this.addDiagnostic(
                fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                DiagnosticRule.reportGeneralTypeIssues,
                Localizer.Diagnostic.typeArgsExpectingNone().format({
                    name: classType.details.name,
                }),
                typeArgs[0].node ?? errorNode
            );
        }

        const enclosingClass = ParseTreeUtils.getEnclosingClass(errorNode);
        const enclosingClassTypeResult = enclosingClass ? this.getTypeOfClass(enclosingClass) : undefined;
        if (!enclosingClassTypeResult) {
            this.addDiagnostic(
                fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                DiagnosticRule.reportGeneralTypeIssues,
                Localizer.Diagnostic.selfTypeContext(),
                errorNode
            );

            return UnknownType.create();
        }

        const enclosingFunction = ParseTreeUtils.getEnclosingFunction(errorNode);
        if (enclosingFunction) {
            const functionFlags = this.getFunctionFlagsFromDecorators(enclosingFunction, /* isInClass */ true);

            const isInnerFunction = !!ParseTreeUtils.getEnclosingFunction(enclosingFunction);
            if (!isInnerFunction) {
                // Check for static methods.
                if (functionFlags & FunctionTypeFlags.StaticMethod) {
                    this.addDiagnostic(
                        fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                        DiagnosticRule.reportGeneralTypeIssues,
                        Localizer.Diagnostic.selfTypeContext(),
                        errorNode
                    );

                    return UnknownType.create();
                }

                if (enclosingFunction.parameters.length > 0) {
                    const firstParamTypeAnnotation = ParseTreeUtils.getTypeAnnotationForParameter(enclosingFunction, 0);
                    if (
                        firstParamTypeAnnotation &&
                        !ParseTreeUtils.isNodeContainedWithin(errorNode, firstParamTypeAnnotation)
                    ) {
                        const annotationType = this.getTypeOfAnnotation(firstParamTypeAnnotation, {
                            associateTypeVarsWithScope: true,
                            disallowRecursiveTypeAlias: true,
                        });
                        if (!isTypeVar(annotationType) || !annotationType.details.isSynthesizedSelf) {
                            this.addDiagnostic(
                                fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                                DiagnosticRule.reportGeneralTypeIssues,
                                Localizer.Diagnostic.selfTypeWithTypedSelfOrCls(),
                                errorNode
                            );
                        }
                    }
                }
            }
        }

        return synthesizeTypeVarForSelfCls(enclosingClassTypeResult.classType, /* isClsParam */ true);
    }

    createRequiredType(
        classType: ClassType,
        errorNode: ParseNode,
        isRequired: boolean,
        typeArgs: TypeResultWithNode[] | undefined,
        flags: EvaluatorFlags
    ): Type {
        // If no type arguments are provided, the resulting type
        // depends on whether we're evaluating a type annotation or
        // we're in some other context.
        if (!typeArgs && (flags & EvaluatorFlags.ExpectingTypeAnnotation) === 0) {
            return classType;
        }

        if (!typeArgs || typeArgs.length !== 1) {
            this.addError(
                isRequired ? Localizer.Diagnostic.requiredArgCount() : Localizer.Diagnostic.notRequiredArgCount(),
                errorNode
            );
            return classType;
        }

        const typeArgType = typeArgs[0].type;

        // Make sure this is used only in a dataclass.
        const containingClassNode = ParseTreeUtils.getEnclosingClass(errorNode, /* stopAtFunction */ true);
        const classTypeInfo = containingClassNode ? this.getTypeOfClass(containingClassNode) : undefined;

        let isUsageLegal = false;

        if (
            classTypeInfo &&
            isInstantiableClass(classTypeInfo.classType) &&
            ClassType.isTypedDictClass(classTypeInfo.classType)
        ) {
            // The only legal usage is when used in a type annotation statement.
            if (
                errorNode.parent?.nodeType === ParseNodeType.TypeAnnotation &&
                errorNode.parent.typeAnnotation === errorNode
            ) {
                isUsageLegal = true;
            }
        }

        if ((flags & EvaluatorFlags.RequiredAllowed) !== 0) {
            isUsageLegal = true;
        }

        if (!isUsageLegal) {
            this.addError(
                isRequired
                    ? Localizer.Diagnostic.requiredNotInTypedDict()
                    : Localizer.Diagnostic.notRequiredNotInTypedDict(),
                errorNode
            );
            return ClassType.cloneForSpecialization(classType, [convertToInstance(typeArgType)], !!typeArgs);
        }

        return typeArgType;
    }

    createUnpackType(
        classType: ClassType,
        errorNode: ParseNode,
        typeArgs: TypeResultWithNode[] | undefined,
        flags: EvaluatorFlags
    ): Type {
        // If no type arguments are provided, the resulting type
        // depends on whether we're evaluating a type annotation or
        // we're in some other context.
        if (!typeArgs && (flags & EvaluatorFlags.ExpectingTypeAnnotation) === 0) {
            return classType;
        }

        if (!typeArgs || typeArgs.length !== 1) {
            this.addError(Localizer.Diagnostic.unpackArgCount(), errorNode);
            return UnknownType.create();
        }

        let typeArgType = typeArgs[0].type;
        if (isUnion(typeArgType) && typeArgType.subtypes.length === 1) {
            typeArgType = typeArgType.subtypes[0];
        }

        const fileInfo = AnalyzerNodeInfo.getFileInfo(errorNode);

        if ((flags & EvaluatorFlags.AllowUnpackedTupleOrTypeVarTuple) !== 0) {
            if (isInstantiableClass(typeArgType) && !typeArgType.includeSubclasses && isTupleClass(typeArgType)) {
                return ClassType.cloneForUnpacked(typeArgType);
            }

            if (isVariadicTypeVar(typeArgType) && !typeArgType.isVariadicUnpacked) {
                return TypeVarType.cloneForUnpacked(typeArgType);
            }

            this.addDiagnostic(
                fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                DiagnosticRule.reportGeneralTypeIssues,
                Localizer.Diagnostic.unpackExpectedTypeVarTuple(),
                errorNode
            );
            return UnknownType.create();
        }

        if ((flags & EvaluatorFlags.AllowUnpackedTypedDict) !== 0) {
            if (isInstantiableClass(typeArgType) && ClassType.isTypedDictClass(typeArgType)) {
                return ClassType.cloneForUnpacked(typeArgType);
            }

            this.addDiagnostic(
                fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                DiagnosticRule.reportGeneralTypeIssues,
                Localizer.Diagnostic.unpackExpectedTypedDict(),
                errorNode
            );
            return UnknownType.create();
        }

        this.addDiagnostic(
            fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
            DiagnosticRule.reportGeneralTypeIssues,
            Localizer.Diagnostic.unpackNotAllowed(),
            errorNode
        );
        return UnknownType.create();
    }

    // Creates a "Final" type.
    createFinalType(
        classType: ClassType,
        errorNode: ParseNode,
        typeArgs: TypeResultWithNode[] | undefined,
        flags: EvaluatorFlags
    ): Type {
        if (flags & EvaluatorFlags.FinalDisallowed) {
            this.addError(Localizer.Diagnostic.finalContext(), errorNode);
            return AnyType.create();
        }

        if (!typeArgs || typeArgs.length === 0) {
            return classType;
        }

        if (typeArgs.length > 1) {
            this.addError(Localizer.Diagnostic.finalTooManyArgs(), errorNode);
        }

        return typeArgs[0].type;
    }

    createConcatenateType(
        errorNode: ParseNode,
        classType: ClassType,
        typeArgs: TypeResultWithNode[] | undefined
    ): Type {
        if (!typeArgs || typeArgs.length === 0) {
            this.addError(Localizer.Diagnostic.concatenateTypeArgsMissing(), errorNode);
        } else {
            typeArgs.forEach((typeArg, index) => {
                if (index === typeArgs.length - 1) {
                    if (!isParamSpec(typeArg.type)) {
                        this.addError(Localizer.Diagnostic.concatenateParamSpecMissing(), typeArg.node);
                    }
                } else {
                    if (isParamSpec(typeArg.type)) {
                        this.addError(Localizer.Diagnostic.paramSpecContext(), typeArg.node);
                    }
                }
            });
        }

        return this.createSpecialType(classType, typeArgs, /* paramLimit */ undefined, /* allowParamSpec */ true);
    }

    createAnnotatedType(errorNode: ParseNode, typeArgs: TypeResultWithNode[] | undefined): Type {
        if (typeArgs && typeArgs.length < 2) {
            this.addError(Localizer.Diagnostic.annotatedTypeArgMissing(), errorNode);
        }

        if (!typeArgs || typeArgs.length === 0) {
            return AnyType.create();
        }

        return TypeBase.cloneForAnnotated(typeArgs[0].type);
    }

    // Creates one of several "special" types that are defined in typing.pyi
    // but not declared in their entirety. This includes the likes of "Tuple",
    // "Dict", etc.
    createSpecialType(
        classType: ClassType,
        typeArgs: TypeResultWithNode[] | undefined,
        paramLimit?: number,
        allowParamSpec = false,
        isCallable = false
    ): Type {
        const isTupleTypeParam = ClassType.isTupleClass(classType);

        if (typeArgs) {
            if (isTupleTypeParam && typeArgs.length === 1 && typeArgs[0].isEmptyTupleShorthand) {
                typeArgs = [];
            } else {
                let sawUnpacked = false;
                const noteSawUnpacked = (typeArg: TypeResultWithNode) => {
                    if (sawUnpacked) {
                        if (!reportedUnpackedError) {
                            this.addError(Localizer.Diagnostic.variadicTypeArgsTooMany(), typeArg.node);
                            reportedUnpackedError = true;
                        }
                    }
                    sawUnpacked = true;
                };
                let reportedUnpackedError = false;

                // Verify that we didn't receive any inappropriate types.
                typeArgs.forEach((typeArg, index) => {
                    if (isEllipsisType(typeArg.type)) {
                        if (!isTupleTypeParam) {
                            this.addError(Localizer.Diagnostic.ellipsisContext(), typeArg.node);
                        } else if (typeArgs!.length !== 2 || index !== 1) {
                            this.addError(Localizer.Diagnostic.ellipsisSecondArg(), typeArg.node);
                        } else {
                            if (
                                isTypeVar(typeArgs![0].type) &&
                                isVariadicTypeVar(typeArgs![0].type) &&
                                !typeArgs![0].type.isVariadicInUnion
                            ) {
                                this.addError(Localizer.Diagnostic.typeVarTupleContext(), typeArgs![0].node);
                            }
                        }
                    } else if (isParamSpec(typeArg.type) && allowParamSpec) {
                        // Nothing to do - this is allowed.
                    } else if (isVariadicTypeVar(typeArg.type) && paramLimit === undefined) {
                        noteSawUnpacked(typeArg);
                        this.validateVariadicTypeVarIsUnpacked(typeArg.type, typeArg.node);
                    } else if (paramLimit === undefined && isUnpacked(typeArg.type)) {
                        noteSawUnpacked(typeArg);
                        this.validateTypeArg(typeArg, { allowUnpackedTuples: true });
                    } else {
                        this.validateTypeArg(typeArg);
                    }
                });
            }
        }

        let typeArgTypes = typeArgs ? typeArgs.map((t) => convertToInstance(t.type)) : [];

        // Make sure the argument list count is correct.
        if (paramLimit !== undefined) {
            if (typeArgs && typeArgTypes.length > paramLimit) {
                this.addError(
                    Localizer.Diagnostic.typeArgsTooMany().format({
                        name: classType.aliasName || classType.details.name,
                        expected: paramLimit,
                        received: typeArgTypes.length,
                    }),
                    typeArgs[paramLimit].node
                );
                typeArgTypes = typeArgTypes.slice(0, paramLimit);
            } else if (typeArgTypes.length < paramLimit) {
                // Fill up the remainder of the slots with unknown types.
                while (typeArgTypes.length < paramLimit) {
                    typeArgTypes.push(UnknownType.create());
                }
            }
        }

        // Handle tuple type params as a special case.
        let returnType: Type;
        if (isTupleTypeParam) {
            const tupleTypeArgTypes: TupleTypeArgument[] = [];

            // If no type args are provided and it's a tuple, default to [Unknown, ...].
            if (!typeArgs) {
                tupleTypeArgTypes.push({ type: UnknownType.create(), isUnbounded: true });
            } else {
                typeArgs.forEach((typeArg, index) => {
                    if (index === 1 && isEllipsisType(typeArgTypes[index])) {
                        if (tupleTypeArgTypes.length === 1 && !tupleTypeArgTypes[0].isUnbounded) {
                            tupleTypeArgTypes[0] = { type: tupleTypeArgTypes[0].type, isUnbounded: true };
                        } else {
                            this.addError(Localizer.Diagnostic.ellipsisSecondArg(), typeArg.node);
                        }
                    } else if (isUnpackedClass(typeArg.type) && typeArg.type.tupleTypeArguments) {
                        appendArray(tupleTypeArgTypes, typeArg.type.tupleTypeArguments);
                    } else {
                        tupleTypeArgTypes.push({ type: typeArgTypes[index], isUnbounded: false });
                    }
                });
            }

            returnType = specializeTupleClass(classType, tupleTypeArgTypes, typeArgs !== undefined);
        } else {
            returnType = ClassType.cloneForSpecialization(classType, typeArgTypes, typeArgs !== undefined);
        }

        if (!isCallable) {
            TypeBase.setSpecialForm(returnType);
        }

        return returnType;
    }

    // Unpacks the index expression for a "Union[X, Y, Z]" type annotation.
    createUnionType(
        classType: ClassType,
        errorNode: ParseNode,
        typeArgs: TypeResultWithNode[] | undefined,
        flags: EvaluatorFlags
    ): Type {
        const types: Type[] = [];

        if (!typeArgs) {
            // If no type arguments are provided, the resulting type
            // depends on whether we're evaluating a type annotation or
            // we're in some other context.
            if ((flags & EvaluatorFlags.ExpectingTypeAnnotation) !== 0) {
                this.addError(Localizer.Diagnostic.unionTypeArgCount(), errorNode);
                return NeverType.createNever();
            }

            return classType;
        }

        for (const typeArg of typeArgs) {
            let typeArgType = typeArg.type;

            if (!this.validateTypeArg(typeArg, { allowVariadicTypeVar: true, allowUnpackedTuples: true })) {
                typeArgType = UnknownType.create();
            } else if (!TypeBase.isInstantiable(typeArgType)) {
                this.addExpectedClassDiagnostic(typeArgType, typeArg.node);
                typeArgType = UnknownType.create();
            }

            // If this is an unpacked tuple, explode out the individual items.
            if (isUnpackedClass(typeArg.type) && typeArg.type.tupleTypeArguments) {
                typeArg.type.tupleTypeArguments.forEach((tupleTypeArg) => {
                    types.push(convertToInstantiable(tupleTypeArg.type));
                });
            } else {
                // If this is an unpacked TypeVar, note that it is in a union so we can differentiate
                // between Unpack[Vs] and Union[Unpack[Vs]].
                if (isTypeVar(typeArgType) && isUnpackedVariadicTypeVar(typeArgType)) {
                    typeArgType = TypeVarType.cloneForUnpacked(typeArgType, /* isInUnion */ true);
                }

                types.push(typeArgType);
            }
        }

        // Validate that we received at least two type arguments. One type argument
        // is allowed if it's an unpacked variadic type var or tuple. None is also allowed
        // since it is used to define NoReturn in typeshed stubs).
        if (types.length === 1) {
            if (!isVariadicTypeVar(types[0]) && !isUnpacked(types[0]) && !isNoneInstance(types[0])) {
                this.addError(Localizer.Diagnostic.unionTypeArgCount(), errorNode);
            }
        }

        const unionType = combineTypes(types);
        if (isUnion(unionType)) {
            TypeBase.setSpecialForm(unionType);
        }

        return unionType;
    }

    // Creates a type that represents "Generic[T1, T2, ...]", used in the
    // definition of a generic class.
    createGenericType(
        classType: ClassType,
        errorNode: ParseNode,
        typeArgs: TypeResultWithNode[] | undefined,
        flags: EvaluatorFlags
    ): Type {
        if (!typeArgs) {
            // If no type arguments are provided, the resulting type
            // depends on whether we're evaluating a type annotation or
            // we're in some other context.
            if ((flags & (EvaluatorFlags.ExpectingTypeAnnotation | EvaluatorFlags.DisallowNakedGeneric)) !== 0) {
                this.addError(Localizer.Diagnostic.genericTypeArgMissing(), errorNode);
            }

            return classType;
        }

        const uniqueTypeVars: TypeVarType[] = [];
        if (typeArgs) {
            // Make sure there's at least one type arg.
            if (typeArgs.length === 0) {
                this.addError(Localizer.Diagnostic.genericTypeArgMissing(), errorNode);
            }

            // Make sure that all of the type args are typeVars and are unique.
            typeArgs.forEach((typeArg) => {
                if (!isTypeVar(typeArg.type)) {
                    this.addError(Localizer.Diagnostic.genericTypeArgTypeVar(), typeArg.node);
                } else {
                    if (uniqueTypeVars.some((t) => isTypeSame(t, typeArg.type))) {
                        this.addError(Localizer.Diagnostic.genericTypeArgUnique(), typeArg.node);
                    }

                    uniqueTypeVars.push(typeArg.type);
                }
            });
        }

        return this.createSpecialType(classType, typeArgs, /* paramLimit */ undefined, /* allowParamSpec */ true);
    }

    transformTypeForTypeAlias(type: Type, name: NameNode, errorNode: ParseNode, typeParameters?: TypeVarType[]): Type {
        if (!TypeBase.isInstantiable(type)) {
            return type;
        }

        // If this is a recursive type alias that hasn't yet been fully resolved
        // (i.e. there is no boundType associated with it), don't apply the transform.
        if (isTypeAliasPlaceholder(type)) {
            return type;
        }

        if (!typeParameters) {
            // Determine if there are any generic type parameters associated
            // with this type alias.
            typeParameters = [];

            // Skip this for a simple TypeVar (one that's not part of a union).
            if (!isTypeVar(type) || TypeBase.isAnnotated(type)) {
                doForEachSubtype(type, (subtype) => {
                    addTypeVarsToListIfUnique(typeParameters!, getTypeVarArgumentsRecursive(subtype));
                });
            }

            // Don't include any synthesized type variables.
            typeParameters = typeParameters.filter((typeVar) => !typeVar.details.isSynthesized);
        }

        // Convert all type variables to instances.
        typeParameters = typeParameters.map((typeVar) => {
            if (TypeBase.isInstance(typeVar)) {
                return typeVar;
            }
            return convertToInstance(typeVar) as TypeVarType;
        });

        // Verify that we have at most one variadic type variable.
        const variadics = typeParameters.filter((param) => isVariadicTypeVar(param));
        if (variadics.length > 1) {
            this.addError(
                Localizer.Diagnostic.variadicTypeParamTooManyAlias().format({
                    names: variadics.map((v) => `"${v.details.name}"`).join(', '),
                }),
                errorNode
            );
        }

        const fileInfo = AnalyzerNodeInfo.getFileInfo(name);
        const typeAliasScopeId = this.getScopeIdForNode(name);

        const boundTypeVars = typeParameters.filter(
            (typeVar) => typeVar.scopeId !== typeAliasScopeId && typeVar.scopeType === TypeVarScopeType.Class
        );
        if (boundTypeVars.length > 0) {
            this.addError(
                Localizer.Diagnostic.genericTypeAliasBoundTypeVar().format({
                    names: boundTypeVars.map((t) => `${t.details.name}`).join(', '),
                }),
                errorNode
            );
        }

        return TypeBase.cloneForTypeAlias(
            type,
            name.value,
            `${fileInfo.moduleName}.${name.value}`,
            typeAliasScopeId,
            typeParameters.length > 0 ? typeParameters : undefined
        );
    }

    createSpecialBuiltInClass(node: ParseNode, assignedName: string, aliasMapEntry: AliasMapEntry): ClassType {
        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
        let specialClassType = ClassType.createInstantiable(
            assignedName,
            ParseTreeUtils.getClassFullName(node, fileInfo.moduleName, assignedName),
            fileInfo.moduleName,
            fileInfo.filePath,
            ClassTypeFlags.BuiltInClass | ClassTypeFlags.SpecialBuiltIn,
            /* typeSourceId */ 0,
            /* declaredMetaclass */ undefined,
            /* effectiveMetaclass */ undefined
        );

        if (fileInfo.isTypingExtensionsStubFile) {
            specialClassType.details.flags |= ClassTypeFlags.TypingExtensionClass;
        }

        const baseClassName = aliasMapEntry.alias || 'object';

        let baseClass: Type | undefined;
        if (aliasMapEntry.module === 'builtins') {
            baseClass = this.getBuiltInType(node, baseClassName);
        } else if (aliasMapEntry.module === 'collections') {
            // The typing.pyi file imports collections.
            baseClass = this.getTypeOfModule(node, baseClassName, ['collections']);
        } else if (aliasMapEntry.module === 'self') {
            const symbolWithScope = this.lookUpSymbolRecursive(node, baseClassName, /* honorCodeFlow */ false);
            if (symbolWithScope) {
                baseClass = this.getEffectiveTypeOfSymbol(symbolWithScope.symbol);
                // The _TypedDict class is marked as abstract, but the
                // methods that are abstract are overridden and shouldn't
                // cause the TypedDict to be marked as abstract.
                if (isInstantiableClass(baseClass) && ClassType.isBuiltIn(baseClass, '_TypedDict')) {
                    baseClass.details.flags &= ~ClassTypeFlags.SupportsAbstractMethods;
                }
            }
        }

        if (baseClass && isInstantiableClass(baseClass)) {
            if (aliasMapEntry.alias) {
                specialClassType = ClassType.cloneForTypingAlias(baseClass, assignedName);
            } else {
                specialClassType.details.baseClasses.push(baseClass);
                specialClassType.details.effectiveMetaclass = baseClass.details.effectiveMetaclass;
                computeMroLinearization(specialClassType);
            }
        } else {
            specialClassType.details.baseClasses.push(UnknownType.create());
            specialClassType.details.effectiveMetaclass = UnknownType.create();
            computeMroLinearization(specialClassType);
        }

        return specialClassType;
    }

    // Handles some special-case type annotations that are found
    // within the typings.pyi file.
    handleTypingStubTypeAnnotation(node: ExpressionNode): ClassType | undefined {
        if (!node.parent || node.parent.nodeType !== ParseNodeType.TypeAnnotation) {
            return undefined;
        }

        if (node.parent.valueExpression.nodeType !== ParseNodeType.Name) {
            return undefined;
        }

        const nameNode = node.parent.valueExpression;
        const assignedName = nameNode.value;

        const specialTypes: Map<string, AliasMapEntry> = new Map([
            ['Tuple', { alias: 'tuple', module: 'builtins' }],
            ['Generic', { alias: '', module: 'builtins' }],
            ['Protocol', { alias: '', module: 'builtins' }],
            ['Callable', { alias: '', module: 'builtins' }],
            ['Type', { alias: 'type', module: 'builtins' }],
            ['ClassVar', { alias: '', module: 'builtins' }],
            ['Final', { alias: '', module: 'builtins' }],
            ['Literal', { alias: '', module: 'builtins' }],
            ['TypedDict', { alias: '_TypedDict', module: 'self' }],
            ['Union', { alias: '', module: 'builtins' }],
            ['Optional', { alias: '', module: 'builtins' }],
            ['Annotated', { alias: '', module: 'builtins' }],
            ['TypeAlias', { alias: '', module: 'builtins' }],
            ['Concatenate', { alias: '', module: 'builtins' }],
            ['TypeGuard', { alias: '', module: 'builtins' }],
            ['StrictTypeGuard', { alias: '', module: 'builtins' }],
            ['Unpack', { alias: '', module: 'builtins' }],
            ['Required', { alias: '', module: 'builtins' }],
            ['NotRequired', { alias: '', module: 'builtins' }],
            ['Self', { alias: '', module: 'builtins' }],
            ['NoReturn', { alias: '', module: 'builtins' }],
            ['Never', { alias: '', module: 'builtins' }],
            ['LiteralString', { alias: '', module: 'builtins' }],
        ]);

        const aliasMapEntry = specialTypes.get(assignedName);
        if (aliasMapEntry) {
            const cachedType = this.readTypeCache(node, EvaluatorFlags.None);
            if (cachedType) {
                assert(isInstantiableClass(cachedType));
                return cachedType as ClassType;
            }

            const specialType = this.createSpecialBuiltInClass(node, assignedName, aliasMapEntry);

            // Handle 'LiteralString' specially because we want it to act as
            // though it derives from 'str'.
            if (assignedName === 'LiteralString') {
                specialType.details.baseClasses.push(this._strClassType ?? AnyType.create());
                computeMroLinearization(specialType);
            }

            this.writeTypeCache(node, specialType, EvaluatorFlags.None, /* isIncomplete */ false);
            return specialType;
        }

        return undefined;
    }

    // Handles some special-case assignment statements that are found
    // within the typings.pyi file.
    handleTypingStubAssignment(node: AssignmentNode): Type | undefined {
        if (node.leftExpression.nodeType !== ParseNodeType.Name) {
            return undefined;
        }

        const nameNode = node.leftExpression;
        const assignedName = nameNode.value;

        if (assignedName === 'Any') {
            return AnyType.create();
        }

        const specialTypes: Map<string, AliasMapEntry> = new Map([
            ['overload', { alias: '', module: 'builtins' }],
            ['TypeVar', { alias: '', module: 'builtins' }],
            ['_promote', { alias: '', module: 'builtins' }],
            ['no_type_check', { alias: '', module: 'builtins' }],
            ['NoReturn', { alias: '', module: 'builtins' }],
            ['Never', { alias: '', module: 'builtins' }],
            ['Counter', { alias: 'Counter', module: 'collections' }],
            ['List', { alias: 'list', module: 'builtins' }],
            ['Dict', { alias: 'dict', module: 'builtins' }],
            ['DefaultDict', { alias: 'defaultdict', module: 'collections' }],
            ['Set', { alias: 'set', module: 'builtins' }],
            ['FrozenSet', { alias: 'frozenset', module: 'builtins' }],
            ['Deque', { alias: 'deque', module: 'collections' }],
            ['ChainMap', { alias: 'ChainMap', module: 'collections' }],
            ['OrderedDict', { alias: 'OrderedDict', module: 'collections' }],
        ]);

        const aliasMapEntry = specialTypes.get(assignedName);
        if (aliasMapEntry) {
            // Evaluate the expression so symbols are marked as accessed.
            this.getTypeOfExpression(node.rightExpression);
            return this.createSpecialBuiltInClass(node, assignedName, aliasMapEntry);
        }

        return undefined;
    }

    evaluateTypesForAssignmentStatement(node: AssignmentNode): void {
        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);

        // If the entire statement has already been evaluated, don't
        // re-evaluate it.
        if (this.readTypeCache(node, EvaluatorFlags.None)) {
            return;
        }

        let flags: EvaluatorFlags = EvaluatorFlags.None;
        if (fileInfo.isStubFile) {
            // An assignment of ellipsis means "Any" within a type stub file.
            flags |= EvaluatorFlags.ConvertEllipsisToUnknown;
        }

        if (
            node.rightExpression.nodeType === ParseNodeType.Name ||
            node.rightExpression.nodeType === ParseNodeType.MemberAccess
        ) {
            // Don't specialize a generic class on assignment (e.g. "x = list"
            // or "x = collections.OrderedDict") because we may want to later
            // specialize it (e.g. "x[int]").
            flags |= EvaluatorFlags.DoNotSpecialize;
        }

        if (this.isDeclaredTypeAlias(node.leftExpression)) {
            flags |=
                EvaluatorFlags.ExpectingType |
                EvaluatorFlags.EvaluateStringLiteralAsType |
                EvaluatorFlags.ParamSpecDisallowed |
                EvaluatorFlags.TypeVarTupleDisallowed |
                EvaluatorFlags.ClassVarDisallowed;
            flags &= ~EvaluatorFlags.DoNotSpecialize;
        }

        // Is this type already cached?
        let rightHandType = this.readTypeCache(node.rightExpression, flags);
        let isIncomplete = false;
        let expectedTypeDiagAddendum: DiagnosticAddendum | undefined;

        if (!rightHandType) {
            // Special-case the typing.pyi file, which contains some special
            // types that the type analyzer needs to interpret differently.
            if (fileInfo.isTypingStubFile || fileInfo.isTypingExtensionsStubFile) {
                rightHandType = this.handleTypingStubAssignment(node);
                if (rightHandType) {
                    this.writeTypeCache(
                        node.rightExpression,
                        rightHandType,
                        EvaluatorFlags.None,
                        /* isIncomplete */ false
                    );
                }
            }

            if (!rightHandType) {
                // Determine whether there is a declared type.
                const declaredType = this.getDeclaredTypeForExpression(node.leftExpression, {
                    method: 'set',
                });

                let typeAliasNameNode: NameNode | undefined;
                let isSpeculativeTypeAlias = false;

                if (this.isDeclaredTypeAlias(node.leftExpression)) {
                    typeAliasNameNode = (node.leftExpression as TypeAnnotationNode).valueExpression as NameNode;

                    if (!isLegalTypeAliasExpressionForm(node.rightExpression)) {
                        this.addDiagnostic(
                            fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                            DiagnosticRule.reportGeneralTypeIssues,
                            Localizer.Diagnostic.typeAliasIllegalExpressionForm(),
                            node.rightExpression
                        );
                    }
                } else if (node.leftExpression.nodeType === ParseNodeType.Name) {
                    const symbolWithScope = this.lookUpSymbolRecursive(
                        node.leftExpression,
                        node.leftExpression.value,
                        /* honorCodeFlow */ false
                    );
                    if (symbolWithScope) {
                        const decls = symbolWithScope.symbol.getDeclarations();
                        if (decls.length === 1 && this.isPossibleTypeAliasOrTypedDict(decls[0])) {
                            typeAliasNameNode = node.leftExpression;
                            isSpeculativeTypeAlias = true;
                        }
                    }
                }

                // Synthesize a type variable that represents the type alias while we're
                // evaluating it. This allows us to handle recursive definitions.
                let typeAliasTypeVar: TypeVarType | undefined;
                if (typeAliasNameNode) {
                    typeAliasTypeVar = TypeVarType.createInstantiable(`__type_alias_${typeAliasNameNode.value}`);
                    typeAliasTypeVar.details.isSynthesized = true;
                    typeAliasTypeVar.details.recursiveTypeAliasName = typeAliasNameNode.value;
                    const scopeId = this.getScopeIdForNode(typeAliasNameNode);
                    typeAliasTypeVar.details.recursiveTypeAliasScopeId = scopeId;
                    typeAliasTypeVar.scopeId = scopeId;

                    // Write the type back to the type cache. It will be replaced below.
                    this.writeTypeCache(node, typeAliasTypeVar, /* flags */ undefined, /* isIncomplete */ false);
                    this.writeTypeCache(
                        node.leftExpression,
                        typeAliasTypeVar,
                        /* flags */ undefined,
                        /* isIncomplete */ false
                    );
                    if (node.leftExpression.nodeType === ParseNodeType.TypeAnnotation) {
                        this.writeTypeCache(
                            node.leftExpression.valueExpression,
                            typeAliasTypeVar,
                            /* flags */ undefined,
                            /* isIncomplete */ false
                        );
                    }
                }

                const srcTypeResult = this.getTypeOfExpression(node.rightExpression, flags, declaredType);
                let srcType = srcTypeResult.type;
                expectedTypeDiagAddendum = srcTypeResult.expectedTypeDiagAddendum;
                if (srcTypeResult.isIncomplete) {
                    isIncomplete = true;
                }

                // If the RHS is a constant boolean expression, assign it a literal type.
                const constExprValue = evaluateStaticBoolExpression(
                    node.rightExpression,
                    fileInfo.executionEnvironment,
                    fileInfo.definedConstants
                );

                if (constExprValue !== undefined) {
                    const boolType = this.getBuiltInObject(node, 'bool');
                    if (isClassInstance(boolType)) {
                        srcType = ClassType.cloneWithLiteral(boolType, constExprValue);
                    }
                }

                // If there was a declared type, make sure the RHS value is compatible.
                if (declaredType) {
                    if (this.assignType(declaredType, srcType)) {
                        // Narrow the resulting type if possible.
                        if (!isAnyOrUnknown(srcType)) {
                            srcType = this.narrowTypeBasedOnAssignment(declaredType, srcType);
                        }
                    }
                }

                // If this is an enum, transform the type as required.
                rightHandType = srcType;
                if (node.leftExpression.nodeType === ParseNodeType.Name && !node.typeAnnotationComment) {
                    rightHandType =
                        transformTypeForPossibleEnumClass(this, node.leftExpression, () => rightHandType!) ||
                        rightHandType;
                }

                if (typeAliasNameNode) {
                    // Clear out the temporary types we wrote above.
                    this.deleteTypeCacheEntry(node);
                    this.deleteTypeCacheEntry(node.leftExpression);
                    if (node.leftExpression.nodeType === ParseNodeType.TypeAnnotation) {
                        this.deleteTypeCacheEntry(node.leftExpression.valueExpression);
                    }

                    // If this was a speculative type alias, it becomes a real type alias
                    // only if the evaluated type is an instantiable type.
                    if (
                        !isSpeculativeTypeAlias ||
                        (TypeBase.isInstantiable(rightHandType) && !isUnknown(rightHandType))
                    ) {
                        // If this is a type alias, record its name based on the assignment target.
                        rightHandType = this.transformTypeForTypeAlias(
                            rightHandType,
                            typeAliasNameNode,
                            node.rightExpression
                        );

                        if (isTypeAliasRecursive(typeAliasTypeVar!, rightHandType)) {
                            this.addDiagnostic(
                                fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                                DiagnosticRule.reportGeneralTypeIssues,
                                Localizer.Diagnostic.typeAliasIsRecursiveDirect().format({
                                    name: typeAliasNameNode.value,
                                }),
                                node.rightExpression
                            );

                            rightHandType = UnknownType.create();
                        }

                        // Set the resulting type to the boundType of the original type alias
                        // to support recursive type aliases.
                        typeAliasTypeVar!.details.boundType = rightHandType;

                        // Record the type parameters within the recursive type alias so it
                        // can be specialized.
                        typeAliasTypeVar!.details.recursiveTypeParameters = rightHandType.typeAliasInfo?.typeParameters;
                    }

                    if (typeAliasTypeVar!.details.illegalRecursionDetected) {
                        this.addDiagnostic(
                            fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                            DiagnosticRule.reportGeneralTypeIssues,
                            Localizer.Diagnostic.typeAliasIsRecursiveIndirect().format({
                                name: typeAliasNameNode.value,
                            }),
                            node.leftExpression
                        );
                    }
                }
            }
        }

        this.assignTypeToExpression(
            node.leftExpression,
            rightHandType,
            isIncomplete,
            node.rightExpression,
            /* ignoreEmptyContainers */ true,
            /* allowAssignmentToFinalVar */ true,
            expectedTypeDiagAddendum
        );

        this.writeTypeCache(node, rightHandType, EvaluatorFlags.None, isIncomplete);
    }

    isPossibleTypeAliasOrTypedDict(decl: Declaration) {
        if (isPossibleTypeAliasDeclaration(decl)) {
            return true;
        }

        if (
            decl.type === DeclarationType.Variable &&
            decl.node.parent &&
            decl.node.parent.nodeType === ParseNodeType.Assignment &&
            decl.node.parent.rightExpression?.nodeType === ParseNodeType.Call
        ) {
            const callLeftNode = decl.node.parent.rightExpression.leftExpression;

            // Use a simple heuristic to determine whether this is potentially
            // a call to the TypedDict call. This avoids the expensive (and potentially
            // recursive) call to getTypeOfExpression in cases where it's not needed.
            if (
                (callLeftNode.nodeType === ParseNodeType.Name && callLeftNode.value) === 'TypedDict' ||
                (callLeftNode.nodeType === ParseNodeType.MemberAccess &&
                    callLeftNode.memberName.value === 'TypedDict' &&
                    callLeftNode.leftExpression.nodeType === ParseNodeType.Name)
            ) {
                // See if this is a call to TypedDict. We want to support
                // recursive type references in a TypedDict call.
                const callType = this.getTypeOfExpression(callLeftNode, EvaluatorFlags.DoNotSpecialize).type;

                if (isInstantiableClass(callType) && ClassType.isBuiltIn(callType, 'TypedDict')) {
                    return true;
                }
            }
        }

        return false;
    }

    // Evaluates the type of a type alias (i.e. "type") statement. This code
    // path does not handle traditional type aliases, which are treated as
    // variables since they use normal variable assignment syntax.
    getTypeOfTypeAlias(node: TypeAliasNode): Type {
        const cachedType = this.readTypeCache(node.name, EvaluatorFlags.None);
        if (cachedType) {
            return cachedType;
        }

        // Synthesize a type variable that represents the type alias while we're
        // evaluating it. This allows us to handle recursive definitions.
        const typeAliasTypeVar = TypeVarType.createInstantiable(`__type_alias_${node.name.value}`);
        typeAliasTypeVar.details.isSynthesized = true;
        typeAliasTypeVar.details.recursiveTypeAliasName = node.name.value;
        const scopeId = this.getScopeIdForNode(node.name);
        typeAliasTypeVar.details.recursiveTypeAliasScopeId = scopeId;
        typeAliasTypeVar.scopeId = scopeId;

        // Write the type to the type cache. It will be replaced below.
        this.writeTypeCache(node.name, typeAliasTypeVar, /* flags */ undefined, /* isIncomplete */ false);

        // Set a partial type to handle recursive (self-referential) type aliases.
        const scope = ScopeUtils.getScopeForNode(node);
        const typeAliasSymbol = scope?.lookUpSymbolRecursive(node.name.value);
        const typeAliasDecl = AnalyzerNodeInfo.getDeclaration(node);
        if (typeAliasDecl && typeAliasSymbol) {
            this.setSymbolResolutionPartialType(typeAliasSymbol.symbol, typeAliasDecl, typeAliasTypeVar);
        }

        let typeParameters: TypeVarType[] = [];
        if (node.typeParameters) {
            typeParameters = this.evaluateTypeParameterList(node.typeParameters);
            typeAliasTypeVar.details.recursiveTypeParameters = typeParameters;
        }

        if (!isLegalTypeAliasExpressionForm(node.expression)) {
            this.addDiagnostic(
                AnalyzerNodeInfo.getFileInfo(node).diagnosticRuleSet.reportGeneralTypeIssues,
                DiagnosticRule.reportGeneralTypeIssues,
                Localizer.Diagnostic.typeAliasIllegalExpressionForm(),
                node.expression
            );
        }

        const aliasTypeResult = this.getTypeOfExpressionExpectingType(node.expression);
        let isIncomplete = false;
        let aliasType = aliasTypeResult.type;
        if (aliasTypeResult.isIncomplete) {
            isIncomplete = true;
        }

        // Clear the temporary type we wrote above.
        this.deleteTypeCacheEntry(node.name);

        aliasType = this.transformTypeForTypeAlias(aliasType, node.name, node.expression, typeParameters);

        if (isTypeAliasRecursive(typeAliasTypeVar, aliasType)) {
            this.addDiagnostic(
                AnalyzerNodeInfo.getFileInfo(node).diagnosticRuleSet.reportGeneralTypeIssues,
                DiagnosticRule.reportGeneralTypeIssues,
                Localizer.Diagnostic.typeAliasIsRecursiveDirect().format({
                    name: node.name.value,
                }),
                node.expression
            );

            aliasType = UnknownType.create();
        }

        // Set the resulting type to the boundType of the original type alias
        // to support recursive type aliases.
        typeAliasTypeVar.details.boundType = aliasType;

        if (typeAliasTypeVar.details.illegalRecursionDetected) {
            this.addDiagnostic(
                AnalyzerNodeInfo.getFileInfo(node).diagnosticRuleSet.reportGeneralTypeIssues,
                DiagnosticRule.reportGeneralTypeIssues,
                Localizer.Diagnostic.typeAliasIsRecursiveIndirect().format({
                    name: node.name.value,
                }),
                node.name
            );
        }

        this.writeTypeCache(node.name, aliasType, EvaluatorFlags.None, isIncomplete);

        return aliasType;
    }

    evaluateTypesForAugmentedAssignment(node: AugmentedAssignmentNode): void {
        if (this.readTypeCache(node, EvaluatorFlags.None)) {
            return;
        }

        const destTypeResult = this.getTypeOfAugmentedAssignment(node, /* expectedType */ undefined);

        this.writeTypeCache(node, destTypeResult.type, EvaluatorFlags.None, !!destTypeResult.isIncomplete);
    }

    getPseudoGenericTypeVarName(paramName: string) {
        return `__type_of_${paramName}`;
    }

    getTypeOfClass(node: ClassNode): ClassTypeResult | undefined {
        // Is this type already cached?
        const cachedClassType = this.readTypeCache(node.name, EvaluatorFlags.None);

        if (cachedClassType) {
            if (!isInstantiableClass(cachedClassType)) {
                // This can happen in rare circumstances where the class declaration
                // is located in an unreachable code block.
                return undefined;
            }
            return {
                classType: cachedClassType,
                decoratedType: this.readTypeCache(node, EvaluatorFlags.None) || UnknownType.create(),
            };
        }

        // The type wasn't cached, so we need to create a new one.
        const scope = ScopeUtils.getScopeForNode(node);

        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
        let classFlags = ClassTypeFlags.None;
        if (
            scope?.type === ScopeType.Builtin ||
            fileInfo.isTypingStubFile ||
            fileInfo.isTypingExtensionsStubFile ||
            fileInfo.isBuiltInStubFile
        ) {
            classFlags |= ClassTypeFlags.BuiltInClass;

            if (fileInfo.isTypingExtensionsStubFile) {
                classFlags |= ClassTypeFlags.TypingExtensionClass;
            }

            if (node.name.value === 'property') {
                classFlags |= ClassTypeFlags.PropertyClass;
            }

            if (node.name.value === 'tuple') {
                classFlags |= ClassTypeFlags.TupleClass;
            }
        }

        if (fileInfo.isStubFile) {
            classFlags |= ClassTypeFlags.DefinedInStub;
        }

        const classType = ClassType.createInstantiable(
            node.name.value,
            ParseTreeUtils.getClassFullName(node, fileInfo.moduleName, node.name.value),
            fileInfo.moduleName,
            fileInfo.filePath,
            classFlags,
            /* typeSourceId */ 0,
            /* declaredMetaclass */ undefined,
            /* effectiveMetaclass */ undefined,
            ParseTreeUtils.getDocString(node.suite.statements)
        );

        classType.details.typeVarScopeId = this.getScopeIdForNode(node);

        // Some classes refer to themselves within type arguments used within
        // base classes. We'll register the partially-constructed class type
        // to allow these to be resolved.
        const classSymbol = scope?.lookUpSymbol(node.name.value);
        let classDecl: ClassDeclaration | undefined;
        const decl = AnalyzerNodeInfo.getDeclaration(node);
        if (decl) {
            classDecl = decl as ClassDeclaration;
        }
        if (classDecl && classSymbol) {
            this.setSymbolResolutionPartialType(classSymbol, classDecl, classType);
        }
        classType.details.flags |= ClassTypeFlags.PartiallyEvaluated;
        this.writeTypeCache(node, classType, /* flags */ undefined, /* isIncomplete */ false);
        this.writeTypeCache(node.name, classType, /* flags */ undefined, /* isIncomplete */ false);

        // Keep a list of unique type parameters that are used in the
        // base class arguments.
        let typeParameters: TypeVarType[] = [];

        if (node.typeParameters) {
            typeParameters = this.evaluateTypeParameterList(node.typeParameters).map((t) =>
                TypeVarType.cloneAsInstance(t)
            );
        }

        // If the class derives from "Generic" directly, it will provide
        // all of the type parameters in the specified order.
        let genericTypeParameters: TypeVarType[] | undefined;
        let protocolTypeParameters: TypeVarType[] | undefined;

        const initSubclassArgs: FunctionArgument[] = [];
        let metaclassNode: ExpressionNode | undefined;
        let exprFlags =
            EvaluatorFlags.ExpectingType |
            EvaluatorFlags.AllowGenericClassType |
            EvaluatorFlags.DisallowNakedGeneric |
            EvaluatorFlags.DisallowTypeVarsWithScopeId |
            EvaluatorFlags.AssociateTypeVarsWithCurrentScope |
            EvaluatorFlags.EnforceTypeVarVarianceConsistency;
        if (fileInfo.isStubFile) {
            exprFlags |= EvaluatorFlags.AllowForwardReferences;
        }

        node.arguments.forEach((arg) => {
            // Ignore unpacked arguments.
            if (arg.argumentCategory !== ArgumentCategory.Simple) {
                // Evaluate the expression's type so symbols are marked accessed
                // and errors are reported.
                this.getTypeOfExpression(arg.valueExpression);
                return;
            }

            if (!arg.name) {
                let argType = this.getTypeOfExpression(arg.valueExpression, exprFlags).type;

                // In some stub files, classes are conditionally defined (e.g. based
                // on platform type). We'll assume that the conditional logic is correct
                // and strip off the "unbound" union.
                if (isUnion(argType)) {
                    argType = removeUnbound(argType);
                }

                if (!isAnyOrUnknown(argType) && !isUnbound(argType)) {
                    if (!isInstantiableClass(argType)) {
                        this.addDiagnostic(
                            fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                            DiagnosticRule.reportGeneralTypeIssues,
                            Localizer.Diagnostic.baseClassInvalid(),
                            arg
                        );
                        argType = UnknownType.create();
                    } else {
                        if (ClassType.isPartiallyEvaluated(argType)) {
                            // If the base class is partially evaluated, install a callback
                            // so we can fix up this class (e.g. compute the MRO) when the
                            // dependent class is completed.
                            this._classTypeHooks.push({
                                dependency: argType,
                                callback: () => this.completeClassTypeDeferred(classType, node.name),
                            });
                        }

                        if (ClassType.isBuiltIn(argType, 'Protocol')) {
                            if (
                                !fileInfo.isStubFile &&
                                !ClassType.isTypingExtensionClass(argType) &&
                                fileInfo.executionEnvironment.pythonVersion < PythonVersion.V3_7
                            ) {
                                this.addError(Localizer.Diagnostic.protocolIllegal(), arg.valueExpression);
                            }
                            classType.details.flags |= ClassTypeFlags.ProtocolClass;
                        }

                        if (ClassType.isBuiltIn(argType, 'property')) {
                            classType.details.flags |= ClassTypeFlags.PropertyClass;
                        }

                        // If the class directly derives from NamedTuple (in Python 3.6 or
                        // newer), it's considered a (read-only) dataclass.
                        if (fileInfo.executionEnvironment.pythonVersion >= PythonVersion.V3_6) {
                            if (ClassType.isBuiltIn(argType, 'NamedTuple')) {
                                classType.details.flags |=
                                    ClassTypeFlags.DataClass |
                                    ClassTypeFlags.SkipSynthesizedDataClassEq |
                                    ClassTypeFlags.ReadOnlyInstanceVariables;
                            }
                        }

                        // If the class directly derives from TypedDict or from a class that is
                        // a TypedDict, it is considered a TypedDict.
                        if (ClassType.isBuiltIn(argType, 'TypedDict') || ClassType.isTypedDictClass(argType)) {
                            classType.details.flags |= ClassTypeFlags.TypedDictClass;
                        } else if (ClassType.isTypedDictClass(classType) && !ClassType.isTypedDictClass(argType)) {
                            // Exempt Generic from this test. As of Python 3.11, generic TypedDict
                            // classes are supported.
                            if (!isInstantiableClass(argType) || !ClassType.isBuiltIn(argType, 'Generic')) {
                                // TypedDict classes must derive only from other TypedDict classes.
                                this.addError(Localizer.Diagnostic.typedDictBaseClass(), arg);
                            }
                        }

                        // Validate that the class isn't deriving from itself, creating a
                        // circular dependency.
                        if (derivesFromClassRecursive(argType, classType, /* ignoreUnknown */ true)) {
                            this.addError(Localizer.Diagnostic.baseClassCircular(), arg);
                            argType = UnknownType.create();
                        }
                    }
                }

                if (isUnknown(argType)) {
                    this.addDiagnostic(
                        fileInfo.diagnosticRuleSet.reportUntypedBaseClass,
                        DiagnosticRule.reportUntypedBaseClass,
                        Localizer.Diagnostic.baseClassUnknown(),
                        arg
                    );
                }

                // Check for a duplicate class.
                if (
                    classType.details.baseClasses.some((prevBaseClass) => {
                        return (
                            isInstantiableClass(prevBaseClass) &&
                            isInstantiableClass(argType) &&
                            ClassType.isSameGenericClass(argType, prevBaseClass)
                        );
                    })
                ) {
                    this.addDiagnostic(
                        fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                        DiagnosticRule.reportGeneralTypeIssues,
                        Localizer.Diagnostic.duplicateBaseClass(),
                        arg.name || arg
                    );
                }

                classType.details.baseClasses.push(argType);
                if (isInstantiableClass(argType)) {
                    if (ClassType.isEnumClass(argType)) {
                        classType.details.flags |= ClassTypeFlags.EnumClass;
                    }

                    // Determine if the class is abstract. Protocol classes support abstract methods
                    // even though they don't derive from the ABCMeta class. We'll exclude built-in
                    // protocol classes because these are known not to contain any abstract methods
                    // and getAbstractMethods causes problems because of dependencies on some of these
                    // built-in protocol classes.
                    if (
                        ClassType.supportsAbstractMethods(argType) ||
                        (ClassType.isProtocolClass(argType) && !ClassType.isBuiltIn(argType))
                    ) {
                        classType.details.flags |= ClassTypeFlags.SupportsAbstractMethods;
                    }

                    if (ClassType.isPropertyClass(argType)) {
                        classType.details.flags |= ClassTypeFlags.PropertyClass;
                    }

                    if (ClassType.isFinal(argType)) {
                        const className = this.printObjectTypeForClass(argType);
                        this.addError(
                            Localizer.Diagnostic.baseClassFinal().format({ type: className }),
                            arg.valueExpression
                        );
                    }
                }

                addTypeVarsToListIfUnique(typeParameters, getTypeVarArgumentsRecursive(argType));
                if (isInstantiableClass(argType)) {
                    if (ClassType.isBuiltIn(argType, 'Generic')) {
                        // 'Generic' is implicitly added if type parameter syntax is used.
                        if (node.typeParameters) {
                            this.addDiagnostic(
                                fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                                DiagnosticRule.reportGeneralTypeIssues,
                                Localizer.Diagnostic.genericBaseClassNotAllowed(),
                                arg.valueExpression
                            );
                        } else {
                            if (!genericTypeParameters) {
                                if (protocolTypeParameters) {
                                    this.addDiagnostic(
                                        fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                                        DiagnosticRule.reportGeneralTypeIssues,
                                        Localizer.Diagnostic.duplicateGenericAndProtocolBase(),
                                        arg.valueExpression
                                    );
                                }
                                genericTypeParameters = [];
                                addTypeVarsToListIfUnique(genericTypeParameters, getTypeVarArgumentsRecursive(argType));
                            }
                        }
                    } else if (
                        ClassType.isBuiltIn(argType, 'Protocol') &&
                        argType.typeArguments &&
                        argType.typeArguments.length > 0
                    ) {
                        if (!protocolTypeParameters) {
                            if (genericTypeParameters) {
                                this.addDiagnostic(
                                    fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                                    DiagnosticRule.reportGeneralTypeIssues,
                                    Localizer.Diagnostic.duplicateGenericAndProtocolBase(),
                                    arg.valueExpression
                                );
                            }
                            protocolTypeParameters = [];
                            addTypeVarsToListIfUnique(protocolTypeParameters, getTypeVarArgumentsRecursive(argType));

                            if (node.typeParameters && protocolTypeParameters.length > 0) {
                                this.addDiagnostic(
                                    fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                                    DiagnosticRule.reportGeneralTypeIssues,
                                    Localizer.Diagnostic.protocolBaseClassWithTypeArgs(),
                                    arg.valueExpression
                                );
                                protocolTypeParameters = [];
                            }
                        }
                    }
                }
            } else if (arg.name.value === 'metaclass') {
                if (metaclassNode) {
                    this.addError(Localizer.Diagnostic.metaclassDuplicate(), arg);
                } else {
                    metaclassNode = arg.valueExpression;
                }
            } else if (arg.name.value === 'total' && ClassType.isTypedDictClass(classType)) {
                // The "total" parameter name applies only for TypedDict classes.
                // PEP 589 specifies that the parameter must be either True or False.
                const constArgValue = evaluateStaticBoolExpression(
                    arg.valueExpression,
                    fileInfo.executionEnvironment,
                    fileInfo.definedConstants
                );
                if (constArgValue === undefined) {
                    this.addError(Localizer.Diagnostic.typedDictTotalParam(), arg.valueExpression);
                } else if (!constArgValue) {
                    classType.details.flags |= ClassTypeFlags.CanOmitDictValues;
                }
            } else {
                // Collect arguments that will be passed to the `__init_subclass__`
                // method described in PEP 487.
                initSubclassArgs.push({
                    argumentCategory: ArgumentCategory.Simple,
                    node: arg,
                    name: arg.name,
                    valueExpression: arg.valueExpression,
                });
            }
        });

        // Check for NamedTuple multiple inheritance.
        if (classType.details.baseClasses.length > 1) {
            let derivesFromNamedTuple = false;
            let foundIllegalBaseClass = false;

            classType.details.baseClasses.forEach((baseClass) => {
                if (isInstantiableClass(baseClass)) {
                    if (ClassType.isBuiltIn(baseClass, 'NamedTuple')) {
                        derivesFromNamedTuple = true;
                    } else if (!ClassType.isBuiltIn(baseClass, 'Generic')) {
                        foundIllegalBaseClass = true;
                    }
                }
            });

            if (derivesFromNamedTuple && foundIllegalBaseClass) {
                this.addDiagnostic(
                    fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                    DiagnosticRule.reportGeneralTypeIssues,
                    Localizer.Diagnostic.namedTupleMultipleInheritance(),
                    node.name
                );
            }
        }

        // Make sure we don't have 'object' derive from itself. Infinite
        // recursion will result.
        if (
            !ClassType.isBuiltIn(classType, 'object') &&
            classType.details.baseClasses.filter((baseClass) => isClass(baseClass)).length === 0
        ) {
            // If there are no other (known) base classes, the class implicitly derives from object.
            classType.details.baseClasses.push(this.getBuiltInType(node, 'object'));
        }

        // If genericTypeParameters or protocolTypeParameters are provided,
        // make sure that typeParameters is a proper subset.
        genericTypeParameters = genericTypeParameters ?? protocolTypeParameters;
        if (genericTypeParameters && !node.typeParameters) {
            this.verifyGenericTypeParameters(node.name, typeParameters, genericTypeParameters);
        }
        classType.details.typeParameters = genericTypeParameters ?? typeParameters;

        // Determine if one or more type parameters is autovariance.
        if (
            classType.details.typeParameters.some(
                (param) => param.details.declaredVariance === Variance.Auto && param.computedVariance === undefined
            )
        ) {
            classType.details.requiresVarianceInference = true;
        }

        // Make sure there's at most one variadic type parameter.
        const variadics = classType.details.typeParameters.filter((param) => isVariadicTypeVar(param));
        if (variadics.length > 1) {
            this.addError(
                Localizer.Diagnostic.variadicTypeParamTooManyClass().format({
                    names: variadics.map((v) => `"${v.details.name}"`).join(', '),
                }),
                node.name,
                TextRange.combine(node.arguments) || node.name
            );
        }

        if (!computeMroLinearization(classType)) {
            this.addError(Localizer.Diagnostic.methodOrdering(), node.name);
        }

        // The scope for this class becomes the "fields" for the corresponding type.
        const innerScope = ScopeUtils.getScopeForNode(node.suite);
        classType.details.fields = innerScope?.symbolTable || new Map<string, Symbol>();

        // Determine whether the class's instance variables are constrained
        // to those defined by __slots__. We need to do this prior to dataclass
        // processing because dataclasses can implicitly add to the slots
        // list.
        const slotsNames = innerScope?.getSlotsNames();
        if (slotsNames) {
            classType.details.localSlotsNames = slotsNames;
        }

        // Determine if the class should be a "pseudo-generic" class, characterized
        // by having an __init__ method with parameters that lack type annotations.
        // For such classes, we'll treat them as generic, with the type arguments provided
        // by the callers of the constructor.
        if (!fileInfo.isStubFile && classType.details.typeParameters.length === 0) {
            const initMethod = classType.details.fields.get('__init__');
            if (initMethod) {
                const initDecls = initMethod.getTypedDeclarations();
                if (initDecls.length === 1 && initDecls[0].type === DeclarationType.Function) {
                    const initDeclNode = initDecls[0].node;
                    const initParams = initDeclNode.parameters;

                    if (
                        initParams.length > 1 &&
                        !initParams.some(
                            (param, index) => !!ParseTreeUtils.getTypeAnnotationForParameter(initDeclNode, index)
                        )
                    ) {
                        const genericParams = initParams.filter(
                            (param, index) =>
                                index > 0 &&
                                param.name &&
                                param.category === ParameterCategory.Simple &&
                                !param.defaultValue
                        );

                        if (genericParams.length > 0) {
                            classType.details.flags |= ClassTypeFlags.PseudoGenericClass;

                            // Create a type parameter for each simple, named parameter
                            // in the __init__ method.
                            classType.details.typeParameters = genericParams.map((param) => {
                                const typeVar = TypeVarType.createInstance(
                                    this.getPseudoGenericTypeVarName(param.name!.value)
                                );
                                typeVar.details.isSynthesized = true;
                                typeVar.scopeId = this.getScopeIdForNode(initDeclNode);
                                typeVar.details.boundType = UnknownType.create();
                                return TypeVarType.cloneForScopeId(
                                    typeVar,
                                    this.getScopeIdForNode(node),
                                    node.name.value,
                                    TypeVarScopeType.Class
                                );
                            });
                        }
                    }
                }
            }
        }

        // Determine if the class has a custom __class_getitem__ method. This applies
        // only to classes that have no type parameters, since those with type parameters
        // are assumed to follow normal subscripting semantics for generic classes.
        if (classType.details.typeParameters.length === 0 && !ClassType.isBuiltIn(classType, 'type')) {
            if (
                classType.details.baseClasses.some(
                    (baseClass) => isInstantiableClass(baseClass) && ClassType.hasCustomClassGetItem(baseClass)
                ) ||
                classType.details.fields.has('__class_getitem__')
            ) {
                classType.details.flags |= ClassTypeFlags.HasCustomClassGetItem;
            }
        }

        // Determine the effective metaclass and detect metaclass conflicts.
        if (metaclassNode) {
            const metaclassType = this.getTypeOfExpression(metaclassNode, exprFlags).type;
            if (isInstantiableClass(metaclassType) || isUnknown(metaclassType)) {
                if (requiresSpecialization(metaclassType, /* ignorePseudoGeneric */ true)) {
                    this.addDiagnostic(
                        fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                        DiagnosticRule.reportGeneralTypeIssues,
                        Localizer.Diagnostic.metaclassIsGeneric(),
                        metaclassNode
                    );
                }

                classType.details.declaredMetaclass = metaclassType;
                if (isInstantiableClass(metaclassType)) {
                    if (ClassType.isBuiltIn(metaclassType, 'EnumMeta')) {
                        classType.details.flags |= ClassTypeFlags.EnumClass;
                    } else if (ClassType.isBuiltIn(metaclassType, 'ABCMeta')) {
                        classType.details.flags |= ClassTypeFlags.SupportsAbstractMethods;
                    }
                }
            }
        }

        const effectiveMetaclass = this.computeEffectiveMetaclass(classType, node.name);

        // Clear the "partially constructed" flag.
        classType.details.flags &= ~ClassTypeFlags.PartiallyEvaluated;

        // Now determine the decorated type of the class.
        let decoratedType: Type = classType;
        let foundUnknown = false;

        for (let i = node.decorators.length - 1; i >= 0; i--) {
            const decorator = node.decorators[i];

            const newDecoratedType = this.applyClassDecorator(decoratedType, classType, decorator);
            if (containsUnknown(newDecoratedType)) {
                // Report this error only on the first unknown type.
                if (!foundUnknown) {
                    this.addDiagnostic(
                        fileInfo.diagnosticRuleSet.reportUntypedClassDecorator,
                        DiagnosticRule.reportUntypedClassDecorator,
                        Localizer.Diagnostic.classDecoratorTypeUnknown(),
                        node.decorators[i].expression
                    );

                    foundUnknown = true;
                }
            } else {
                // Apply the decorator only if the type is known.
                decoratedType = newDecoratedType;
            }
        }

        // Determine whether this class derives from (or has a metaclass) that imbues
        // it with dataclass-like behaviors. If so, we'll apply those here.
        let dataClassBehaviors: DataClassBehaviors | undefined;
        if (isInstantiableClass(effectiveMetaclass) && effectiveMetaclass.details.classDataClassTransform) {
            dataClassBehaviors = effectiveMetaclass.details.classDataClassTransform;
        } else {
            const baseClassDataTransform = classType.details.mro.find((mroClass) => {
                return (
                    isClass(mroClass) &&
                    mroClass.details.classDataClassTransform !== undefined &&
                    !ClassType.isSameGenericClass(mroClass, classType)
                );
            });

            if (baseClassDataTransform) {
                dataClassBehaviors = (baseClassDataTransform as ClassType).details.classDataClassTransform!;
            }
        }

        if (dataClassBehaviors) {
            applyDataClassDefaultBehaviors(classType, dataClassBehaviors);
            applyDataClassClassBehaviorOverrides(this, node.name, classType, initSubclassArgs, dataClassBehaviors);
        }

        // Run any class hooks that depend on this class.
        this.runClassTypeHooks(classType);

        // Synthesize TypedDict methods.
        if (ClassType.isTypedDictClass(classType)) {
            synthesizeTypedDictClassMethods(
                this,
                node,
                classType,
                isClass(decoratedType) && ClassType.isFinal(decoratedType)
            );
        }

        // Synthesize dataclass methods.
        if (ClassType.isDataClass(classType)) {
            const skipSynthesizedInit = ClassType.isSkipSynthesizedDataClassInit(classType);
            let hasExistingInitMethod = skipSynthesizedInit;

            // See if there's already a non-synthesized __init__ method.
            // We shouldn't override it.
            if (!skipSynthesizedInit) {
                const initSymbol = lookUpClassMember(classType, '__init__', ClassMemberLookupFlags.SkipBaseClasses);
                if (initSymbol) {
                    const initSymbolType = this.getTypeOfMember(initSymbol);
                    if (isFunction(initSymbolType)) {
                        if (!FunctionType.isSynthesizedMethod(initSymbolType)) {
                            hasExistingInitMethod = true;
                        }
                    } else {
                        hasExistingInitMethod = true;
                    }
                }
            }

            let skipSynthesizeHash = false;
            const hashSymbol = lookUpClassMember(classType, '__hash__', ClassMemberLookupFlags.SkipBaseClasses);
            if (hashSymbol) {
                const hashSymbolType = this.getTypeOfMember(hashSymbol);
                if (isFunction(hashSymbolType) && !FunctionType.isSynthesizedMethod(hashSymbolType)) {
                    skipSynthesizeHash = true;
                }
            }

            synthesizeDataClassMethods(
                this,
                node,
                classType,
                skipSynthesizedInit,
                hasExistingInitMethod,
                skipSynthesizeHash
            );
        }

        // Build a complete list of all slots names defined by the class hierarchy.
        // This needs to be done after dataclass processing.
        if (classType.details.localSlotsNames) {
            let isLimitedToSlots = true;
            const extendedSlotsNames = [...classType.details.localSlotsNames];

            classType.details.baseClasses.forEach((baseClass) => {
                if (isInstantiableClass(baseClass)) {
                    if (
                        !ClassType.isBuiltIn(baseClass, 'object') &&
                        !ClassType.isBuiltIn(baseClass, 'type') &&
                        !ClassType.isBuiltIn(baseClass, 'Generic')
                    ) {
                        if (baseClass.details.inheritedSlotsNames === undefined) {
                            isLimitedToSlots = false;
                        } else {
                            appendArray(extendedSlotsNames, baseClass.details.inheritedSlotsNames);
                        }
                    }
                } else {
                    isLimitedToSlots = false;
                }
            });

            if (isLimitedToSlots) {
                classType.details.inheritedSlotsNames = extendedSlotsNames;
            }
        }

        // Update the undecorated class type.
        this.writeTypeCache(node.name, classType, EvaluatorFlags.None, /* isIncomplete */ false);

        // Update the decorated class type.
        this.writeTypeCache(node, decoratedType, EvaluatorFlags.None, /* isIncomplete */ false);

        // Stash away a reference to the UnionType class if we encounter it.
        // There's no easy way to otherwise reference it.
        if (ClassType.isBuiltIn(classType, 'UnionType')) {
            this._unionType = ClassType.cloneAsInstance(classType);
        }

        return { classType, decoratedType };
    }

    inferTypeParameterVarianceForClass(classType: ClassType): void {
        if (!classType.details.requiresVarianceInference) {
            return;
        }

        if (!this._objectType || !isClassInstance(this._objectType)) {
            return;
        }

        // Presumptively mark the variance inference as complete. This
        // prevents potential recursion.
        classType.details.requiresVarianceInference = false;

        // Presumptively mark the computed variance to "in progress". We'll
        // replace this below once the variance has been inferred.
        classType.details.typeParameters.forEach((param) => {
            if (param.details.declaredVariance === Variance.Auto) {
                param.computedVariance = Variance.Unknown;
            }
        });

        // Replace all of the type parameters with invariant TypeVars.
        const updatedTypeParams = classType.details.typeParameters.map((typeParam) =>
            TypeVarType.cloneAsInvariant(typeParam)
        );
        const updatedClassType = ClassType.cloneWithNewTypeParameters(classType, updatedTypeParams);

        const dummyTypeObject = ClassType.createInstantiable('__varianceDummy', '', '', '', 0, 0, undefined, undefined);

        updatedTypeParams.forEach((param, paramIndex) => {
            // Skip variadics and ParamSpecs.
            if (param.details.isVariadic || param.details.isParamSpec) {
                return;
            }

            // Skip type variables without auto-variance.
            if (param.details.declaredVariance !== Variance.Auto) {
                return;
            }

            // Replace all type arguments with a dummy type except for the
            // TypeVar of interest, which is replaced with an object instance.
            const srcTypeArgs = updatedTypeParams.map((p, i) => {
                if (p.details.isVariadic) {
                    return p;
                }
                return i === paramIndex ? this._objectType! : dummyTypeObject;
            });

            // Replace all type arguments with a dummy type except for the
            // TypeVar of interest, which is replaced with itself.
            const destTypeArgs = updatedTypeParams.map((p, i) => {
                return i === paramIndex || p.details.isVariadic ? p : dummyTypeObject;
            });

            const srcType = ClassType.cloneForSpecialization(
                updatedClassType,
                srcTypeArgs,
                /* isTypeArgumentExplicit */ true
            );
            const destType = ClassType.cloneForSpecialization(
                updatedClassType,
                destTypeArgs,
                /* isTypeArgumentExplicit */ true
            );

            const isDestSubtypeOfSrc = this.assignClassToSelf(srcType, destType);

            let inferredVariance: Variance;
            if (isDestSubtypeOfSrc) {
                inferredVariance = Variance.Covariant;
            } else {
                const isSrcSubtypeOfDest = this.assignClassToSelf(destType, srcType);
                if (isSrcSubtypeOfDest) {
                    inferredVariance = Variance.Contravariant;
                } else {
                    inferredVariance = Variance.Invariant;
                }
            }

            // We assume here that we don't need to clone the type var object
            // because it was already cloned when it was associated with this
            // class scope.
            classType.details.typeParameters[paramIndex].computedVariance = inferredVariance;
        });
    }

    evaluateTypeParameterList(node: TypeParameterListNode): TypeVarType[] {
        const paramTypes: TypeVarType[] = [];

        node.parameters.forEach((param) => {
            const paramSymbol = AnalyzerNodeInfo.getTypeParameterSymbol(param.name);
            assert(paramSymbol);

            const typeOfParam = this.getDeclaredTypeOfSymbol(paramSymbol, param.name);
            if (!typeOfParam || !isTypeVar(typeOfParam)) {
                return;
            }

            this.writeTypeCache(param.name, typeOfParam, EvaluatorFlags.None, /* isIncomplete */ false);
            paramTypes.push(typeOfParam);
        });

        return paramTypes;
    }

    computeEffectiveMetaclass(classType: ClassType, errorNode: ParseNode) {
        let effectiveMetaclass = classType.details.declaredMetaclass;
        let reportedMetaclassConflict = false;

        if (!effectiveMetaclass || isInstantiableClass(effectiveMetaclass)) {
            for (const baseClass of classType.details.baseClasses) {
                if (isInstantiableClass(baseClass)) {
                    const baseClassMeta = baseClass.details.effectiveMetaclass || this._typeClassType;
                    if (baseClassMeta && isInstantiableClass(baseClassMeta)) {
                        // Make sure there is no metaclass conflict.
                        if (!effectiveMetaclass) {
                            effectiveMetaclass = baseClassMeta;
                        } else if (
                            derivesFromClassRecursive(baseClassMeta, effectiveMetaclass, /* ignoreUnknown */ false)
                        ) {
                            effectiveMetaclass = baseClassMeta;
                        } else if (
                            !derivesFromClassRecursive(effectiveMetaclass, baseClassMeta, /* ignoreUnknown */ false)
                        ) {
                            if (!reportedMetaclassConflict) {
                                this.addDiagnostic(
                                    AnalyzerNodeInfo.getFileInfo(errorNode).diagnosticRuleSet.reportGeneralTypeIssues,
                                    DiagnosticRule.reportGeneralTypeIssues,
                                    Localizer.Diagnostic.metaclassConflict(),
                                    errorNode
                                );
                                // Don't report more than once.
                                reportedMetaclassConflict = true;
                            }
                        }
                    } else {
                        effectiveMetaclass = baseClassMeta ? UnknownType.create() : undefined;
                        break;
                    }
                } else {
                    // If one of the base classes is unknown, then the effective
                    // metaclass is also unknowable.
                    effectiveMetaclass = UnknownType.create();
                    break;
                }
            }
        }

        // If we haven't found an effective metaclass, assume "type", which
        // is the metaclass for "object".
        if (!effectiveMetaclass) {
            const typeMetaclass = this.getBuiltInType(errorNode, 'type');
            effectiveMetaclass =
                typeMetaclass && isInstantiableClass(typeMetaclass) ? typeMetaclass : UnknownType.create();
        }

        classType.details.effectiveMetaclass = effectiveMetaclass;

        return effectiveMetaclass;
    }

    // Verifies that the type variables provided outside of "Generic"
    // or "Protocol" are also provided within the "Generic". For example:
    //    class Foo(Mapping[K, V], Generic[V])
    // is illegal because K is not included in Generic.
    verifyGenericTypeParameters(errorNode: ExpressionNode, typeVars: TypeVarType[], genericTypeVars: TypeVarType[]) {
        const missingFromGeneric = typeVars.filter((typeVar) => {
            return !genericTypeVars.some((genericTypeVar) => genericTypeVar.details.name === typeVar.details.name);
        });

        if (missingFromGeneric.length > 0) {
            const diag = new DiagnosticAddendum();
            diag.addMessage(
                Localizer.DiagnosticAddendum.typeVarsMissing().format({
                    names: missingFromGeneric.map((typeVar) => `"${typeVar.details.name}"`).join(', '),
                })
            );
            this.addDiagnostic(
                AnalyzerNodeInfo.getFileInfo(errorNode).diagnosticRuleSet.reportGeneralTypeIssues,
                DiagnosticRule.reportGeneralTypeIssues,
                Localizer.Diagnostic.typeVarsNotInGenericOrProtocol() + diag.getString(),
                errorNode
            );
        }
    }

    applyClassDecorator(inputClassType: Type, originalClassType: ClassType, decoratorNode: DecoratorNode): Type {
        const fileInfo = AnalyzerNodeInfo.getFileInfo(decoratorNode);
        let flags = fileInfo.isStubFile ? EvaluatorFlags.AllowForwardReferences : EvaluatorFlags.None;
        if (decoratorNode.expression.nodeType !== ParseNodeType.Call) {
            flags |= EvaluatorFlags.DoNotSpecialize;
        }
        const decoratorType = this.getTypeOfExpression(decoratorNode.expression, flags).type;

        if (decoratorNode.expression.nodeType === ParseNodeType.Call) {
            const decoratorCallType = this.getTypeOfExpression(
                decoratorNode.expression.leftExpression,
                flags | EvaluatorFlags.DoNotSpecialize
            ).type;

            if (isFunction(decoratorCallType)) {
                if (
                    decoratorCallType.details.name === '__dataclass_transform__' ||
                    decoratorCallType.details.builtInName === 'dataclass_transform'
                ) {
                    originalClassType.details.classDataClassTransform = validateDataClassTransformDecorator(
                        this,
                        decoratorNode.expression
                    );
                }
            }
        }

        if (isOverloadedFunction(decoratorType)) {
            const dataclassBehaviors = getDataclassDecoratorBehaviors(decoratorType);
            if (dataclassBehaviors) {
                applyDataClassDecorator(
                    this,
                    decoratorNode,
                    originalClassType,
                    dataclassBehaviors,
                    /* callNode */ undefined
                );
                return inputClassType;
            }
        } else if (isFunction(decoratorType)) {
            if (decoratorType.details.builtInName === 'final') {
                originalClassType.details.flags |= ClassTypeFlags.Final;

                // Don't call getTypeOfDecorator for final. We'll hard-code its
                // behavior because its function definition results in a cyclical
                // dependency between builtins, typing and _typeshed stubs.
                return inputClassType;
            } else if (decoratorType.details.builtInName === 'runtime_checkable') {
                originalClassType.details.flags |= ClassTypeFlags.RuntimeCheckable;

                // Don't call getTypeOfDecorator for runtime_checkable. It appears
                // frequently in stubs, and it's a waste of time to validate its
                // parameters.
                return inputClassType;
            }

            // Is this a dataclass decorator?
            let dataclassBehaviors: DataClassBehaviors | undefined;
            let callNode: CallNode | undefined;

            if (decoratorNode.expression.nodeType === ParseNodeType.Call) {
                callNode = decoratorNode.expression;
                const decoratorCallType = this.getTypeOfExpression(
                    callNode.leftExpression,
                    flags | EvaluatorFlags.DoNotSpecialize
                ).type;
                dataclassBehaviors = getDataclassDecoratorBehaviors(decoratorCallType);
            } else {
                const decoratorType = this.getTypeOfExpression(decoratorNode.expression, flags).type;
                dataclassBehaviors = getDataclassDecoratorBehaviors(decoratorType);
            }

            if (dataclassBehaviors) {
                applyDataClassDecorator(this, decoratorNode, originalClassType, dataclassBehaviors, callNode);
                return inputClassType;
            }
        }

        return this.getTypeOfDecorator(decoratorNode, inputClassType);
    }

    // Runs any registered "callback hooks" that depend on the specified class type.
    // This allows us to complete any work that requires dependent classes to be
    // completed.
    runClassTypeHooks(type: ClassType) {
        this._classTypeHooks.forEach((hook) => {
            if (ClassType.isSameGenericClass(hook.dependency, type)) {
                hook.callback();
            }
        });

        // Remove any hooks that depend on this type.
        this._classTypeHooks = this._classTypeHooks.filter(
            (hook) => !ClassType.isSameGenericClass(hook.dependency, type)
        );
    }

    // Recomputes the MRO and effective metaclass for the class after dependent
    // classes have been fully constructed.
    completeClassTypeDeferred(type: ClassType, errorNode: ParseNode) {
        // Recompute the MRO linearization.
        if (!computeMroLinearization(type)) {
            this.addError(Localizer.Diagnostic.methodOrdering(), errorNode);
        }

        // Recompute the effective metaclass.
        this.computeEffectiveMetaclass(type, errorNode);
    }

    validateInitSubclassArgs(node: ClassNode, classType: ClassType, argList: FunctionArgument[]) {
        const errorNode = argList.length > 0 ? argList[0].node!.name! : node.name;
        const initSubclassMethodInfo = this.getTypeOfClassMemberName(
            errorNode,
            classType,
            /* isAccessedThroughObject */ false,
            '__init_subclass__',
            { method: 'get' },
            /* diag */ undefined,
            MemberAccessFlags.AccessClassMembersOnly |
                MemberAccessFlags.SkipObjectBaseClass |
                MemberAccessFlags.SkipOriginalClass,
            classType
        );

        if (initSubclassMethodInfo) {
            const initSubclassMethodType = initSubclassMethodInfo.type;

            if (initSubclassMethodType) {
                this.validateCallArguments(
                    errorNode,
                    argList,
                    { type: initSubclassMethodType },
                    /* typeVarContext */ undefined,
                    /* skipUnknownArgCheck */ false,
                    NoneType.createInstance()
                );
            }
        } else if (classType.details.effectiveMetaclass && isClass(classType.details.effectiveMetaclass)) {
            // See if the metaclass has a `__new__` method that accepts keyword parameters.
            const newMethodMember = lookUpClassMember(
                classType.details.effectiveMetaclass,
                '__new__',
                ClassMemberLookupFlags.SkipTypeBaseClass
            );

            if (newMethodMember) {
                const newMethodType = this.getTypeOfMember(newMethodMember);
                if (isFunction(newMethodType)) {
                    const paramListDetails = getParameterListDetails(newMethodType);

                    if (paramListDetails.firstKeywordOnlyIndex !== undefined) {
                        // Build a map of the keyword-only parameters.
                        const paramMap = new Map<string, number>();
                        for (let i = paramListDetails.firstKeywordOnlyIndex; i < paramListDetails.params.length; i++) {
                            const paramInfo = paramListDetails.params[i];
                            if (paramInfo.param.category === ParameterCategory.Simple && paramInfo.param.name) {
                                paramMap.set(paramInfo.param.name, i);
                            }
                        }

                        argList.forEach((arg) => {
                            if (arg.argumentCategory === ArgumentCategory.Simple && arg.name) {
                                const paramIndex = paramMap.get(arg.name.value) ?? paramListDetails.kwargsIndex;

                                if (paramIndex !== undefined) {
                                    const paramInfo = paramListDetails.params[paramIndex];
                                    const argParam: ValidateArgTypeParams = {
                                        paramCategory: paramInfo.param.category,
                                        paramType: FunctionType.getEffectiveParameterType(
                                            newMethodType,
                                            paramInfo.index
                                        ),
                                        requiresTypeVarMatching: false,
                                        argument: arg,
                                        errorNode: arg.valueExpression ?? errorNode,
                                    };

                                    this.validateArgType(
                                        argParam,
                                        new TypeVarContext(),
                                        newMethodType,
                                        /* skipUnknownCheck */ true,
                                        /* skipOverloadArg */ true,
                                        /* useNarrowBoundOnly */ false,
                                        /* conditionFilter */ undefined
                                    );
                                    paramMap.delete(arg.name.value);
                                } else {
                                    this.addDiagnostic(
                                        AnalyzerNodeInfo.getFileInfo(node).diagnosticRuleSet.reportGeneralTypeIssues,
                                        DiagnosticRule.reportGeneralTypeIssues,
                                        Localizer.Diagnostic.paramNameMissing().format({ name: arg.name.value }),
                                        arg.name ?? errorNode
                                    );
                                }
                            }
                        });

                        // See if we have any remaining unmatched parameters without
                        // default values.
                        const unassignedParams: string[] = [];
                        paramMap.forEach((index, paramName) => {
                            const paramInfo = paramListDetails.params[index];
                            if (!paramInfo.param.hasDefault) {
                                unassignedParams.push(paramName);
                            }
                        });

                        if (unassignedParams.length > 0) {
                            const missingParamNames = unassignedParams.map((p) => `"${p}"`).join(', ');
                            this.addDiagnostic(
                                AnalyzerNodeInfo.getFileInfo(errorNode).diagnosticRuleSet.reportGeneralTypeIssues,
                                DiagnosticRule.reportGeneralTypeIssues,
                                unassignedParams.length === 1
                                    ? Localizer.Diagnostic.argMissingForParam().format({ name: missingParamNames })
                                    : Localizer.Diagnostic.argMissingForParams().format({ names: missingParamNames }),
                                errorNode
                            );
                        }
                    }
                }
            }
        }

        // Evaluate all of the expressions so they are checked and marked referenced.
        argList.forEach((arg) => {
            if (arg.valueExpression) {
                this.getTypeOfExpression(arg.valueExpression);
            }
        });
    }

    getTypeOfFunction(node: FunctionNode): FunctionTypeResult | undefined {
        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);

        // Is this type already cached?
        const cachedFunctionType = this.readTypeCache(node.name, EvaluatorFlags.None) as FunctionType;

        if (cachedFunctionType) {
            if (!isFunction(cachedFunctionType)) {
                // This can happen in certain rare circumstances where the
                // function declaration falls within an unreachable code block.
                return undefined;
            }
            return {
                functionType: cachedFunctionType,
                decoratedType: this.readTypeCache(node, EvaluatorFlags.None) || UnknownType.create(),
            };
        }

        let functionDecl: FunctionDeclaration | undefined;
        const decl = AnalyzerNodeInfo.getDeclaration(node);
        if (decl) {
            functionDecl = decl as FunctionDeclaration;
        }

        // There was no cached type, so create a new one.
        // Retrieve the containing class node if the function is a method.
        const containingClassNode = ParseTreeUtils.getEnclosingClass(node, /* stopAtFunction */ true);
        let containingClassType: ClassType | undefined;
        if (containingClassNode) {
            const classInfo = this.getTypeOfClass(containingClassNode);
            if (!classInfo) {
                return undefined;
            }
            containingClassType = classInfo.classType;
        }

        let functionFlags = this.getFunctionFlagsFromDecorators(node, !!containingClassNode);
        if (functionDecl?.isGenerator) {
            functionFlags |= FunctionTypeFlags.Generator;
        }

        // Special-case magic method __class_getitem__, which is implicitly a class method.
        if (containingClassNode && node.name.value === '__class_getitem__') {
            functionFlags |= FunctionTypeFlags.ClassMethod;
        }

        if (fileInfo.isStubFile) {
            functionFlags |= FunctionTypeFlags.StubDefinition;
        } else if (fileInfo.isInPyTypedPackage) {
            functionFlags |= FunctionTypeFlags.PyTypedDefinition;
        }

        if (node.isAsync) {
            functionFlags |= FunctionTypeFlags.Async;
        }

        const functionType = FunctionType.createInstance(
            node.name.value,
            this.getFunctionFullName(node, fileInfo.moduleName, node.name.value),
            fileInfo.moduleName,
            functionFlags | FunctionTypeFlags.PartiallyEvaluated,
            ParseTreeUtils.getDocString(node.suite.statements)
        );

        functionType.details.typeVarScopeId = this.getScopeIdForNode(node);

        if (node.name.value === '__init__' || node.name.value === '__new__') {
            if (containingClassNode) {
                functionType.details.constructorTypeVarScopeId = this.getScopeIdForNode(containingClassNode);
            }
        }

        if (fileInfo.isBuiltInStubFile || fileInfo.isTypingStubFile || fileInfo.isTypingExtensionsStubFile) {
            // Stash away the name of the function since we need to handle
            // 'namedtuple', 'abstractmethod', 'dataclass' and 'NewType'
            // specially.
            functionType.details.builtInName = node.name.value;
        }

        functionType.details.declaration = functionDecl;

        // Allow recursion by registering the partially-constructed
        // function type.
        const scope = ScopeUtils.getScopeForNode(node);
        const functionSymbol = scope?.lookUpSymbolRecursive(node.name.value);
        if (functionDecl && functionSymbol) {
            this.setSymbolResolutionPartialType(functionSymbol.symbol, functionDecl, functionType);
        }
        this.writeTypeCache(node, functionType, /* flags */ undefined, /* isIncomplete */ false);
        this.writeTypeCache(node.name, functionType, /* flags */ undefined, /* isIncomplete */ false);

        // Is this an "__init__" method within a pseudo-generic class? If so,
        // we'll add generic types to the constructor's parameters.
        const addGenericParamTypes =
            containingClassType &&
            ClassType.isPseudoGenericClass(containingClassType) &&
            node.name.value === '__init__';

        const paramTypes: Type[] = [];

        // Determine if the first parameter should be skipped for comment-based
        // function annotations.
        let firstCommentAnnotationIndex = 0;
        if (containingClassType && (functionType.details.flags & FunctionTypeFlags.StaticMethod) === 0) {
            firstCommentAnnotationIndex = 1;
        }

        // If there is a function annotation comment, validate that it has the correct
        // number of parameter annotations.
        if (node.functionAnnotationComment && !node.functionAnnotationComment.isParamListEllipsis) {
            const expected = node.parameters.length - firstCommentAnnotationIndex;
            const received = node.functionAnnotationComment.paramTypeAnnotations.length;

            // For methods with "self" or "cls" parameters, the annotation list
            // can either include or exclude the annotation for the first parameter.
            if (firstCommentAnnotationIndex > 0 && received === node.parameters.length) {
                firstCommentAnnotationIndex = 0;
            } else if (received !== expected) {
                this.addError(
                    Localizer.Diagnostic.annotatedParamCountMismatch().format({
                        expected,
                        received,
                    }),
                    node.functionAnnotationComment
                );
            }
        }

        if (node.typeParameters) {
            this.evaluateTypeParameterList(node.typeParameters);
        }

        const markParamAccessed = (param: ParameterNode) => {
            if (param.name) {
                const symbolWithScope = this.lookUpSymbolRecursive(
                    param.name,
                    param.name.value,
                    /* honorCodeFlow */ false
                );
                if (symbolWithScope) {
                    this.setSymbolAccessed(fileInfo, symbolWithScope.symbol, param.name);
                }
            }
        };

        let paramsArePositionOnly = true;
        const isFirstParamClsOrSelf =
            containingClassType &&
            (FunctionType.isClassMethod(functionType) ||
                FunctionType.isInstanceMethod(functionType) ||
                FunctionType.isConstructorMethod(functionType));
        const firstNonClsSelfParamIndex = isFirstParamClsOrSelf ? 1 : 0;

        node.parameters.forEach((param, index) => {
            let paramType: Type | undefined;
            let annotatedType: Type | undefined;
            let isNoneWithoutOptional = false;
            let paramTypeNode: ExpressionNode | undefined;

            if (param.name) {
                if (index === 0 && isFirstParamClsOrSelf) {
                    // Mark "self/cls" as accessed.
                    markParamAccessed(param);
                } else if (FunctionType.isAbstractMethod(functionType)) {
                    // Mark all parameters in abstract methods as accessed.
                    markParamAccessed(param);
                } else if (containingClassType && ClassType.isProtocolClass(containingClassType)) {
                    // Mark all parameters in protocol methods as accessed.
                    markParamAccessed(param);
                }
            }

            if (param.typeAnnotation) {
                paramTypeNode = param.typeAnnotation;
            } else if (param.typeAnnotationComment) {
                paramTypeNode = param.typeAnnotationComment;
            } else if (node.functionAnnotationComment && !node.functionAnnotationComment.isParamListEllipsis) {
                const adjustedIndex = index - firstCommentAnnotationIndex;
                if (adjustedIndex >= 0 && adjustedIndex < node.functionAnnotationComment.paramTypeAnnotations.length) {
                    paramTypeNode = node.functionAnnotationComment.paramTypeAnnotations[adjustedIndex];
                }
            }

            if (paramTypeNode) {
                annotatedType = this.getTypeOfParameterAnnotation(paramTypeNode, param.category);

                if (isVariadicTypeVar(annotatedType) && !annotatedType.isVariadicUnpacked) {
                    this.addError(
                        Localizer.Diagnostic.unpackedTypeVarTupleExpected().format({
                            name1: annotatedType.details.name,
                            name2: annotatedType.details.name,
                        }),
                        paramTypeNode
                    );
                    annotatedType = UnknownType.create();
                }
            }

            if (!annotatedType && addGenericParamTypes) {
                if (index > 0 && param.category === ParameterCategory.Simple && param.name && !param.defaultValue) {
                    const typeParamName = this.getPseudoGenericTypeVarName(param.name.value);
                    annotatedType = containingClassType!.details.typeParameters.find(
                        (param) => param.details.name === typeParamName
                    );
                }
            }

            if (annotatedType) {
                const adjustedAnnotatedType = this.adjustParameterAnnotatedType(param, annotatedType);
                if (adjustedAnnotatedType !== annotatedType) {
                    annotatedType = adjustedAnnotatedType;
                    isNoneWithoutOptional = true;
                }
            }

            let defaultValueType: Type | undefined;
            if (param.defaultValue) {
                defaultValueType = this.getTypeOfExpression(
                    param.defaultValue,
                    EvaluatorFlags.ConvertEllipsisToAny,
                    annotatedType
                ).type;
            }

            if (annotatedType) {
                // If there was both a type annotation and a default value, verify
                // that the default value matches the annotation.
                if (param.defaultValue && defaultValueType) {
                    const diagAddendum = new DiagnosticAddendum();
                    const typeVarContext = new TypeVarContext(functionType.details.typeVarScopeId);
                    if (containingClassType && containingClassType.details.typeVarScopeId !== undefined) {
                        if (node.name.value === '__init__' || node.name.value === '__new__') {
                            typeVarContext.addSolveForScope(containingClassType.details.typeVarScopeId);
                        }
                    }

                    if (!this.assignType(annotatedType, defaultValueType, diagAddendum, typeVarContext)) {
                        const diag = this.addDiagnostic(
                            fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                            DiagnosticRule.reportGeneralTypeIssues,
                            Localizer.Diagnostic.paramAssignmentMismatch().format({
                                sourceType: this.printType(defaultValueType),
                                paramType: this.printType(annotatedType),
                            }) + diagAddendum.getString(),
                            param.defaultValue
                        );

                        if (isNoneWithoutOptional && paramTypeNode) {
                            const addOptionalAction: AddMissingOptionalToParamAction = {
                                action: Commands.addMissingOptionalToParam,
                                offsetOfTypeNode: paramTypeNode.start + 1,
                            };
                            diag?.addAction(addOptionalAction);
                        }
                    }
                }

                paramType = annotatedType;
            }

            // Determine whether we need to insert an implied position-only parameter.
            // This is needed when a function's parameters are named using the old-style
            // way of specifying position-only parameters.
            if (index >= firstNonClsSelfParamIndex) {
                let isImplicitPositionOnlyParam = false;

                if (param.category === ParameterCategory.Simple && param.name) {
                    if (isPrivateName(param.name.value)) {
                        isImplicitPositionOnlyParam = true;
                    }
                } else {
                    paramsArePositionOnly = false;
                }

                if (
                    paramsArePositionOnly &&
                    !isImplicitPositionOnlyParam &&
                    functionType.details.parameters.length > firstNonClsSelfParamIndex
                ) {
                    // Insert an implicit "position-only parameter" separator.
                    FunctionType.addParameter(functionType, {
                        category: ParameterCategory.Simple,
                        type: UnknownType.create(),
                    });
                }

                if (!isImplicitPositionOnlyParam) {
                    paramsArePositionOnly = false;
                }
            }

            // If there was no annotation for the parameter, infer its type if possible.
            let isTypeInferred = false;
            if (!paramTypeNode) {
                isTypeInferred = true;
                const inferredType = this.inferParameterType(
                    node,
                    functionType.details.flags,
                    index,
                    containingClassType
                );
                if (inferredType) {
                    paramType = inferredType;
                }
            }

            const functionParam: FunctionParameter = {
                category: param.category,
                name: param.name ? param.name.value : undefined,
                hasDefault: !!param.defaultValue,
                defaultValueExpression: param.defaultValue,
                defaultType: defaultValueType,
                type: paramType ?? UnknownType.create(),
                typeAnnotation: paramTypeNode,
                hasDeclaredType: !!paramTypeNode,
                isTypeInferred,
            };

            FunctionType.addParameter(functionType, functionParam);

            if (param.name) {
                const variadicParamType = this.transformVariadicParamType(node, param.category, functionParam.type);
                paramTypes.push(variadicParamType);
            } else {
                paramTypes.push(functionParam.type);
            }
        });

        if (paramsArePositionOnly && functionType.details.parameters.length > firstNonClsSelfParamIndex) {
            // Insert an implicit "position-only parameter" separator.
            FunctionType.addParameter(functionType, {
                category: ParameterCategory.Simple,
                type: UnknownType.create(),
            });
        }

        // Update the types for the nodes associated with the parameters.
        paramTypes.forEach((paramType, index) => {
            const paramNameNode = node.parameters[index].name;
            if (paramNameNode) {
                if (isUnknown(paramType)) {
                    functionType.details.flags |= FunctionTypeFlags.UnannotatedParams;
                }
                this.writeTypeCache(paramNameNode, paramType, EvaluatorFlags.None, /* isIncomplete */ false);
            }
        });

        // If the function ends in P.args and P.kwargs parameters, make it exempt from
        // args/kwargs compatibility checks. This is important for protocol comparisons.
        if (paramTypes.length >= 2) {
            const paramType1 = paramTypes[paramTypes.length - 2];
            const paramType2 = paramTypes[paramTypes.length - 1];
            if (
                isParamSpec(paramType1) &&
                paramType1.paramSpecAccess === 'args' &&
                isParamSpec(paramType2) &&
                paramType2.paramSpecAccess === 'kwargs'
            ) {
                functionType.details.flags |= FunctionTypeFlags.SkipArgsKwargsCompatibilityCheck;
            }
        }

        // If there was a defined return type, analyze that first so when we
        // walk the contents of the function, return statements can be
        // validated against this type.
        if (node.returnTypeAnnotation) {
            // Temporarily set the return type to unknown in case of recursion.
            functionType.details.declaredReturnType = UnknownType.create();

            const returnType = this.getTypeOfAnnotation(node.returnTypeAnnotation, {
                associateTypeVarsWithScope: true,
                disallowRecursiveTypeAlias: true,
            });
            functionType.details.declaredReturnType = returnType;
        } else if (node.functionAnnotationComment) {
            // Temporarily set the return type to unknown in case of recursion.
            functionType.details.declaredReturnType = UnknownType.create();

            const returnType = this.getTypeOfAnnotation(node.functionAnnotationComment.returnTypeAnnotation, {
                associateTypeVarsWithScope: true,
                disallowRecursiveTypeAlias: true,
            });
            functionType.details.declaredReturnType = returnType;
        } else {
            // If there was no return type annotation and this is a type stub,
            // we have no opportunity to infer the return type, so we'll indicate
            // that it's unknown.
            if (fileInfo.isStubFile) {
                // Special-case the __init__ method, which is commonly left without
                // an annotated return type, but we can assume it returns None.
                if (node.name.value === '__init__') {
                    functionType.details.declaredReturnType = NoneType.createInstance();
                } else {
                    functionType.details.declaredReturnType = UnknownType.create();
                }
            }
        }

        // If the return type is explicitly annotated as a generator, mark the
        // function as a generator even though it may not contain a "yield" statement.
        // This is important for generator functions declared in stub files, abstract
        // methods or protocol definitions.
        if (fileInfo.isStubFile || ParseTreeUtils.isSuiteEmpty(node.suite)) {
            if (
                functionType.details.declaredReturnType &&
                isClassInstance(functionType.details.declaredReturnType) &&
                ClassType.isBuiltIn(functionType.details.declaredReturnType, [
                    'Generator',
                    'AsyncGenerator',
                    'AwaitableGenerator',
                ])
            ) {
                functionType.details.flags |= FunctionTypeFlags.Generator;
            }
        }

        // Clear the "partially evaluated" flag to indicate that the functionType
        // is fully evaluated.
        functionType.details.flags &= ~FunctionTypeFlags.PartiallyEvaluated;

        // If it's an async function, wrap the return type in an Awaitable or Generator.
        const preDecoratedType = node.isAsync ? this.createAsyncFunction(node, functionType) : functionType;

        // Apply all of the decorators in reverse order.
        let decoratedType: Type = preDecoratedType;
        let foundUnknown = false;
        for (let i = node.decorators.length - 1; i >= 0; i--) {
            const decorator = node.decorators[i];

            const newDecoratedType = this.applyFunctionDecorator(decoratedType, functionType, decorator, node);
            if (containsUnknown(newDecoratedType)) {
                // Report this error only on the first unknown type.
                if (!foundUnknown) {
                    this.addDiagnostic(
                        fileInfo.diagnosticRuleSet.reportUntypedFunctionDecorator,
                        DiagnosticRule.reportUntypedFunctionDecorator,
                        Localizer.Diagnostic.functionDecoratorTypeUnknown(),
                        node.decorators[i].expression
                    );

                    foundUnknown = true;
                }
            } else {
                // Apply the decorator only if the type is known.
                decoratedType = newDecoratedType;
            }
        }

        // See if there are any overloads provided by previous function declarations.
        if (isFunction(decoratedType)) {
            if (FunctionType.isOverloaded(decoratedType)) {
                // Mark all the parameters as accessed.
                node.parameters.forEach((param) => {
                    markParamAccessed(param);
                });
            }

            decoratedType = this.addOverloadsToFunctionType(node, decoratedType);
        }

        this.writeTypeCache(node.name, functionType, EvaluatorFlags.None, /* isIncomplete */ false);
        this.writeTypeCache(node, decoratedType, EvaluatorFlags.None, /* isIncomplete */ false);

        return { functionType, decoratedType };
    }

    adjustParameterAnnotatedType(param: ParameterNode, type: Type): Type {
        // PEP 484 indicates that if a parameter has a default value of 'None'
        // the type checker should assume that the type is optional (i.e. a union
        // of the specified type and 'None'). Skip this step if the type is already
        // optional to avoid losing alias names when combining the types.
        if (
            param.defaultValue?.nodeType === ParseNodeType.Constant &&
            param.defaultValue.constType === KeywordType.None &&
            !isOptionalType(type) &&
            !AnalyzerNodeInfo.getFileInfo(param).diagnosticRuleSet.strictParameterNoneValue
        ) {
            type = combineTypes([type, NoneType.createInstance()]);
        } else if (isTypeVar(type) && param.defaultValue && type.scopeType === TypeVarScopeType.Function) {
            // Handle the case where a default argument type is provided when the
            // parameter is annotated with a "raw" function-scoped type variable, as in:
            //   "def foo(value: T = 3)"
            // In this case, we need to include the default value type in a union.
            const defaultArgType = this.getTypeOfExpression(
                param.defaultValue,
                EvaluatorFlags.ConvertEllipsisToAny,
                type
            ).type;

            if (!isAny(defaultArgType)) {
                type = combineTypes([type, defaultArgType]);
            }
        }

        return type;
    }

    // Attempts to infer an unannotated parameter type from available context.
    inferParameterType(
        functionNode: FunctionNode,
        functionFlags: FunctionTypeFlags,
        paramIndex: number,
        containingClassType: ClassType | undefined
    ) {
        // Is the function a method within a class? If so, see if a base class
        // defines the same method and provides annotations.
        if (containingClassType) {
            if (paramIndex === 0) {
                if ((functionFlags & FunctionTypeFlags.StaticMethod) === 0) {
                    const hasClsParam =
                        (functionFlags & (FunctionTypeFlags.ClassMethod | FunctionTypeFlags.ConstructorMethod)) !== 0;
                    return synthesizeTypeVarForSelfCls(containingClassType, hasClsParam);
                }
            }

            const methodName = functionNode.name.value;

            const baseClassMemberInfo = lookUpClassMember(
                containingClassType,
                methodName,
                ClassMemberLookupFlags.SkipOriginalClass
            );

            if (baseClassMemberInfo) {
                const memberDecls = baseClassMemberInfo.symbol.getDeclarations();
                if (memberDecls.length === 1 && memberDecls[0].type === DeclarationType.Function) {
                    const baseClassMethodNode = memberDecls[0].node;

                    // Does the signature match exactly with the exception of annotations?
                    if (
                        baseClassMethodNode.parameters.length === functionNode.parameters.length &&
                        baseClassMethodNode.parameters.every((param, index) => {
                            const overrideParam = functionNode.parameters[index];
                            return (
                                overrideParam.name?.value === param.name?.value &&
                                overrideParam.category === param.category
                            );
                        })
                    ) {
                        const baseClassParam = baseClassMethodNode.parameters[paramIndex];
                        const baseClassParamAnnotation =
                            baseClassParam.typeAnnotation ?? baseClassParam.typeAnnotationComment;
                        if (baseClassParamAnnotation) {
                            let inferredParamType = this.getTypeOfParameterAnnotation(
                                baseClassParamAnnotation,
                                functionNode.parameters[paramIndex].category
                            );

                            const fileInfo = AnalyzerNodeInfo.getFileInfo(functionNode);
                            if (fileInfo.isInPyTypedPackage && !fileInfo.isStubFile) {
                                inferredParamType = TypeBase.cloneForAmbiguousType(inferredParamType);
                            }

                            return inferredParamType;
                        }
                    }
                }
            }
        }

        // If the parameter has a default argument value, we may be able to infer its
        // type from this information.
        const paramValueExpr = functionNode.parameters[paramIndex].defaultValue;
        if (paramValueExpr) {
            const defaultValueType = this.getTypeOfExpression(paramValueExpr, EvaluatorFlags.ConvertEllipsisToAny).type;

            let inferredParamType: Type | undefined;

            // Is the default value a "None" or an instance of some private class (one
            // whose name starts with an underscore)? If so, we will assume that the
            // value is a singleton sentinel. The actual supported type is going to be
            // a union of this type and Unknown.
            if (
                isNoneInstance(defaultValueType) ||
                (isClassInstance(defaultValueType) && isPrivateOrProtectedName(defaultValueType.details.name))
            ) {
                inferredParamType = combineTypes([defaultValueType, UnknownType.create()]);
            } else {
                // Do not infer certain types like tuple because it's likely to be
                // more restrictive (narrower) than intended.
                if (
                    !isClassInstance(defaultValueType) ||
                    !ClassType.isBuiltIn(defaultValueType, ['tuple', 'list', 'set', 'dict'])
                ) {
                    inferredParamType = this.stripLiteralValue(defaultValueType);
                }
            }

            if (inferredParamType) {
                const fileInfo = AnalyzerNodeInfo.getFileInfo(functionNode);
                if (fileInfo.isInPyTypedPackage && !fileInfo.isStubFile) {
                    inferredParamType = TypeBase.cloneForAmbiguousType(inferredParamType);
                }
            }

            return inferredParamType;
        }

        return undefined;
    }

    // Transforms the parameter type based on its category. If it's a simple parameter,
    // no transform is applied. If it's a var-arg or keyword-arg parameter, the type
    // is wrapped in a List or Dict.
    transformVariadicParamType(node: ParseNode, paramCategory: ParameterCategory, type: Type): Type {
        switch (paramCategory) {
            case ParameterCategory.Simple: {
                return type;
            }

            case ParameterCategory.VarArgList: {
                if (isTypeVar(type) && type.paramSpecAccess) {
                    return type;
                }

                if (isUnpackedClass(type)) {
                    return ClassType.cloneForUnpacked(type, /* isUnpackedTuple */ false);
                }

                if (this._tupleClassType && isInstantiableClass(this._tupleClassType)) {
                    return ClassType.cloneAsInstance(
                        specializeTupleClass(
                            this._tupleClassType,
                            [{ type, isUnbounded: !isVariadicTypeVar(type) }],
                            /* isTypeArgumentExplicit */ true
                        )
                    );
                }

                return UnknownType.create();
            }

            case ParameterCategory.VarArgDictionary: {
                // Leave a ParamSpec alone.
                if (isTypeVar(type) && type.paramSpecAccess) {
                    return type;
                }

                // Is this an unpacked TypedDict? If so, return it unmodified.
                if (isClassInstance(type) && ClassType.isTypedDictClass(type) && type.isUnpacked) {
                    return type;
                }

                // Wrap the type in a dict with str keys.
                const dictType = this.getBuiltInType(node, 'dict');
                const strType = this.getBuiltInObject(node, 'str');

                if (isInstantiableClass(dictType) && isClassInstance(strType)) {
                    return ClassType.cloneAsInstance(
                        ClassType.cloneForSpecialization(dictType, [strType, type], /* isTypeArgumentExplicit */ true)
                    );
                }

                return UnknownType.create();
            }
        }
    }

    // Scans through the decorators to find a few built-in decorators
    // that affect the function flags.
    getFunctionFlagsFromDecorators(node: FunctionNode, isInClass: boolean) {
        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
        let flags = FunctionTypeFlags.None;

        // The "__new__" magic method is not an instance method.
        // It acts as a static method instead.
        if (node.name.value === '__new__' && isInClass) {
            flags |= FunctionTypeFlags.ConstructorMethod;
        }

        // The "__init_subclass__" magic method is not an instance method.
        // It acts an an implicit class method instead.
        if (node.name.value === '__init_subclass__' && isInClass) {
            flags |= FunctionTypeFlags.ClassMethod;
        }

        for (const decoratorNode of node.decorators) {
            // Some stub files (e.g. builtins.pyi) rely on forward declarations of decorators.
            let evaluatorFlags = fileInfo.isStubFile ? EvaluatorFlags.AllowForwardReferences : EvaluatorFlags.None;
            if (decoratorNode.expression.nodeType !== ParseNodeType.Call) {
                evaluatorFlags |= EvaluatorFlags.DoNotSpecialize;
            }

            const decoratorTypeResult = this.getTypeOfExpression(decoratorNode.expression, evaluatorFlags);
            const decoratorType = decoratorTypeResult.type;

            if (isFunction(decoratorType)) {
                if (decoratorType.details.builtInName === 'abstractmethod') {
                    if (isInClass) {
                        flags |= FunctionTypeFlags.AbstractMethod;
                    }
                } else if (decoratorType.details.builtInName === 'final') {
                    flags |= FunctionTypeFlags.Final;
                } else if (decoratorType.details.builtInName === 'override') {
                    flags |= FunctionTypeFlags.Overridden;
                }
            } else if (isInstantiableClass(decoratorType)) {
                if (ClassType.isBuiltIn(decoratorType, 'staticmethod')) {
                    if (isInClass) {
                        flags |= FunctionTypeFlags.StaticMethod;
                    }
                } else if (ClassType.isBuiltIn(decoratorType, 'classmethod')) {
                    if (isInClass) {
                        flags |= FunctionTypeFlags.ClassMethod;
                    }
                }
            }
        }

        return flags;
    }

    // Transforms the input function type into an output type based on the
    // decorator function described by the decoratorNode.
    applyFunctionDecorator(
        inputFunctionType: Type,
        undecoratedType: FunctionType,
        decoratorNode: DecoratorNode,
        functionNode: FunctionNode
    ): Type {
        const fileInfo = AnalyzerNodeInfo.getFileInfo(decoratorNode);

        // Some stub files (e.g. builtins.pyi) rely on forward declarations of decorators.
        let evaluatorFlags = fileInfo.isStubFile ? EvaluatorFlags.AllowForwardReferences : EvaluatorFlags.None;
        if (decoratorNode.expression.nodeType !== ParseNodeType.Call) {
            evaluatorFlags |= EvaluatorFlags.DoNotSpecialize;
        }

        const decoratorTypeResult = this.getTypeOfExpression(decoratorNode.expression, evaluatorFlags);
        const decoratorType = decoratorTypeResult.type;

        // Special-case the "overload" because it has no definition. Older versions of typeshed
        // defined "overload" as an object, but newer versions define it as a function.
        if (
            (isInstantiableClass(decoratorType) && ClassType.isSpecialBuiltIn(decoratorType, 'overload')) ||
            (isFunction(decoratorType) && decoratorType.details.builtInName === 'overload')
        ) {
            if (isFunction(inputFunctionType)) {
                inputFunctionType.details.flags |= FunctionTypeFlags.Overloaded;
                undecoratedType.details.flags |= FunctionTypeFlags.Overloaded;
                return inputFunctionType;
            }
        }

        if (decoratorNode.expression.nodeType === ParseNodeType.Call) {
            const decoratorCallType = this.getTypeOfExpression(
                decoratorNode.expression.leftExpression,
                evaluatorFlags | EvaluatorFlags.DoNotSpecialize
            ).type;

            if (isFunction(decoratorCallType)) {
                if (
                    decoratorCallType.details.name === '__dataclass_transform__' ||
                    decoratorCallType.details.builtInName === 'dataclass_transform'
                ) {
                    undecoratedType.details.decoratorDataClassBehaviors = validateDataClassTransformDecorator(
                        this,
                        decoratorNode.expression
                    );
                    return inputFunctionType;
                }
            }
        }

        let returnType = this.getTypeOfDecorator(decoratorNode, inputFunctionType);

        // Check for some built-in decorator types with known semantics.
        if (isFunction(decoratorType)) {
            if (decoratorType.details.builtInName === 'abstractmethod') {
                return inputFunctionType;
            }

            // Handle property setters and deleters.
            if (decoratorNode.expression.nodeType === ParseNodeType.MemberAccess) {
                const baseType = this.getTypeOfExpression(
                    decoratorNode.expression.leftExpression,
                    evaluatorFlags | EvaluatorFlags.DoNotSpecialize
                ).type;

                if (isProperty(baseType)) {
                    const memberName = decoratorNode.expression.memberName.value;
                    if (memberName === 'setter') {
                        if (isFunction(inputFunctionType)) {
                            validatePropertyMethod(this, inputFunctionType, decoratorNode);
                            return clonePropertyWithSetter(this, baseType, inputFunctionType, functionNode);
                        } else {
                            return inputFunctionType;
                        }
                    } else if (memberName === 'deleter') {
                        if (isFunction(inputFunctionType)) {
                            validatePropertyMethod(this, inputFunctionType, decoratorNode);
                            return clonePropertyWithDeleter(this, baseType, inputFunctionType, functionNode);
                        } else {
                            return inputFunctionType;
                        }
                    }
                }
            }
        } else if (isInstantiableClass(decoratorType)) {
            if (ClassType.isBuiltIn(decoratorType)) {
                switch (decoratorType.details.name) {
                    case 'classmethod':
                    case 'staticmethod': {
                        const requiredFlag =
                            decoratorType.details.name === 'classmethod'
                                ? FunctionTypeFlags.ClassMethod
                                : FunctionTypeFlags.StaticMethod;

                        // If the function isn't currently a class method or static method
                        // (which can happen if the function was wrapped in a decorator),
                        // add the appropriate flag.
                        if (isFunction(inputFunctionType) && (inputFunctionType.details.flags & requiredFlag) === 0) {
                            const newFunction = FunctionType.clone(inputFunctionType);
                            newFunction.details.flags &= ~(
                                FunctionTypeFlags.ConstructorMethod |
                                FunctionTypeFlags.StaticMethod |
                                FunctionTypeFlags.ClassMethod
                            );
                            newFunction.details.flags |= requiredFlag;
                            return newFunction;
                        }

                        return inputFunctionType;
                    }
                }
            }

            // Handle properties and subclasses of properties specially.
            if (ClassType.isPropertyClass(decoratorType)) {
                if (isFunction(inputFunctionType)) {
                    validatePropertyMethod(this, inputFunctionType, decoratorNode);
                    return createProperty(this, decoratorNode, decoratorType, inputFunctionType);
                } else if (isClassInstance(inputFunctionType)) {
                    const boundMethod = this.getBoundMethod(inputFunctionType, '__call__');
                    if (boundMethod && isFunction(boundMethod)) {
                        return createProperty(this, decoratorNode, decoratorType, boundMethod);
                    }

                    return UnknownType.create();
                }
            }
        }

        if (isFunction(inputFunctionType) && isFunction(returnType)) {
            returnType = FunctionType.clone(returnType);

            // Copy the overload flag from the input function type.
            if (FunctionType.isOverloaded(inputFunctionType)) {
                returnType.details.flags |= FunctionTypeFlags.Overloaded;
            }

            // Copy the docstrings from the input function type if the
            // decorator didn't have its own docstring.
            if (!returnType.details.docString) {
                returnType.details.docString = inputFunctionType.details.docString;
            }
        }

        return returnType;
    }

    // Given a function node and the function type associated with it, this
    // method searches for prior function nodes that are marked as @overload
    // and creates an OverloadedFunctionType that includes this function and
    // all previous ones.
    addOverloadsToFunctionType(node: FunctionNode, type: FunctionType): Type {
        let functionDecl: FunctionDeclaration | undefined;
        const decl = AnalyzerNodeInfo.getDeclaration(node);
        if (decl) {
            functionDecl = decl as FunctionDeclaration;
        }
        const symbolWithScope = this.lookUpSymbolRecursive(node, node.name.value, /* honorCodeFlow */ false);
        if (symbolWithScope) {
            const decls = symbolWithScope.symbol.getDeclarations();

            // Find this function's declaration.
            const declIndex = decls.findIndex((decl) => decl === functionDecl);
            if (declIndex > 0) {
                // Evaluate all of the previous function declarations. They will
                // be cached. We do it in this order to avoid a stack overflow due
                // to recursion if there is a large number (1000's) of overloads.
                for (let i = 0; i < declIndex; i++) {
                    const decl = decls[i];
                    if (decl.type === DeclarationType.Function) {
                        this.getTypeOfFunction(decl.node);
                    }
                }

                const overloadedTypes: FunctionType[] = [];

                // Look at the previous declaration's type.
                const prevDecl = decls[declIndex - 1];
                if (prevDecl.type === DeclarationType.Function) {
                    const prevDeclDeclTypeInfo = this.getTypeOfFunction(prevDecl.node);
                    if (prevDeclDeclTypeInfo) {
                        if (isFunction(prevDeclDeclTypeInfo.decoratedType)) {
                            if (FunctionType.isOverloaded(prevDeclDeclTypeInfo.decoratedType)) {
                                overloadedTypes.push(prevDeclDeclTypeInfo.decoratedType);
                            }
                        } else if (isOverloadedFunction(prevDeclDeclTypeInfo.decoratedType)) {
                            // If the previous declaration was itself an overloaded function,
                            // copy the entries from it.
                            appendArray(overloadedTypes, prevDeclDeclTypeInfo.decoratedType.overloads);
                        }
                    }
                }

                overloadedTypes.push(type);

                if (overloadedTypes.length === 1) {
                    return overloadedTypes[0];
                }

                // Create a new overloaded type that copies the contents of the previous
                // one and adds a new function.
                const newOverload = OverloadedFunctionType.create(overloadedTypes);

                const prevOverload = overloadedTypes[overloadedTypes.length - 2];
                const isPrevOverloadAbstract = FunctionType.isAbstractMethod(prevOverload);
                const isCurrentOverloadAbstract = FunctionType.isAbstractMethod(type);

                if (isPrevOverloadAbstract !== isCurrentOverloadAbstract) {
                    this.addDiagnostic(
                        AnalyzerNodeInfo.getFileInfo(node).diagnosticRuleSet.reportGeneralTypeIssues,
                        DiagnosticRule.reportGeneralTypeIssues,
                        Localizer.Diagnostic.overloadAbstractMismatch().format({ name: node.name.value }),
                        node.name
                    );
                }

                return newOverload;
            }
        }

        return type;
    }

    createAsyncFunction(node: FunctionNode, functionType: FunctionType): FunctionType {
        // Clone the original function and replace its return type with an
        // Awaitable[<returnType>].
        const awaitableFunctionType = FunctionType.clone(functionType);

        if (functionType.details.declaredReturnType) {
            awaitableFunctionType.details.declaredReturnType = this.createAwaitableReturnType(
                node,
                functionType.details.declaredReturnType,
                FunctionType.isGenerator(functionType)
            );
        }

        // Note that the inferred type, once lazily computed, needs to wrap the
        // resulting type in an awaitable.
        awaitableFunctionType.details.flags |= FunctionTypeFlags.WrapReturnTypeInAwait;

        return awaitableFunctionType;
    }

    createAwaitableReturnType(node: ParseNode, returnType: Type, isGenerator: boolean): Type {
        let awaitableReturnType: Type | undefined;

        if (isClassInstance(returnType)) {
            if (ClassType.isBuiltIn(returnType)) {
                if (returnType.details.name === 'Generator') {
                    // If the return type is a Generator, change it to an AsyncGenerator.
                    const asyncGeneratorType = this.getTypingType(node, 'AsyncGenerator');
                    if (asyncGeneratorType && isInstantiableClass(asyncGeneratorType)) {
                        const typeArgs: Type[] = [];
                        const generatorTypeArgs = returnType.typeArguments;
                        if (generatorTypeArgs && generatorTypeArgs.length > 0) {
                            typeArgs.push(generatorTypeArgs[0]);
                        }
                        if (generatorTypeArgs && generatorTypeArgs.length > 1) {
                            typeArgs.push(generatorTypeArgs[1]);
                        }
                        awaitableReturnType = ClassType.cloneAsInstance(
                            ClassType.cloneForSpecialization(
                                asyncGeneratorType,
                                typeArgs,
                                /* isTypeArgumentExplicit */ true
                            )
                        );
                    }
                } else if (
                    ['AsyncGenerator', 'AsyncIterator', 'AsyncIterable'].some(
                        (name) => name === returnType.details.name
                    )
                ) {
                    // If it's already an AsyncGenerator, AsyncIterator or AsyncIterable,
                    // leave it as is.
                    awaitableReturnType = returnType;
                }
            }
        }

        if (!awaitableReturnType || !isGenerator) {
            // Wrap in a Coroutine, which is a subclass of Awaitable.
            const coroutineType = this.getTypingType(node, 'Coroutine');
            if (coroutineType && isInstantiableClass(coroutineType)) {
                awaitableReturnType = ClassType.cloneAsInstance(
                    ClassType.cloneForSpecialization(
                        coroutineType,
                        [AnyType.create(), AnyType.create(), returnType],
                        /* isTypeArgumentExplicit */ true
                    )
                );
            } else {
                awaitableReturnType = UnknownType.create();
            }
        }

        return awaitableReturnType;
    }

    inferFunctionReturnType(node: FunctionNode, isAbstract: boolean): TypeResult | undefined {
        const returnAnnotation = node.returnTypeAnnotation || node.functionAnnotationComment?.returnTypeAnnotation;

        // This shouldn't be called if there is a declared return type, but it
        // can happen if there are unexpected cycles between decorators and
        // classes that they decorate. We'll just return an undefined type
        // in this case.
        if (returnAnnotation) {
            return undefined;
        }

        // Is this type already cached?
        let inferredReturnType = this.readTypeCache(node.suite, EvaluatorFlags.None);
        let isIncomplete = false;

        if (inferredReturnType) {
            return { type: inferredReturnType, isIncomplete };
        }

        if (
            this._functionRecursionMap.has(node.id) ||
            this._functionRecursionMap.size >= maxInferFunctionReturnRecursionCount
        ) {
            inferredReturnType = UnknownType.create();
            isIncomplete = true;
        } else {
            this._functionRecursionMap.add(node.id);

            try {
                let functionDecl: FunctionDeclaration | undefined;
                const decl = AnalyzerNodeInfo.getDeclaration(node);
                if (decl) {
                    functionDecl = decl as FunctionDeclaration;
                }

                const functionNeverReturns = !this.isAfterNodeReachable(node);
                const implicitlyReturnsNone = this.isAfterNodeReachable(node.suite);

                // Infer the return type based on all of the return statements in the function's body.
                if (AnalyzerNodeInfo.getFileInfo(node).isStubFile) {
                    // If a return type annotation is missing in a stub file, assume
                    // it's an "unknown" type. In normal source files, we can infer the
                    // type from the implementation.
                    inferredReturnType = UnknownType.create();
                } else {
                    if (functionNeverReturns) {
                        // If the function always raises and never returns, assume a "NoReturn" type.
                        // Skip this for abstract methods which often are implemented with "raise
                        // NotImplementedError()".
                        if (isAbstract || this.methodAlwaysRaisesNotImplemented(functionDecl)) {
                            inferredReturnType = UnknownType.create();
                        } else {
                            inferredReturnType = NeverType.createNoReturn();
                        }
                    } else {
                        const inferredReturnTypes: Type[] = [];
                        if (functionDecl?.returnStatements) {
                            functionDecl.returnStatements.forEach((returnNode) => {
                                if (this.isNodeReachable(returnNode)) {
                                    if (returnNode.returnExpression) {
                                        const returnTypeResult = this.getTypeOfExpression(returnNode.returnExpression);
                                        if (returnTypeResult.isIncomplete) {
                                            isIncomplete = true;
                                        }

                                        inferredReturnTypes.push(returnTypeResult.type ?? UnknownType.create());
                                    } else {
                                        inferredReturnTypes.push(NoneType.createInstance());
                                    }
                                }
                            });
                        }

                        if (!functionNeverReturns && implicitlyReturnsNone) {
                            inferredReturnTypes.push(NoneType.createInstance());
                        }

                        inferredReturnType = combineTypes(inferredReturnTypes);

                        // Remove any unbound values since those would generate an exception
                        // before being returned.
                        inferredReturnType = removeUnbound(inferredReturnType);
                    }

                    // Is it a generator?
                    if (functionDecl?.isGenerator) {
                        const inferredYieldTypes: Type[] = [];
                        let useAwaitableGenerator = false;

                        if (functionDecl.yieldStatements) {
                            functionDecl.yieldStatements.forEach((yieldNode) => {
                                if (this.isNodeReachable(yieldNode)) {
                                    if (yieldNode.nodeType === ParseNodeType.YieldFrom) {
                                        const iteratorTypeResult = this.getTypeOfExpression(yieldNode.expression);
                                        if (
                                            isClassInstance(iteratorTypeResult.type) &&
                                            ClassType.isBuiltIn(iteratorTypeResult.type, 'Coroutine')
                                        ) {
                                            // Handle old-style (pre-await) Coroutines.
                                            inferredYieldTypes.push();
                                            useAwaitableGenerator = true;
                                        } else {
                                            const yieldType = this.getTypeOfIterator(
                                                iteratorTypeResult,
                                                /* isAsync */ false,
                                                yieldNode
                                            )?.type;
                                            inferredYieldTypes.push(yieldType ?? UnknownType.create());
                                        }
                                    } else {
                                        if (yieldNode.expression) {
                                            const yieldType = this.getTypeOfExpression(yieldNode.expression).type;
                                            inferredYieldTypes.push(yieldType ?? UnknownType.create());
                                        } else {
                                            inferredYieldTypes.push(NoneType.createInstance());
                                        }
                                    }
                                }
                            });
                        }

                        if (inferredYieldTypes.length === 0) {
                            inferredYieldTypes.push(NoneType.createInstance());
                        }
                        const inferredYieldType = combineTypes(inferredYieldTypes);

                        // Inferred yield types need to be wrapped in a Generator or
                        // AwaitableGenerator to produce the final result.
                        const generatorType = this.getTypingType(
                            node,
                            useAwaitableGenerator ? 'AwaitableGenerator' : 'Generator'
                        );

                        if (generatorType && isInstantiableClass(generatorType)) {
                            const typeArgs: Type[] = [];

                            if (useAwaitableGenerator) {
                                typeArgs.push(AnyType.create());
                            }

                            typeArgs.push(
                                inferredYieldType,
                                NoneType.createInstance(),
                                isNever(inferredReturnType) ? NoneType.createInstance() : inferredReturnType
                            );

                            inferredReturnType = ClassType.cloneAsInstance(
                                ClassType.cloneForSpecialization(
                                    generatorType,
                                    typeArgs,
                                    /* isTypeArgumentExplicit */ true
                                )
                            );
                        } else {
                            inferredReturnType = UnknownType.create();
                        }
                    }
                }

                this.writeTypeCache(node.suite, inferredReturnType, EvaluatorFlags.None, isIncomplete);
            } finally {
                this._functionRecursionMap.delete(node.id);
            }
        }

        return inferredReturnType ? { type: inferredReturnType, isIncomplete } : undefined;
    }

    // Determines whether the function consists only of a "raise" statement
    // and the exception type raised is a NotImplementedError. This is commonly
    // used for abstract methods that
    methodAlwaysRaisesNotImplemented(functionDecl?: FunctionDeclaration): boolean {
        if (
            !functionDecl ||
            !functionDecl.isMethod ||
            functionDecl.returnStatements ||
            functionDecl.yieldStatements ||
            !functionDecl.raiseStatements
        ) {
            return false;
        }

        for (const raiseStatement of functionDecl.raiseStatements) {
            if (!raiseStatement.typeExpression || raiseStatement.valueExpression) {
                return false;
            }
            const raiseType = this.getTypeOfExpression(raiseStatement.typeExpression).type;
            const classType = isInstantiableClass(raiseType)
                ? raiseType
                : isClassInstance(raiseType)
                ? raiseType
                : undefined;
            if (!classType || !ClassType.isBuiltIn(classType, 'NotImplementedError')) {
                return false;
            }
        }

        return true;
    }

    evaluateTypesForForStatement(node: ForNode): void {
        if (this.readTypeCache(node, EvaluatorFlags.None)) {
            return;
        }

        const iteratorTypeResult = this.getTypeOfExpression(node.iterableExpression);
        const iteratedType =
            this.getTypeOfIterator(iteratorTypeResult, !!node.isAsync, node.iterableExpression)?.type ??
            UnknownType.create();

        this.assignTypeToExpression(
            node.targetExpression,
            iteratedType,
            !!iteratorTypeResult.isIncomplete,
            node.targetExpression
        );

        this.writeTypeCache(node, iteratedType, EvaluatorFlags.None, !!iteratorTypeResult.isIncomplete);
    }

    evaluateTypesForExceptStatement(node: ExceptNode): void {
        // This should be called only if the except node has a target exception.
        assert(node.typeExpression !== undefined);

        if (this.readTypeCache(node, EvaluatorFlags.None)) {
            return;
        }

        const exceptionTypeResult = this.getTypeOfExpression(node.typeExpression!);
        const exceptionTypes = exceptionTypeResult.type;

        const getExceptionType = (exceptionType: Type, errorNode: ExpressionNode) => {
            exceptionType = this.makeTopLevelTypeVarsConcrete(exceptionType);

            if (isAnyOrUnknown(exceptionType)) {
                return exceptionType;
            }

            if (isInstantiableClass(exceptionType)) {
                return ClassType.cloneAsInstance(exceptionType);
            }

            if (isClassInstance(exceptionType)) {
                const iterableType =
                    this.getTypeOfIterator(
                        { type: exceptionType, isIncomplete: exceptionTypeResult.isIncomplete },
                        /* isAsync */ false,
                        errorNode
                    )?.type ?? UnknownType.create();

                return mapSubtypes(iterableType, (subtype) => {
                    if (isAnyOrUnknown(subtype)) {
                        return subtype;
                    }

                    return UnknownType.create();
                });
            }

            return UnknownType.create();
        };

        let targetType = mapSubtypes(exceptionTypes, (subType) => {
            // If more than one type was specified for the exception, we'll receive
            // a specialized tuple object here.
            const tupleType = getSpecializedTupleType(subType);
            if (tupleType && tupleType.tupleTypeArguments) {
                const entryTypes = tupleType.tupleTypeArguments.map((t) => {
                    return getExceptionType(t.type, node.typeExpression!);
                });
                return combineTypes(entryTypes);
            }

            return getExceptionType(subType, node.typeExpression!);
        });

        // If this is an except group, wrap the exception type in an ExceptionGroup.
        if (node.isExceptGroup) {
            targetType = this.getBuiltInObject(node, 'ExceptionGroup', [targetType]);
        }

        if (node.name) {
            this.assignTypeToExpression(node.name, targetType, /* isIncomplete */ false, node.name);
        }

        this.writeTypeCache(node, targetType, EvaluatorFlags.None, /* isIncomplete */ false);
    }

    evaluateTypesForWithStatement(node: WithItemNode): void {
        if (this.readTypeCache(node, EvaluatorFlags.None)) {
            return;
        }

        const exprTypeResult = this.getTypeOfExpression(node.expression);
        let exprType = exprTypeResult.type;
        const isAsync = node.parent && node.parent.nodeType === ParseNodeType.With && !!node.parent.isAsync;

        if (isOptionalType(exprType)) {
            const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
            this.addDiagnostic(
                fileInfo.diagnosticRuleSet.reportOptionalContextManager,
                DiagnosticRule.reportOptionalContextManager,
                Localizer.Diagnostic.noneNotUsableWith(),
                node.expression
            );
            exprType = removeNoneFromUnion(exprType);
        }

        // Verify that the target has an __enter__ or __aenter__ method defined.
        const enterMethodName = isAsync ? '__aenter__' : '__enter__';
        const scopedType = mapSubtypes(exprType, (subtype) => {
            subtype = this.makeTopLevelTypeVarsConcrete(subtype);

            if (isAnyOrUnknown(subtype)) {
                return subtype;
            }

            const additionalHelp = new DiagnosticAddendum();

            if (isClass(subtype)) {
                let enterType = this.getTypeOfMagicMethodReturn(
                    subtype,
                    [],
                    enterMethodName,
                    node.expression,
                    /* expectedType */ undefined
                );

                if (enterType) {
                    // For "async while", an implicit "await" is performed.
                    if (isAsync) {
                        enterType = this.getTypeOfAwaitable(enterType, node.expression);
                    }

                    return enterType;
                }

                if (!isAsync) {
                    if (
                        this.getTypeOfMagicMethodReturn(
                            subtype,
                            [],
                            '__aenter__',
                            node.expression,
                            /* expectedType */ undefined
                        )
                    ) {
                        additionalHelp.addMessage(Localizer.DiagnosticAddendum.asyncHelp());
                    }
                }
            }

            const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
            this.addDiagnostic(
                fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                DiagnosticRule.reportGeneralTypeIssues,
                Localizer.Diagnostic.typeNotUsableWith().format({
                    type: this.printType(subtype),
                    method: enterMethodName,
                }) + additionalHelp.getString(),
                node.expression
            );
            return UnknownType.create();
        });

        // Verify that the target has an __exit__ or __aexit__ method defined.
        const exitMethodName = isAsync ? '__aexit__' : '__exit__';
        doForEachSubtype(exprType, (subtype) => {
            subtype = this.makeTopLevelTypeVarsConcrete(subtype);

            if (isAnyOrUnknown(subtype)) {
                return;
            }

            if (isClass(subtype)) {
                const anyArg: TypeResult = { type: AnyType.create() };
                const exitType = this.getTypeOfMagicMethodReturn(
                    subtype,
                    [anyArg, anyArg, anyArg],
                    exitMethodName,
                    node.expression,
                    /* expectedType */ undefined
                );

                if (exitType) {
                    return;
                }
            }

            const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
            this.addDiagnostic(
                fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                DiagnosticRule.reportGeneralTypeIssues,
                Localizer.Diagnostic.typeNotUsableWith().format({
                    type: this.printType(subtype),
                    method: exitMethodName,
                }),
                node.expression
            );
        });

        if (node.target) {
            this.assignTypeToExpression(node.target, scopedType, !!exprTypeResult.isIncomplete, node.target);
        }

        this.writeTypeCache(node, scopedType, EvaluatorFlags.None, !!exprTypeResult.isIncomplete);
    }

    evaluateTypesForImportAs(node: ImportAsNode): void {
        if (this.readTypeCache(node, EvaluatorFlags.None)) {
            return;
        }

        let symbolNameNode: NameNode;
        if (node.alias) {
            // The symbol name is defined by the alias.
            symbolNameNode = node.alias;
        } else {
            // There was no alias, so we need to use the first element of
            // the name parts as the symbol.
            symbolNameNode = node.module.nameParts[0];
        }

        if (!symbolNameNode) {
            // This can happen in certain cases where there are parse errors.
            return;
        }

        // Look up the symbol to find the alias declaration.
        let symbolType = this.getAliasedSymbolTypeForName(node, symbolNameNode.value) ?? UnknownType.create();

        // Is there a cached module type associated with this node? If so, use
        // it instead of the type we just created.
        const cachedModuleType = this.readTypeCache(node, EvaluatorFlags.None) as ModuleType;
        if (cachedModuleType && isModule(cachedModuleType) && symbolType) {
            if (isTypeSame(symbolType, cachedModuleType)) {
                symbolType = cachedModuleType;
            }
        }

        this.assignTypeToNameNode(
            symbolNameNode,
            symbolType,
            /* isIncomplete */ false,
            /* ignoreEmptyContainers */ false
        );

        this.writeTypeCache(node, symbolType, EvaluatorFlags.None, /* isIncomplete */ false);
    }

    evaluateTypesForImportFromAs(node: ImportFromAsNode): void {
        if (this.readTypeCache(node, EvaluatorFlags.None)) {
            return;
        }

        const aliasNode = node.alias || node.name;
        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);

        // If this is a redundant form of an import, assume it is an intentional
        // export and mark the symbol as accessed.
        if (node.alias?.value === node.name.value) {
            const symbolInScope = this.lookUpSymbolRecursive(node, node.name.value, /* honorCodeFlow */ true);
            if (symbolInScope) {
                this.setSymbolAccessed(fileInfo, symbolInScope.symbol, node);
            }
        }

        let symbolType = this.getAliasedSymbolTypeForName(node, aliasNode.value);
        if (!symbolType) {
            const parentNode = node.parent as ImportFromNode;
            assert(parentNode && parentNode.nodeType === ParseNodeType.ImportFrom);
            assert(!parentNode.isWildcardImport);

            const importInfo = AnalyzerNodeInfo.getImportInfo(parentNode.module);
            if (importInfo && importInfo.isImportFound && !importInfo.isNativeLib) {
                const resolvedPath = importInfo.resolvedPaths[importInfo.resolvedPaths.length - 1];

                const importLookupInfo = this._importLookup(resolvedPath);
                let reportError = false;

                // If we were able to resolve the import, report the error as
                // an unresolved symbol.
                if (importLookupInfo) {
                    reportError = true;

                    // Handle PEP 562 support for module-level __getattr__ function,
                    // introduced in Python 3.7.
                    if (fileInfo.executionEnvironment.pythonVersion >= PythonVersion.V3_7 || fileInfo.isStubFile) {
                        const getAttrSymbol = importLookupInfo.symbolTable.get('__getattr__');
                        if (getAttrSymbol) {
                            const getAttrType = this.getEffectiveTypeOfSymbol(getAttrSymbol);
                            if (isFunction(getAttrType)) {
                                symbolType = this.getFunctionEffectiveReturnType(getAttrType);
                                reportError = false;
                            }
                        }
                    }
                } else if (!resolvedPath) {
                    // This corresponds to the "from . import a" form.
                    reportError = true;
                }

                if (reportError) {
                    this.addDiagnostic(
                        fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                        DiagnosticRule.reportGeneralTypeIssues,
                        Localizer.Diagnostic.importSymbolUnknown().format({ name: node.name.value }),
                        node.name
                    );
                }
            }

            if (!symbolType) {
                symbolType = UnknownType.create();
            }
        }

        this.assignTypeToNameNode(aliasNode, symbolType, /* isIncomplete */ false, /* ignoreEmptyContainers */ false);
        this.writeTypeCache(node, symbolType, EvaluatorFlags.None, /* isIncomplete */ false);
    }

    evaluateTypesForMatchStatement(node: MatchNode): void {
        if (this.readTypeCache(node, EvaluatorFlags.None)) {
            return;
        }

        const subjectTypeResult = this.getTypeOfExpression(node.subjectExpression);
        let subjectType = subjectTypeResult.type;

        // Apply negative narrowing for each of the cases that doesn't have a guard statement.
        for (const caseStatement of node.cases) {
            if (!caseStatement.guardExpression) {
                subjectType = narrowTypeBasedOnPattern(
                    this,
                    subjectType,
                    caseStatement.pattern,
                    /* isPositiveTest */ false
                );
            }
        }

        this.writeTypeCache(node, subjectType, EvaluatorFlags.None, !!subjectTypeResult.isIncomplete);
    }

    evaluateTypesForCaseStatement(node: CaseNode): void {
        if (this.readTypeCache(node, EvaluatorFlags.None)) {
            return;
        }

        if (!node.parent || node.parent.nodeType !== ParseNodeType.Match) {
            fail('Expected parent of case statement to be match statement');
            return;
        }

        const subjectTypeResult = this.getTypeOfExpression(node.parent.subjectExpression);
        let subjectType = subjectTypeResult.type;

        // Apply negative narrowing for each of the cases prior to the current one
        // except for those that have a guard expression.
        for (const caseStatement of node.parent.cases) {
            if (caseStatement === node) {
                break;
            }
            if (!caseStatement.guardExpression) {
                subjectType = narrowTypeBasedOnPattern(
                    this,
                    subjectType,
                    caseStatement.pattern,
                    /* isPositiveTest */ false
                );
            }
        }

        // Determine if the pre-narrowed subject type contains an object.
        let subjectIsObject = false;
        doForEachSubtype(this.makeTopLevelTypeVarsConcrete(subjectType), (subtype) => {
            if (isClassInstance(subtype) && ClassType.isBuiltIn(subtype, 'object')) {
                subjectIsObject = true;
            }
        });

        // Apply positive narrowing for the current case statement.
        subjectType = narrowTypeBasedOnPattern(this, subjectType, node.pattern, /* isPositiveTest */ true);

        assignTypeToPatternTargets(this, subjectType, !!subjectTypeResult.isIncomplete, subjectIsObject, node.pattern);

        this.writeTypeCache(node, subjectType, EvaluatorFlags.None, !!subjectTypeResult.isIncomplete);
    }

    evaluateTypesForImportFrom(node: ImportFromNode): void {
        if (this.readTypeCache(node, EvaluatorFlags.None)) {
            return;
        }

        // Use the first element of the name parts as the symbol.
        const symbolNameNode = node.module.nameParts[0];

        // Look up the symbol to find the alias declaration.
        let symbolType = this.getAliasedSymbolTypeForName(node, symbolNameNode.value);
        if (!symbolType) {
            return;
        }

        // Is there a cached module type associated with this node? If so, use
        // it instead of the type we just created.
        const cachedModuleType = this.readTypeCache(node, EvaluatorFlags.None) as ModuleType;
        if (cachedModuleType && isModule(cachedModuleType) && symbolType) {
            if (isTypeSame(symbolType, cachedModuleType)) {
                symbolType = cachedModuleType;
            }
        }

        this.assignTypeToNameNode(
            symbolNameNode,
            symbolType,
            /* isIncomplete */ false,
            /* ignoreEmptyContainers */ false
        );

        this.writeTypeCache(node, symbolType, EvaluatorFlags.None, /* isIncomplete */ false);
    }

    evaluateTypesForTypeAnnotationNode(node: TypeAnnotationNode) {
        // If this node is part of an assignment statement, use specialized
        // logic that performs bidirectional inference and assignment
        // type narrowing.
        if (node.parent?.nodeType === ParseNodeType.Assignment) {
            this.evaluateTypesForAssignmentStatement(node.parent);
        } else {
            const annotationType = this.getTypeOfAnnotation(node.typeAnnotation, {
                isVariableAnnotation: true,
                allowFinal: ParseTreeUtils.isFinalAllowedForAssignmentTarget(node.valueExpression),
                allowClassVar: ParseTreeUtils.isClassVarAllowedForAssignmentTarget(node.valueExpression),
            });

            this.writeTypeCache(node.valueExpression, annotationType, EvaluatorFlags.None, /* isIncomplete */ false);
        }
    }

    getAliasedSymbolTypeForName(
        node: ImportAsNode | ImportFromAsNode | ImportFromNode,
        name: string
    ): Type | undefined {
        const symbolWithScope = this.lookUpSymbolRecursive(node, name, /* honorCodeFlow */ true);
        if (!symbolWithScope) {
            return undefined;
        }

        // Normally there will be at most one decl associated with the import node, but
        // there can be multiple in the case of the "from .X import X" statement. In such
        // case, we want to choose the last declaration.
        const filteredDecls = symbolWithScope.symbol
            .getDeclarations()
            .filter(
                (decl) => ParseTreeUtils.isNodeContainedWithin(node, decl.node) && decl.type === DeclarationType.Alias
            );
        let aliasDecl = filteredDecls.length > 0 ? filteredDecls[filteredDecls.length - 1] : undefined;

        // If we didn't find an exact match, look for any alias associated with
        // this symbol. In cases where we have multiple ImportAs nodes that share
        // the same first-part name (e.g. "import asyncio" and "import asyncio.tasks"),
        // we may not find the declaration associated with this node.
        if (!aliasDecl) {
            aliasDecl = symbolWithScope.symbol.getDeclarations().find((decl) => decl.type === DeclarationType.Alias);
        }

        if (!aliasDecl) {
            return undefined;
        }

        assert(aliasDecl.type === DeclarationType.Alias);

        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);

        // Try to resolve the alias while honoring external visibility.
        const resolvedAliasInfo = this.resolveAliasDeclarationWithInfo(
            aliasDecl,
            /* resolveLocalNames */ true,
            /* allowExternallyHiddenAccess */ fileInfo.isStubFile
        );

        if (!resolvedAliasInfo) {
            return undefined;
        }

        if (!resolvedAliasInfo.declaration) {
            return this._evaluatorOptions.evaluateUnknownImportsAsAny ? AnyType.create() : UnknownType.create();
        }

        if (node.nodeType === ParseNodeType.ImportFromAs) {
            if (resolvedAliasInfo.isPrivate) {
                this.addDiagnostic(
                    fileInfo.diagnosticRuleSet.reportPrivateUsage,
                    DiagnosticRule.reportPrivateUsage,
                    Localizer.Diagnostic.privateUsedOutsideOfModule().format({
                        name: node.name.value,
                    }),
                    node.name
                );
            }

            if (resolvedAliasInfo.privatePyTypedImporter) {
                const diag = new DiagnosticAddendum();
                if (resolvedAliasInfo.privatePyTypedImported) {
                    diag.addMessage(
                        Localizer.DiagnosticAddendum.privateImportFromPyTypedSource().format({
                            module: resolvedAliasInfo.privatePyTypedImported,
                        })
                    );
                }
                this.addDiagnostic(
                    fileInfo.diagnosticRuleSet.reportPrivateImportUsage,
                    DiagnosticRule.reportPrivateImportUsage,
                    Localizer.Diagnostic.privateImportFromPyTypedModule().format({
                        name: node.name.value,
                        module: resolvedAliasInfo.privatePyTypedImporter,
                    }) + diag.getString(),
                    node.name
                );
            }
        }

        return this.getInferredTypeOfDeclaration(symbolWithScope.symbol, aliasDecl);
    }

    // In some cases, an expression must be evaluated in the context of another
    // expression or statement that contains it. This contextual evaluation
    // allows for bidirectional type evaluation.
    evaluateTypesForExpressionInContext(node: ExpressionNode): void {
        // Check for a couple of special cases where the node is a NameNode but
        // is technically not part of an expression. We'll handle these here so
        // callers don't need to include special-case logic.
        if (node.nodeType === ParseNodeType.Name && node.parent) {
            if (node.parent.nodeType === ParseNodeType.Function && node.parent.name === node) {
                this.getTypeOfFunction(node.parent);
                return;
            }

            if (node.parent.nodeType === ParseNodeType.Class && node.parent.name === node) {
                this.getTypeOfClass(node.parent);
                return;
            }

            if (node.parent.nodeType === ParseNodeType.TypeAlias && node.parent.name === node) {
                this.getTypeOfTypeAlias(node.parent);
                return;
            }

            if (node.parent.nodeType === ParseNodeType.Global || node.parent.nodeType === ParseNodeType.Nonlocal) {
                // For global and nonlocal statements, allow forward references so
                // we don't use code flow during symbol lookups.
                this.getTypeOfExpression(node, EvaluatorFlags.AllowForwardReferences);
                return;
            }

            if (node.parent.nodeType === ParseNodeType.ModuleName) {
                // A name within a module name isn't an expression,
                // so there's nothing we can evaluate here.
                return;
            }
        }

        // If the expression is part of a type annotation, we need to evaluate
        // it with special evaluation flags.
        const annotationNode = ParseTreeUtils.getParentAnnotationNode(node);
        if (annotationNode) {
            // Annotations need to be evaluated with specialized evaluation flags.
            const annotationParent = annotationNode.parent;
            assert(annotationParent !== undefined);

            if (annotationParent.nodeType === ParseNodeType.Assignment) {
                if (annotationNode === annotationParent.typeAnnotationComment) {
                    this.getTypeOfAnnotation(annotationNode, {
                        isVariableAnnotation: true,
                        allowFinal: ParseTreeUtils.isFinalAllowedForAssignmentTarget(annotationParent.leftExpression),
                        allowClassVar: ParseTreeUtils.isClassVarAllowedForAssignmentTarget(
                            annotationParent.leftExpression
                        ),
                    });
                } else {
                    this.evaluateTypesForAssignmentStatement(annotationParent);
                }
                return;
            }

            if (annotationParent.nodeType === ParseNodeType.TypeAnnotation) {
                this.evaluateTypesForTypeAnnotationNode(annotationParent);
                return;
            }

            if (
                annotationParent.nodeType === ParseNodeType.Function &&
                annotationNode === annotationParent.returnTypeAnnotation
            ) {
                this.getTypeOfAnnotation(annotationNode, {
                    associateTypeVarsWithScope: true,
                    disallowRecursiveTypeAlias: true,
                });
                return;
            }

            this.getTypeOfAnnotation(annotationNode, {
                isVariableAnnotation: annotationNode.parent?.nodeType === ParseNodeType.TypeAnnotation,
                allowUnpackedTuple:
                    annotationParent.nodeType === ParseNodeType.Parameter &&
                    annotationParent.category === ParameterCategory.VarArgList,
                allowUnpackedTypedDict:
                    annotationParent.nodeType === ParseNodeType.Parameter &&
                    annotationParent.category === ParameterCategory.VarArgDictionary,
            });
            return;
        }

        // See if the expression is part of a pattern used in a case statement.
        const possibleCaseNode = ParseTreeUtils.getParentNodeOfType(node, ParseNodeType.Case);
        if (possibleCaseNode) {
            const caseNode = possibleCaseNode as CaseNode;
            if (ParseTreeUtils.isNodeContainedWithin(node, caseNode.pattern)) {
                this.evaluateTypesForCaseStatement(caseNode);
                return;
            }
        }

        // Scan up the parse tree until we find a node that doesn't
        // require any context to be evaluated.
        let nodeToEvaluate: ExpressionNode = node;
        let flags = EvaluatorFlags.None;

        while (true) {
            // If we're within an argument node in a call or index expression, skip
            // all of the nodes between because the entire argument expression
            // needs to be evaluated contextually.
            const argumentNode = ParseTreeUtils.getParentNodeOfType(nodeToEvaluate, ParseNodeType.Argument);
            if (argumentNode && argumentNode !== nodeToEvaluate) {
                assert(argumentNode.parent !== undefined);

                if (
                    argumentNode.parent.nodeType === ParseNodeType.Call ||
                    argumentNode.parent.nodeType === ParseNodeType.Index
                ) {
                    nodeToEvaluate = argumentNode.parent;
                    continue;
                }
            }

            let parent = nodeToEvaluate.parent;
            if (!parent) {
                break;
            }

            // If this is the target of an assignment expression, evaluate the
            // assignment expression node instead.
            if (parent.nodeType === ParseNodeType.AssignmentExpression && nodeToEvaluate === parent.name) {
                nodeToEvaluate = parent;
                continue;
            }

            // The left expression of a call or member access expression is not contextual.
            if (parent.nodeType === ParseNodeType.Call || parent.nodeType === ParseNodeType.MemberAccess) {
                if (nodeToEvaluate === parent.leftExpression) {
                    // Handle the special case where the LHS is a call to super().
                    if (
                        nodeToEvaluate.nodeType === ParseNodeType.Call &&
                        nodeToEvaluate.leftExpression.nodeType === ParseNodeType.Name &&
                        nodeToEvaluate.leftExpression.value === 'super'
                    ) {
                        nodeToEvaluate = parent;
                        continue;
                    }

                    flags = EvaluatorFlags.DoNotSpecialize;
                    break;
                }
            } else if (parent.nodeType === ParseNodeType.Index) {
                // The base expression of an index expression is not contextual.
                if (nodeToEvaluate === parent.baseExpression) {
                    flags = EvaluatorFlags.DoNotSpecialize;
                    break;
                }
            } else if (parent.nodeType === ParseNodeType.StringList && nodeToEvaluate === parent.typeAnnotation) {
                // Forward-declared type annotation expressions need to be be evaluated
                // in context so they have the appropriate flags set. Most of these cases
                // will have been detected above when calling getParentAnnotationNode,
                // but TypeAlias expressions are not handled there.
                nodeToEvaluate = parent;
                continue;
            } else {
                // Check for expression types that are always contextual.
                if (
                    nodeToEvaluate.nodeType !== ParseNodeType.Dictionary &&
                    nodeToEvaluate.nodeType !== ParseNodeType.List &&
                    nodeToEvaluate.nodeType !== ParseNodeType.Lambda &&
                    nodeToEvaluate.nodeType !== ParseNodeType.Set &&
                    nodeToEvaluate.nodeType !== ParseNodeType.Tuple &&
                    nodeToEvaluate.nodeType !== ParseNodeType.Unpack &&
                    nodeToEvaluate.nodeType !== ParseNodeType.ListComprehension
                ) {
                    break;
                }
            }

            if (!isExpressionNode(parent)) {
                // If we've hit a non-expression node, we generally want to
                // stop. However, there are a few special "pass through"
                // node types that we can skip over to get to a known
                // expression node.
                if (
                    parent.nodeType === ParseNodeType.DictionaryKeyEntry ||
                    parent.nodeType === ParseNodeType.DictionaryExpandEntry ||
                    parent.nodeType === ParseNodeType.ListComprehensionFor ||
                    parent.nodeType === ParseNodeType.ListComprehensionIf
                ) {
                    assert(parent.parent !== undefined && isExpressionNode(parent.parent));
                    parent = parent.parent;
                } else if (parent.nodeType === ParseNodeType.Parameter) {
                    assert(parent.parent !== undefined);

                    // Parameters are contextual for lambdas.
                    if (parent.parent.nodeType === ParseNodeType.Lambda) {
                        parent = parent.parent;
                    } else {
                        break;
                    }
                } else {
                    break;
                }
            }

            nodeToEvaluate = parent;
        }

        const parent = nodeToEvaluate.parent!;
        assert(parent !== undefined);

        switch (parent.nodeType) {
            case ParseNodeType.Del: {
                this.verifyDeleteExpression(nodeToEvaluate);
                return;
            }

            case ParseNodeType.TypeParameter: {
                // If this is the name node within a type parameter list, see if it's a type alias
                // definition. If so, we need to evaluate the type alias contextually.
                if (
                    nodeToEvaluate === parent.name &&
                    parent.parent?.nodeType === ParseNodeType.TypeParameterList &&
                    parent.parent.parent?.nodeType === ParseNodeType.TypeAlias
                ) {
                    this.getTypeOfTypeAlias(parent.parent.parent);
                    return;
                }
                break;
            }

            case ParseNodeType.TypeAlias: {
                this.getTypeOfTypeAlias(parent);
                return;
            }

            case ParseNodeType.Decorator: {
                if (parent.parent?.nodeType === ParseNodeType.Class) {
                    this.getTypeOfClass(parent.parent);
                } else if (parent.parent?.nodeType === ParseNodeType.Function) {
                    this.getTypeOfFunction(parent.parent);
                }
                return;
            }

            case ParseNodeType.Parameter: {
                if (nodeToEvaluate !== parent.defaultValue) {
                    this.evaluateTypeOfParameter(parent);
                    return;
                }
                break;
            }

            case ParseNodeType.Argument: {
                if (nodeToEvaluate === parent.name) {
                    // A name used to specify a named parameter in an argument isn't an
                    // expression, so there's nothing we can evaluate here.
                    return;
                }

                if (parent.parent?.nodeType === ParseNodeType.Class) {
                    // A class argument must be evaluated in the context of the class declaration.
                    this.getTypeOfClass(parent.parent);
                    return;
                }
                break;
            }

            case ParseNodeType.Return: {
                // Return expressions must be evaluated in the context of the expected return type.
                if (parent.returnExpression) {
                    const enclosingFunctionNode = ParseTreeUtils.getEnclosingFunction(node);
                    const declaredReturnType = enclosingFunctionNode
                        ? this.getFunctionDeclaredReturnType(enclosingFunctionNode)
                        : undefined;
                    this.getTypeOfExpression(parent.returnExpression, EvaluatorFlags.None, declaredReturnType);
                    return;
                }
                break;
            }

            case ParseNodeType.TypeAnnotation: {
                this.evaluateTypesForTypeAnnotationNode(parent);
                return;
            }

            case ParseNodeType.Assignment: {
                this.evaluateTypesForAssignmentStatement(parent);
                return;
            }
        }

        if (nodeToEvaluate.nodeType === ParseNodeType.TypeAnnotation) {
            this.evaluateTypesForTypeAnnotationNode(nodeToEvaluate);
            return;
        }

        this.getTypeOfExpression(nodeToEvaluate, flags);
    }

    evaluateTypeOfParameter(node: ParameterNode): void {
        // If this parameter has no name, we have nothing to do.
        if (!node.name) {
            return;
        }

        // We need to handle lambdas differently from functions because
        // the former never have parameter type annotations but can
        // be inferred, whereas the latter sometimes have type annotations
        // but cannot be inferred.
        const parent = node.parent!;
        if (parent.nodeType === ParseNodeType.Lambda) {
            this.evaluateTypesForExpressionInContext(parent);
            return;
        }

        assert(parent.nodeType === ParseNodeType.Function);
        const functionNode = parent as FunctionNode;

        const paramIndex = functionNode.parameters.findIndex((param) => param === node);
        const typeAnnotation = ParseTreeUtils.getTypeAnnotationForParameter(functionNode, paramIndex);

        if (typeAnnotation) {
            const param = functionNode.parameters[paramIndex];
            const annotatedType = this.getTypeOfParameterAnnotation(
                typeAnnotation,
                functionNode.parameters[paramIndex].category
            );

            const adjType = this.transformVariadicParamType(
                node,
                node.category,
                this.adjustParameterAnnotatedType(param, annotatedType)
            );

            this.writeTypeCache(node.name!, adjType, EvaluatorFlags.None, /* isIncomplete */ false);
            return;
        }

        const containingClassNode = ParseTreeUtils.getEnclosingClass(functionNode, /* stopAtFunction */ true);
        const classInfo = containingClassNode ? this.getTypeOfClass(containingClassNode) : undefined;

        if (
            classInfo &&
            ClassType.isPseudoGenericClass(classInfo?.classType) &&
            functionNode.name.value === '__init__'
        ) {
            const typeParamName = this.getPseudoGenericTypeVarName(node.name.value);
            const paramType = classInfo.classType.details.typeParameters.find(
                (param) => param.details.name === typeParamName
            );

            if (paramType) {
                this.writeTypeCache(node.name!, paramType, EvaluatorFlags.None, /* isIncomplete */ false);
                return;
            }
        }

        // See if the function is a method in a child class. We may be able to
        // infer the type of the parameter from a method of the same name in
        // a parent class if it has an annotated type.
        const functionFlags = this.getFunctionFlagsFromDecorators(functionNode, /* isInClass */ true);
        const inferredParamType = this.inferParameterType(
            functionNode,
            functionFlags,
            paramIndex,
            classInfo?.classType
        );

        this.writeTypeCache(
            node.name!,
            this.transformVariadicParamType(node, node.category, inferredParamType ?? UnknownType.create()),
            EvaluatorFlags.None,
            /* isIncomplete */ false
        );
    }

    // Evaluates the types that are assigned within the statement that contains
    // the specified parse node. In some cases, a broader statement may need to
    // be evaluated to provide sufficient context for the type. Evaluated types
    // are written back to the type cache for later retrieval.
    evaluateTypesForStatement(node: ParseNode): void {
        this.initializedBasicTypes(node);

        let curNode: ParseNode | undefined = node;

        while (curNode) {
            switch (curNode.nodeType) {
                case ParseNodeType.Assignment: {
                    // See if the assignment is part of a chain of assignments. If so,
                    // evaluate the entire chain.
                    const isInAssignmentChain =
                        curNode.parent &&
                        (curNode.parent.nodeType === ParseNodeType.Assignment ||
                            curNode.parent.nodeType === ParseNodeType.AssignmentExpression ||
                            curNode.parent.nodeType === ParseNodeType.AugmentedAssignment) &&
                        curNode.parent.rightExpression === curNode;
                    if (!isInAssignmentChain) {
                        this.evaluateTypesForAssignmentStatement(curNode);
                        return;
                    }
                    break;
                }

                case ParseNodeType.TypeAlias: {
                    this.getTypeOfTypeAlias(curNode);
                    return;
                }

                case ParseNodeType.AssignmentExpression: {
                    this.getTypeOfExpression(curNode);
                    return;
                }

                case ParseNodeType.AugmentedAssignment: {
                    this.evaluateTypesForAugmentedAssignment(curNode);
                    return;
                }

                case ParseNodeType.Class: {
                    this.getTypeOfClass(curNode);
                    return;
                }

                case ParseNodeType.Parameter: {
                    this.evaluateTypeOfParameter(curNode);
                    return;
                }

                case ParseNodeType.Lambda: {
                    this.evaluateTypesForExpressionInContext(curNode);
                    return;
                }

                case ParseNodeType.Function: {
                    this.getTypeOfFunction(curNode);
                    return;
                }

                case ParseNodeType.For: {
                    this.evaluateTypesForForStatement(curNode);
                    return;
                }

                case ParseNodeType.Except: {
                    this.evaluateTypesForExceptStatement(curNode);
                    return;
                }

                case ParseNodeType.WithItem: {
                    this.evaluateTypesForWithStatement(curNode);
                    return;
                }

                case ParseNodeType.ListComprehensionFor: {
                    const listComprehension = curNode.parent as ListComprehensionNode;
                    assert(listComprehension.nodeType === ParseNodeType.ListComprehension);
                    if (curNode === listComprehension.expression) {
                        this.evaluateTypesForExpressionInContext(listComprehension);
                    } else {
                        // Evaluate the individual iterations starting with the first
                        // up to the curNode.
                        for (const forIfNode of listComprehension.forIfNodes) {
                            this.evaluateListComprehensionForIf(forIfNode);
                            if (forIfNode === curNode) {
                                break;
                            }
                        }
                    }
                    return;
                }

                case ParseNodeType.ImportAs: {
                    this.evaluateTypesForImportAs(curNode);
                    return;
                }

                case ParseNodeType.ImportFromAs: {
                    this.evaluateTypesForImportFromAs(curNode);
                    return;
                }

                case ParseNodeType.ImportFrom: {
                    this.evaluateTypesForImportFrom(curNode);
                    return;
                }

                case ParseNodeType.Case: {
                    this.evaluateTypesForCaseStatement(curNode);
                    return;
                }
            }

            curNode = curNode.parent;
        }

        fail('Unexpected statement');
        return undefined;
    }

    // Helper function for cases where we need to evaluate the types
    // for a subtree so we can determine the type of one of the subnodes
    // within that tree. If the type cannot be determined (because it's part
    // of a cyclical dependency), the function returns undefined.
    evaluateTypeForSubnode(subnode: ParseNode, callback: () => void): TypeResult | undefined {
        // If the type cache is already populated, don't bother
        // doing additional work.
        let subnodeType = this.readTypeCache(subnode, /* flags */ undefined);
        if (subnodeType) {
            return { type: subnodeType };
        }

        const oldIncompleteCache = this._incompleteTypeCache;
        try {
            // If there isn't already an incompleteTypeCache allocated, allocate
            // one now. We'll use this same cache for nested calls, but we'll
            // abandon it once the last nested call completes.
            if (!this._incompleteTypeCache) {
                this._incompleteTypeCache = new Map<number, CachedType>();
            }
            callback();
            subnodeType = this.readTypeCache(subnode, /* flags */ undefined);
            if (subnodeType) {
                return { type: subnodeType };
            }

            subnodeType = this._incompleteTypeCache.get(subnode.id) as Type | undefined;
            if (subnodeType) {
                return { type: subnodeType, isIncomplete: true };
            }

            this._incompleteTypeCache = oldIncompleteCache;
        } catch (e) {
            // We don't use a finally clause here because the debugger doesn't
            // handle it well when stepping through code.
            this._incompleteTypeCache = oldIncompleteCache;
            throw e;
        }

        return undefined;
    }

    getCodeFlowAnalyzerForNode(nodeId: number) {
        let analyzer = this._codeFlowAnalyzerCache.get(nodeId);

        if (!analyzer) {
            // Allocate a new code flow analyzer.
            analyzer = this._codeFlowEngine.createCodeFlowAnalyzer();
            this._codeFlowAnalyzerCache.set(nodeId, analyzer);
        }

        return analyzer;
    }

    // Attempts to determine the type of the reference expression at the
    // point in the code. If the code flow analysis has nothing to say
    // about that expression, it returns un undefined type. Normally
    // flow analysis starts from the reference node, but startNode can be
    // specified to override this in a few special cases (functions and
    // lambdas) to support analysis of captured variables.
    getFlowTypeOfReference(
        reference: CodeFlowReferenceExpressionNode,
        targetSymbolId: number,
        typeAtStart: Type,
        startNode?: FunctionNode | LambdaNode,
        options?: FlowNodeTypeOptions
    ): FlowNodeTypeResult {
        // See if this execution scope requires code flow for this reference expression.
        const referenceKey = createKeyForReference(reference);
        const executionNode = ParseTreeUtils.getExecutionScopeNode(startNode?.parent ?? reference);
        const codeFlowExpressions = AnalyzerNodeInfo.getCodeFlowExpressions(executionNode);

        if (
            !codeFlowExpressions ||
            (!codeFlowExpressions.has(referenceKey) && !codeFlowExpressions.has(wildcardImportReferenceKey))
        ) {
            return { type: undefined, isIncomplete: false };
        }

        if (this.checkCodeFlowTooComplex(reference)) {
            return { type: undefined, isIncomplete: true };
        }

        // Is there an code flow analyzer cached for this execution scope?
        let analyzer: CodeFlowAnalyzer | undefined;

        if (this.isNodeInReturnTypeInferenceContext(executionNode)) {
            // If we're performing the analysis within a temporary
            // context of a function for purposes of inferring its
            // return type for a specified set of arguments, use
            // a temporary analyzer that we'll use only for this context.
            analyzer = this.getCodeFlowAnalyzerForReturnTypeInferenceContext();
        } else {
            analyzer = this.getCodeFlowAnalyzerForNode(executionNode.id);
        }

        const flowNode = AnalyzerNodeInfo.getFlowNode(startNode ?? reference);
        if (flowNode === undefined) {
            return { type: undefined, isIncomplete: false };
        }

        return analyzer.getTypeFromCodeFlow(flowNode!, reference, targetSymbolId, typeAtStart, options);
    }

    // Specializes the specified (potentially generic) class type using
    // the specified type arguments, reporting errors as appropriate.
    // Returns the specialized type and a boolean indicating whether
    // the type indicates a class type (true) or an object type (false).
    createSpecializedClassType(
        classType: ClassType,
        typeArgs: TypeResultWithNode[] | undefined,
        flags: EvaluatorFlags,
        errorNode: ParseNode
    ): Type {
        // Handle the special-case classes that are not defined
        // in the type stubs.
        if (ClassType.isSpecialBuiltIn(classType)) {
            const aliasedName = classType.aliasName || classType.details.name;
            switch (aliasedName) {
                case 'Callable': {
                    return this.createCallableType(typeArgs, errorNode);
                }

                case 'Never': {
                    if (typeArgs && typeArgs.length > 0) {
                        this.addError(
                            Localizer.Diagnostic.typeArgsExpectingNone().format({ name: 'Never' }),
                            typeArgs[0].node
                        );
                    }
                    return NeverType.createNever();
                }

                case 'NoReturn': {
                    if (typeArgs && typeArgs.length > 0) {
                        this.addError(
                            Localizer.Diagnostic.typeArgsExpectingNone().format({ name: 'NoReturn' }),
                            typeArgs[0].node
                        );
                    }
                    return NeverType.createNoReturn();
                }

                case 'Optional': {
                    return this.createOptionalType(classType, errorNode, typeArgs, flags);
                }

                case 'Type': {
                    // PEP 484 says that Type[Any] should be considered
                    // equivalent to type.
                    if (
                        typeArgs?.length === 1 &&
                        isAnyOrUnknown(typeArgs[0].type) &&
                        this._typeClassType &&
                        isInstantiableClass(this._typeClassType)
                    ) {
                        return this._typeClassType;
                    }

                    let typeType = this.createSpecialType(classType, typeArgs, 1);
                    if (isInstantiableClass(typeType)) {
                        typeType = explodeGenericClass(typeType);
                    }
                    return typeType;
                }

                case 'ClassVar': {
                    return this.createClassVarType(classType, errorNode, typeArgs, flags);
                }

                case 'Protocol': {
                    return this.createSpecialType(
                        classType,
                        typeArgs,
                        /* paramLimit */ undefined,
                        /* allowParamSpec */ true
                    );
                }

                case 'Tuple': {
                    return this.createSpecialType(classType, typeArgs, /* paramLimit */ undefined);
                }

                case 'Union': {
                    return this.createUnionType(classType, errorNode, typeArgs, flags);
                }

                case 'Generic': {
                    return this.createGenericType(classType, errorNode, typeArgs, flags);
                }

                case 'Final': {
                    return this.createFinalType(classType, errorNode, typeArgs, flags);
                }

                case 'Annotated': {
                    return this.createAnnotatedType(errorNode, typeArgs);
                }

                case 'Concatenate': {
                    return this.createConcatenateType(errorNode, classType, typeArgs);
                }

                case 'TypeGuard':
                case 'StrictTypeGuard': {
                    return this.createTypeGuardType(errorNode, classType, typeArgs, flags);
                }

                case 'Unpack': {
                    return this.createUnpackType(classType, errorNode, typeArgs, flags);
                }

                case 'Required':
                case 'NotRequired': {
                    return this.createRequiredType(classType, errorNode, aliasedName === 'Required', typeArgs, flags);
                }

                case 'Self': {
                    return this.createSelfType(classType, errorNode, typeArgs);
                }

                case 'LiteralString': {
                    return this.createSpecialType(classType, typeArgs, 0);
                }
            }
        }

        const fileInfo = AnalyzerNodeInfo.getFileInfo(errorNode);
        if (
            fileInfo.isStubFile ||
            fileInfo.executionEnvironment.pythonVersion >= PythonVersion.V3_9 ||
            isAnnotationEvaluationPostponed(AnalyzerNodeInfo.getFileInfo(errorNode)) ||
            (flags & EvaluatorFlags.AllowForwardReferences) !== 0
        ) {
            // Handle "type" specially, since it needs to act like "Type"
            // in Python 3.9 and newer.
            if (ClassType.isBuiltIn(classType, 'type') && typeArgs) {
                // PEP 484 says that type[Any] should be considered
                // equivalent to type.
                if (typeArgs.length === 1 && isAnyOrUnknown(typeArgs[0].type)) {
                    return classType;
                }

                const typeClass = this.getTypingType(errorNode, 'Type');
                if (typeClass && isInstantiableClass(typeClass)) {
                    let typeType = this.createSpecialType(
                        typeClass,
                        typeArgs,
                        1,
                        /* allowParamSpec */ undefined,
                        /* isCallable */ true
                    );

                    if (isInstantiableClass(typeType)) {
                        typeType = explodeGenericClass(typeType);
                    }

                    return typeType;
                }
            }

            // Handle "tuple" specially, since it needs to act like "Tuple"
            // in Python 3.9 and newer.
            if (isTupleClass(classType)) {
                return this.createSpecialType(
                    classType,
                    typeArgs,
                    /* paramLimit */ undefined,
                    /* allowParamSpec */ undefined,
                    /* isCallable */ true
                );
            }
        }

        let typeArgCount = typeArgs ? typeArgs.length : 0;

        // Make sure the argument list count is correct.
        const typeParameters = ClassType.isPseudoGenericClass(classType) ? [] : ClassType.getTypeParameters(classType);

        // If there are no type parameters or args, the class is already specialized.
        // No need to do any more work.
        if (typeParameters.length === 0 && typeArgCount === 0) {
            return classType;
        }

        const variadicTypeParamIndex = typeParameters.findIndex((param) => isVariadicTypeVar(param));

        if (typeArgs) {
            let minTypeArgCount = typeParameters.length;
            const firstNonDefaultParam = typeParameters.findIndex((param) => !!param.details.defaultType);
            if (firstNonDefaultParam >= 0) {
                minTypeArgCount = firstNonDefaultParam;
            }

            if (typeArgCount > typeParameters.length) {
                if (!ClassType.isPartiallyEvaluated(classType) && !ClassType.isTupleClass(classType)) {
                    const fileInfo = AnalyzerNodeInfo.getFileInfo(errorNode);
                    if (typeParameters.length === 0) {
                        this.addDiagnostic(
                            fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                            DiagnosticRule.reportGeneralTypeIssues,
                            Localizer.Diagnostic.typeArgsExpectingNone().format({
                                name: classType.aliasName || classType.details.name,
                            }),
                            typeArgs[typeParameters.length].node
                        );
                    } else if (typeParameters.length !== 1 || !isParamSpec(typeParameters[0])) {
                        this.addDiagnostic(
                            fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                            DiagnosticRule.reportGeneralTypeIssues,
                            Localizer.Diagnostic.typeArgsTooMany().format({
                                name: classType.aliasName || classType.details.name,
                                expected: typeParameters.length,
                                received: typeArgCount,
                            }),
                            typeArgs[typeParameters.length].node
                        );
                    }

                    typeArgCount = typeParameters.length;
                }
            } else if (typeArgCount < minTypeArgCount) {
                const fileInfo = AnalyzerNodeInfo.getFileInfo(errorNode);
                this.addDiagnostic(
                    fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                    DiagnosticRule.reportGeneralTypeIssues,
                    Localizer.Diagnostic.typeArgsTooFew().format({
                        name: classType.aliasName || classType.details.name,
                        expected: minTypeArgCount,
                        received: typeArgCount,
                    }),
                    typeArgs.length > 0 ? typeArgs[0].node.parent! : errorNode
                );
            }

            typeArgs.forEach((typeArg, index) => {
                if (index === variadicTypeParamIndex) {
                    // The types that make up the tuple that maps to the variadic
                    // type variable have already been validated when the tuple
                    // object was created in adjustTypeArgumentsForVariadicTypeVar.
                    if (isClassInstance(typeArg.type) && isTupleClass(typeArg.type)) {
                        return;
                    }

                    if (isVariadicTypeVar(typeArg.type)) {
                        this.validateVariadicTypeVarIsUnpacked(typeArg.type, typeArg.node);
                        return;
                    }
                }

                const typeParam = index < typeParameters.length ? typeParameters[index] : undefined;
                const isParamSpecTarget = typeParam?.details.isParamSpec;

                this.validateTypeArg(typeArg, {
                    allowParamSpec: true,
                    allowTypeArgList: isParamSpecTarget,
                });
            });
        }

        // Handle ParamSpec arguments and fill in any missing type arguments with Unknown.
        let typeArgTypes: Type[] = [];
        const fullTypeParams = ClassType.getTypeParameters(classType);

        // PEP 612 says that if the class has only one type parameter consisting
        // of a ParamSpec, the list of arguments does not need to be enclosed in
        // a list. We'll handle that case specially here.
        if (fullTypeParams.length === 1 && fullTypeParams[0].details.isParamSpec && typeArgs) {
            if (
                typeArgs.every(
                    (typeArg) => !isEllipsisType(typeArg.type) && !typeArg.typeList && !isParamSpec(typeArg.type)
                )
            ) {
                if (
                    typeArgs.length !== 1 ||
                    !isInstantiableClass(typeArgs[0].type) ||
                    !ClassType.isBuiltIn(typeArgs[0].type, 'Concatenate')
                ) {
                    // Package up the type arguments into a typeList.
                    typeArgs = [
                        {
                            type: UnknownType.create(),
                            node: typeArgs[0].node,
                            typeList: typeArgs,
                        },
                    ];
                }
            } else if (typeArgs.length > 1) {
                const paramSpecTypeArg = typeArgs.find((typeArg) => isParamSpec(typeArg.type));
                if (paramSpecTypeArg) {
                    this.addError(Localizer.Diagnostic.paramSpecContext(), paramSpecTypeArg.node);
                }

                const listTypeArg = typeArgs.find((typeArg) => !!typeArg.typeList);
                if (listTypeArg) {
                    this.addError(Localizer.Diagnostic.typeArgListNotAllowed(), listTypeArg.node);
                }
            }
        }

        fullTypeParams.forEach((typeParam, index) => {
            if (typeArgs && index < typeArgs.length) {
                if (typeParam.details.isParamSpec) {
                    const typeArg = typeArgs[index];
                    const functionType = FunctionType.createInstantiable(FunctionTypeFlags.ParamSpecValue);
                    TypeBase.setSpecialForm(functionType);

                    if (isEllipsisType(typeArg.type)) {
                        FunctionType.addDefaultParameters(functionType);
                        functionType.details.flags |= FunctionTypeFlags.SkipArgsKwargsCompatibilityCheck;
                        typeArgTypes.push(functionType);
                        return;
                    }

                    if (typeArg.typeList) {
                        typeArg.typeList!.forEach((paramType, paramIndex) => {
                            FunctionType.addParameter(functionType, {
                                category: ParameterCategory.Simple,
                                name: `__p${paramIndex}`,
                                isNameSynthesized: true,
                                type: convertToInstance(paramType.type),
                                hasDeclaredType: true,
                            });
                        });
                        typeArgTypes.push(functionType);
                        return;
                    }

                    if (isInstantiableClass(typeArg.type) && ClassType.isBuiltIn(typeArg.type, 'Concatenate')) {
                        const concatTypeArgs = typeArg.type.typeArguments;
                        if (concatTypeArgs && concatTypeArgs.length > 0) {
                            concatTypeArgs.forEach((typeArg, index) => {
                                if (index === concatTypeArgs.length - 1) {
                                    if (isParamSpec(typeArg)) {
                                        functionType.details.paramSpec = typeArg;
                                    }
                                } else {
                                    FunctionType.addParameter(functionType, {
                                        category: ParameterCategory.Simple,
                                        name: `__p${index}`,
                                        isNameSynthesized: true,
                                        hasDeclaredType: true,
                                        type: typeArg,
                                    });
                                }
                            });
                        }

                        typeArgTypes.push(functionType);
                        return;
                    }
                }

                typeArgTypes.push(convertToInstance(typeArgs[index].type));
                return;
            }

            typeArgTypes.push(typeParam.details.defaultType ?? UnknownType.create());
        });

        typeArgTypes = typeArgTypes.map((typeArgType, index) => {
            if (index < typeArgCount) {
                const diag = new DiagnosticAddendum();
                let adjustedTypeArgType = this.applyTypeArgToTypeVar(typeParameters[index], typeArgType, diag);

                // Determine if the variance must match.
                if (adjustedTypeArgType && (flags & EvaluatorFlags.EnforceTypeVarVarianceConsistency) !== 0) {
                    const destType = typeParameters[index];
                    const declaredVariance = destType.details.declaredVariance;

                    if (!isVarianceOfTypeArgumentCompatible(adjustedTypeArgType, declaredVariance)) {
                        diag.addMessage(
                            Localizer.DiagnosticAddendum.varianceMismatch().format({
                                typeVarName: this.printType(adjustedTypeArgType),
                                className: classType.details.name,
                            })
                        );
                        adjustedTypeArgType = undefined;
                    }
                }

                if (adjustedTypeArgType) {
                    typeArgType = adjustedTypeArgType;
                } else {
                    // Avoid emitting this error for a partially-constructed class.
                    if (!isClassInstance(typeArgType) || !ClassType.isPartiallyEvaluated(typeArgType)) {
                        const fileInfo = AnalyzerNodeInfo.getFileInfo(typeArgs![index].node);
                        this.addDiagnostic(
                            fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,
                            DiagnosticRule.reportGeneralTypeIssues,
                            Localizer.Diagnostic.typeVarAssignmentMismatch().format({
                                type: this.printType(typeArgType),
                                name: TypeVarType.getReadableName(typeParameters[index]),
                            }) + diag.getString(),
                            typeArgs![index].node
                        );
                    }
                }
            }

            return typeArgType;
        });

        // If the class is partially constructed and doesn't yet have
        // type parameters, assume that the number and types of supplied type
        // arguments are correct.
        if (typeArgs && classType.details.typeParameters.length === 0 && ClassType.isPartiallyEvaluated(classType)) {
            typeArgTypes = typeArgs.map((t) => convertToInstance(t.type));
        }

        const specializedClass = ClassType.cloneForSpecialization(classType, typeArgTypes, typeArgs !== undefined);

        return specializedClass;
    }

    getTypeOfArgument(arg: FunctionArgument): TypeResult {
        if (arg.typeResult) {
            return { type: arg.typeResult.type, isIncomplete: arg.typeResult.isIncomplete };
        }

        if (!arg.valueExpression) {
            // We shouldn't ever get here, but just in case.
            return { type: UnknownType.create() };
        }

        // If there was no defined type provided, there should always
        // be a value expression from which we can retrieve the type.
        return this.getTypeOfExpression(arg.valueExpression);
    }

    // This function is like getTypeOfArgument except that it is
    // used in cases where the argument is expected to be a type
    // and therefore follows the normal rules of types (e.g. they
    // can be forward-declared in stubs, etc.).
    getTypeOfArgumentExpectingType(arg: FunctionArgument): TypeResult {
        if (arg.typeResult) {
            return { type: arg.typeResult.type, isIncomplete: arg.typeResult.isIncomplete };
        }

        // If there was no defined type provided, there should always
        // be a value expression from which we can retrieve the type.
        return this.getTypeOfExpressionExpectingType(arg.valueExpression!);
    }

    getTypeOfExpressionExpectingType(node: ExpressionNode, options?: ExpectedTypeOptions): TypeResult {
        let flags =
            EvaluatorFlags.ExpectingType |
            EvaluatorFlags.EvaluateStringLiteralAsType |
            EvaluatorFlags.ClassVarDisallowed;

        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
        if (fileInfo.isStubFile) {
            flags |= EvaluatorFlags.AllowForwardReferences;
        } else {
            flags |= EvaluatorFlags.InterpreterParsesStringLiteral;
        }

        if (!options?.allowFinal) {
            flags |= EvaluatorFlags.FinalDisallowed;
        }

        if (options?.allowRequired) {
            flags |= EvaluatorFlags.RequiredAllowed | EvaluatorFlags.ExpectingTypeAnnotation;
        }

        if (options?.allowUnpackedTuple) {
            flags |= EvaluatorFlags.AllowUnpackedTupleOrTypeVarTuple;
        } else {
            flags |= EvaluatorFlags.TypeVarTupleDisallowed;
        }

        if (!options?.allowParamSpec) {
            flags |= EvaluatorFlags.ParamSpecDisallowed;
        }

        return this.getTypeOfExpression(node, flags);
    }

    getBuiltInType(node: ParseNode, name: string): Type {
        const scope = ScopeUtils.getScopeForNode(node);
        if (scope) {
            const builtInScope = ScopeUtils.getBuiltInScope(scope);
            const nameType = builtInScope.lookUpSymbol(name);
            if (nameType) {
                return this.getEffectiveTypeOfSymbol(nameType);
            }
        }

        return UnknownType.create();
    }

    getBuiltInObject(node: ParseNode, name: string, typeArguments?: Type[]) {
        const nameType = this.getBuiltInType(node, name);
        if (isInstantiableClass(nameType)) {
            let classType = nameType;
            if (typeArguments) {
                classType = ClassType.cloneForSpecialization(
                    classType,
                    typeArguments,
                    /* isTypeArgumentExplicit */ typeArguments !== undefined
                );
            }

            return ClassType.cloneAsInstance(classType);
        }

        return nameType;
    }

    lookUpSymbolRecursive(
        node: ParseNode,
        name: string,
        honorCodeFlow: boolean,
        preferGlobalScope = false
    ): SymbolWithScope | undefined {
        const scope = ScopeUtils.getScopeForNode(node);
        let symbolWithScope = scope?.lookUpSymbolRecursive(name);
        const scopeType = scope?.type ?? ScopeType.Module;

        // Functions and list comprehensions don't allow access to implicitly
        // aliased symbols in outer scopes if they haven't yet been assigned
        // within the local scope.
        const scopeTypeHonorsCodeFlow = scopeType !== ScopeType.Function && scopeType !== ScopeType.ListComprehension;

        if (symbolWithScope && honorCodeFlow && scopeTypeHonorsCodeFlow) {
            // Filter the declarations based on flow reachability.
            const reachableDecls = symbolWithScope.symbol.getDeclarations().filter((decl) => {
                if (decl.type !== DeclarationType.Alias && decl.type !== DeclarationType.Intrinsic) {
                    // Is the declaration in the same execution scope as the "usageNode" node?
                    const usageScope = ParseTreeUtils.getExecutionScopeNode(node);
                    const declNode =
                        decl.type === DeclarationType.Class ||
                        decl.type === DeclarationType.Function ||
                        decl.type === DeclarationType.TypeAlias
                            ? decl.node.name
                            : decl.node;
                    const declScope = ParseTreeUtils.getExecutionScopeNode(declNode);
                    if (usageScope === declScope) {
                        if (!this.isFlowPathBetweenNodes(declNode, node)) {
                            // If there was no control flow path from the usage back
                            // to the source, see if the usage node is reachable by
                            // any path.
                            const flowNode = AnalyzerNodeInfo.getFlowNode(node);
                            const isReachable =
                                flowNode &&
                                this._codeFlowEngine.isFlowNodeReachable(
                                    flowNode,
                                    /* sourceFlowNode */ undefined,
                                    /* ignoreNoReturn */ true
                                );
                            return !isReachable;
                        }
                    }
                }
                return true;
            });

            // If none of the declarations are reachable from the current node,
            // search for the symbol in outer scopes.
            if (reachableDecls.length === 0) {
                if (symbolWithScope.scope.type !== ScopeType.Function) {
                    let nextScopeToSearch = symbolWithScope.scope.parent;
                    const isOutsideCallerModule =
                        symbolWithScope.isOutsideCallerModule || symbolWithScope.scope.type === ScopeType.Module;
                    let isBeyondExecutionScope =
                        symbolWithScope.isBeyondExecutionScope || symbolWithScope.scope.isIndependentlyExecutable();

                    if (symbolWithScope.scope.type === ScopeType.Class) {
                        // There is an odd documented behavior for classes in that
                        // symbol resolution skips to the global scope rather than
                        // the next scope in the chain.
                        const globalScopeResult = symbolWithScope.scope.getGlobalScope();
                        nextScopeToSearch = globalScopeResult.scope;
                        if (globalScopeResult.isBeyondExecutionScope) {
                            isBeyondExecutionScope = true;
                        }
                    }

                    if (nextScopeToSearch) {
                        symbolWithScope = nextScopeToSearch.lookUpSymbolRecursive(
                            name,
                            isOutsideCallerModule,
                            isBeyondExecutionScope
                        );
                    } else {
                        symbolWithScope = undefined;
                    }
                } else {
                    symbolWithScope = undefined;
                }
            }
        }

        // PEP 563 indicates that if a forward reference can be resolved in the module
        // scope (or, by implication, in the builtins scope), it should prefer that
        // resolution over local resolutions.
        if (symbolWithScope && preferGlobalScope) {
            let curSymbolWithScope: SymbolWithScope | undefined = symbolWithScope;
            while (
                curSymbolWithScope.scope.type !== ScopeType.Module &&
                curSymbolWithScope.scope.type !== ScopeType.Builtin &&
                curSymbolWithScope.scope.parent
            ) {
                curSymbolWithScope = curSymbolWithScope.scope.parent.lookUpSymbolRecursive(
                    name,
                    curSymbolWithScope.isOutsideCallerModule,
                    curSymbolWithScope.isBeyondExecutionScope || curSymbolWithScope.scope.isIndependentlyExecutable()
                );
                if (!curSymbolWithScope) {
                    break;
                }
            }

            if (
                curSymbolWithScope?.scope.type === ScopeType.Module ||
                curSymbolWithScope?.scope.type === ScopeType.Builtin
            ) {
                symbolWithScope = curSymbolWithScope;
            }
        }

        return symbolWithScope;
    }

    // Disables recording of errors and warnings.
    suppressDiagnostics<T>(node: ParseNode, callback: () => T) {
        this._suppressedNodeStack.push(node);

        try {
            const result = callback();
            this._suppressedNodeStack.pop();
            return result;
        } catch (e) {
            // We don't use finally here because the TypeScript debugger doesn't
            // handle finally well when single stepping.
            this._suppressedNodeStack.pop();
            throw e;
        }
    }

    // Disables recording of errors and warnings and disables
    // any caching of types, under the assumption that we're
    // performing speculative evaluations.
    useSpeculativeMode<T>(speculativeNode: ParseNode, callback: () => T, allowCacheRetention = true) {
        this._speculativeTypeTracker.enterSpeculativeContext(speculativeNode, allowCacheRetention);

        try {
            const result = callback();
            this._speculativeTypeTracker.leaveSpeculativeContext();
            return result;
        } catch (e) {
            // We don't use finally here because the TypeScript debugger doesn't
            // handle finally well when single stepping.
            this._speculativeTypeTracker.leaveSpeculativeContext();
            throw e;
        }
    }

    disableSpeculativeMode(callback: () => void) {
        const stack = this._speculativeTypeTracker.disableSpeculativeMode();

        try {
            callback();
            this._speculativeTypeTracker.enableSpeculativeMode(stack);
        } catch (e) {
            // We don't use finally here because the TypeScript debugger doesn't
            // handle finally well when single stepping.
            this._speculativeTypeTracker.enableSpeculativeMode(stack);
            throw e;
        }
    }

    getDeclarationFromFunctionNamedParameter(type: FunctionType, paramName: string): Declaration | undefined {
        if (isFunction(type)) {
            if (type.details.declaration) {
                const functionDecl = type.details.declaration;
                if (functionDecl.type === DeclarationType.Function) {
                    const functionNode = functionDecl.node;
                    const functionScope = AnalyzerNodeInfo.getScope(functionNode);
                    if (functionScope) {
                        const paramSymbol = functionScope.lookUpSymbol(paramName)!;
                        if (paramSymbol) {
                            return paramSymbol
                                .getDeclarations()
                                .find((decl) => decl.type === DeclarationType.Parameter);
                        }
                    }
                }
            }
        }

        return undefined;
    }

    // In general, string nodes don't have any declarations associated with them, but
    // we need to handle the special case of string literals used as keys within a
    // dictionary expression where those keys are associated with a known TypedDict.
    getDeclarationsForStringNode(node: StringNode): Declaration[] | undefined {
        const declarations: Declaration[] = [];
        const expectedType = this.getExpectedType(node)?.type;

        if (expectedType) {
            doForEachSubtype(expectedType, (subtype) => {
                // If the expected type is a TypedDict then the node is either a key expression
                // or a single entry in a set. We then need to check that the value of the node
                // is a valid entry in the TypedDict to avoid resolving declarations for
                // synthesized symbols such as 'get'.
                if (isClassInstance(subtype) && ClassType.isTypedDictClass(subtype)) {
                    const entry = subtype.details.typedDictEntries?.get(node.value);
                    if (entry) {
                        const symbol = lookUpObjectMember(subtype, node.value)?.symbol;

                        if (symbol) {
                            appendArray(declarations, symbol.getDeclarations());
                        }
                    }
                }
            });
        }

        return declarations.length === 0 ? undefined : declarations;
    }

    getAliasFromImport(node: NameNode): NameNode | undefined {
        if (
            node.parent &&
            node.parent.nodeType === ParseNodeType.ImportFromAs &&
            node.parent.alias &&
            node === node.parent.name
        ) {
            return node.parent.alias;
        }
        return undefined;
    }

    getDeclarationsForNameNode(node: NameNode, skipUnreachableCode = true): Declaration[] | undefined {
        if (skipUnreachableCode && AnalyzerNodeInfo.isCodeUnreachable(node)) {
            return undefined;
        }

        const declarations: Declaration[] = [];

        // If the node is part of a "from X import Y as Z" statement and the node
        // is the "Y" (non-aliased) name, we need to look up the alias symbol
        // since the non-aliased name is not in the symbol table.
        const alias = this.getAliasFromImport(node);
        if (alias) {
            const scope = ScopeUtils.getScopeForNode(node);
            if (scope) {
                // Look up the alias symbol.
                const symbolInScope = scope.lookUpSymbolRecursive(alias.value);
                if (symbolInScope) {
                    // The alias could have more decls that don't refer to this import. Filter
                    // out the one(s) that specifically associated with this import statement.
                    const declsForThisImport = symbolInScope.symbol.getDeclarations().filter((decl) => {
                        return decl.type === DeclarationType.Alias && decl.node === node.parent;
                    });

                    appendArray(declarations, getDeclarationsWithUsesLocalNameRemoved(declsForThisImport));
                }
            }
        } else if (
            node.parent &&
            node.parent.nodeType === ParseNodeType.MemberAccess &&
            node === node.parent.memberName
        ) {
            let baseType = this.getType(node.parent.leftExpression);
            if (baseType) {
                baseType = this.makeTopLevelTypeVarsConcrete(baseType);
                const memberName = node.parent.memberName.value;
                doForEachSubtype(baseType, (subtype) => {
                    let symbol: Symbol | undefined;

                    subtype = this.makeTopLevelTypeVarsConcrete(subtype);

                    if (isInstantiableClass(subtype)) {
                        // Try to find a member that has a declared type. If so, that
                        // overrides any inferred types.
                        let member = lookUpClassMember(subtype, memberName, ClassMemberLookupFlags.DeclaredTypesOnly);
                        if (!member) {
                            member = lookUpClassMember(subtype, memberName);
                        }

                        if (!member) {
                            const metaclass = subtype.details.effectiveMetaclass;
                            if (metaclass && isInstantiableClass(metaclass)) {
                                member = lookUpClassMember(metaclass, memberName);
                            }
                        }

                        if (member) {
                            symbol = member.symbol;
                        }
                    } else if (isClassInstance(subtype)) {
                        // Try to find a member that has a declared type. If so, that
                        // overrides any inferred types.
                        let member = lookUpObjectMember(subtype, memberName, ClassMemberLookupFlags.DeclaredTypesOnly);
                        if (!member) {
                            member = lookUpObjectMember(subtype, memberName);
                        }
                        if (member) {
                            symbol = member.symbol;
                        }
                    } else if (isModule(subtype)) {
                        symbol = ModuleType.getField(subtype, memberName);
                    }

                    if (symbol) {
                        // By default, report only the declarations that have type annotations.
                        // If there are none, then report all of the unannotated declarations,
                        // which includes every assignment of that symbol.
                        const typedDecls = symbol.getTypedDeclarations();
                        if (typedDecls.length > 0) {
                            appendArray(declarations, typedDecls);
                        } else {
                            appendArray(declarations, symbol.getDeclarations());
                        }
                    }
                });
            }
        } else if (node.parent && node.parent.nodeType === ParseNodeType.ModuleName) {
            const namePartIndex = node.parent.nameParts.findIndex((part) => part === node);
            const importInfo = AnalyzerNodeInfo.getImportInfo(node.parent);
            if (
                namePartIndex >= 0 &&
                importInfo &&
                !importInfo.isNativeLib &&
                namePartIndex < importInfo.resolvedPaths.length
            ) {
                if (importInfo.resolvedPaths[namePartIndex]) {
                    this.evaluateTypesForStatement(node);

                    // Synthesize an alias declaration for this name part. The only
                    // time this case is used is for IDE services such as
                    // the find all references, hover provider and etc.
                    declarations.push(createSynthesizedAliasDeclaration(importInfo.resolvedPaths[namePartIndex]));
                }
            }
        } else if (node.parent && node.parent.nodeType === ParseNodeType.Argument && node === node.parent.name) {
            // The target node is the name in a named argument. We need to determine whether
            // the corresponding named parameter can be determined from the context.
            const argNode = node.parent;
            const paramName = node.value;
            if (argNode.parent && argNode.parent.nodeType === ParseNodeType.Call) {
                const baseType = this.getType(argNode.parent.leftExpression);

                if (baseType) {
                    if (isFunction(baseType) && baseType.details.declaration) {
                        const paramDecl = this.getDeclarationFromFunctionNamedParameter(baseType, paramName);
                        if (paramDecl) {
                            declarations.push(paramDecl);
                        }
                    } else if (isOverloadedFunction(baseType)) {
                        baseType.overloads.forEach((f) => {
                            const paramDecl = this.getDeclarationFromFunctionNamedParameter(f, paramName);
                            if (paramDecl) {
                                declarations.push(paramDecl);
                            }
                        });
                    } else if (isInstantiableClass(baseType)) {
                        const initMethodType = this.getTypeOfObjectMember(
                            argNode.parent.leftExpression,
                            ClassType.cloneAsInstance(baseType),
                            '__init__',
                            { method: 'get' },
                            /* diag */ undefined,
                            MemberAccessFlags.SkipObjectBaseClass
                        )?.type;

                        if (initMethodType && isFunction(initMethodType)) {
                            const paramDecl = this.getDeclarationFromFunctionNamedParameter(initMethodType, paramName);
                            if (paramDecl) {
                                declarations.push(paramDecl);
                            } else if (ClassType.isDataClass(baseType) || ClassType.isTypedDictClass(baseType)) {
                                const lookupResults = lookUpClassMember(baseType, paramName);
                                if (lookupResults) {
                                    appendArray(declarations, lookupResults.symbol.getDeclarations());
                                }
                            }
                        }
                    }
                }
            }
        } else {
            const fileInfo = AnalyzerNodeInfo.getFileInfo(node);

            // Determine if this node is within a quoted type annotation.
            const isWithinTypeAnnotation = ParseTreeUtils.isWithinTypeAnnotation(
                node,
                !isAnnotationEvaluationPostponed(AnalyzerNodeInfo.getFileInfo(node))
            );
            const allowForwardReferences = isWithinTypeAnnotation || fileInfo.isStubFile;

            let symbol: Symbol | undefined;
            const typeParamSymbol = AnalyzerNodeInfo.getTypeParameterSymbol(node);
            if (typeParamSymbol) {
                symbol = typeParamSymbol;
            } else {
                const symbolWithScope = this.lookUpSymbolRecursive(
                    node,
                    node.value,
                    !allowForwardReferences,
                    isWithinTypeAnnotation
                );

                symbol = symbolWithScope?.symbol;
            }

            if (symbol) {
                appendArray(declarations, symbol.getDeclarations());
            }
        }

        return declarations;
    }

    getTypeForDeclaration(declaration: Declaration): Type | undefined {
        switch (declaration.type) {
            case DeclarationType.Intrinsic: {
                if (declaration.intrinsicType === 'Any') {
                    return AnyType.create();
                }

                if (declaration.intrinsicType === 'class') {
                    const classNode = ParseTreeUtils.getEnclosingClass(declaration.node) as ClassNode;
                    const classTypeInfo = this.getTypeOfClass(classNode);
                    return classTypeInfo?.classType;
                }

                const strType = this.getBuiltInObject(declaration.node, 'str');
                const intType = this.getBuiltInObject(declaration.node, 'int');
                if (isClassInstance(intType) && isClassInstance(strType)) {
                    if (declaration.intrinsicType === 'str') {
                        return strType;
                    }

                    if (declaration.intrinsicType === 'str | None') {
                        return combineTypes([strType, NoneType.createInstance()]);
                    }

                    if (declaration.intrinsicType === 'int') {
                        return intType;
                    }

                    if (declaration.intrinsicType === 'Iterable[str]') {
                        const iterableType = this.getBuiltInType(declaration.node, 'Iterable');
                        if (isInstantiableClass(iterableType)) {
                            return ClassType.cloneAsInstance(
                                ClassType.cloneForSpecialization(
                                    iterableType,
                                    [strType],
                                    /* isTypeArgumentExplicit */ true
                                )
                            );
                        }
                    }

                    if (declaration.intrinsicType === 'Dict[str, Any]') {
                        const dictType = this.getBuiltInType(declaration.node, 'dict');
                        if (isInstantiableClass(dictType)) {
                            return ClassType.cloneAsInstance(
                                ClassType.cloneForSpecialization(
                                    dictType,
                                    [strType, AnyType.create()],
                                    /* isTypeArgumentExplicit */ true
                                )
                            );
                        }
                    }
                }

                return UnknownType.create();
            }

            case DeclarationType.Class: {
                const classTypeInfo = this.getTypeOfClass(declaration.node);
                return classTypeInfo?.decoratedType;
            }

            case DeclarationType.SpecialBuiltInClass: {
                return this.getTypeOfAnnotation(declaration.node.typeAnnotation);
            }

            case DeclarationType.Function: {
                const functionTypeInfo = this.getTypeOfFunction(declaration.node);
                return functionTypeInfo?.decoratedType;
            }

            case DeclarationType.TypeAlias: {
                return this.getTypeOfTypeAlias(declaration.node);
            }

            case DeclarationType.Parameter: {
                let typeAnnotationNode = declaration.node.typeAnnotation || declaration.node.typeAnnotationComment;

                // If there wasn't an annotation, see if the parent function
                // has a function-level annotation comment that provides
                // this parameter's annotation type.
                if (!typeAnnotationNode) {
                    if (declaration.node.parent?.nodeType === ParseNodeType.Function) {
                        const functionNode = declaration.node.parent;
                        if (
                            functionNode.functionAnnotationComment &&
                            !functionNode.functionAnnotationComment.isParamListEllipsis
                        ) {
                            const paramIndex = functionNode.parameters.findIndex((param) => param === declaration.node);
                            typeAnnotationNode = ParseTreeUtils.getTypeAnnotationForParameter(functionNode, paramIndex);
                        }
                    }
                }

                if (typeAnnotationNode) {
                    const declaredType = this.getTypeOfParameterAnnotation(
                        typeAnnotationNode,
                        declaration.node.category
                    );

                    return this.transformVariadicParamType(
                        declaration.node,
                        declaration.node.category,
                        this.adjustParameterAnnotatedType(declaration.node, declaredType)
                    );
                }

                return undefined;
            }

            case DeclarationType.TypeParameter: {
                let typeVar = TypeVarType.createInstantiable(declaration.node.name.value);
                if (declaration.node.typeParamCategory === TypeParameterCategory.TypeVarTuple) {
                    typeVar.details.isVariadic = true;
                } else if (declaration.node.typeParamCategory === TypeParameterCategory.ParamSpec) {
                    typeVar.details.isParamSpec = true;
                }

                if (declaration.node.boundExpression) {
                    if (declaration.node.boundExpression.nodeType === ParseNodeType.Tuple) {
                        const constraints = declaration.node.boundExpression.expressions.map((constraint) => {
                            const constraintType = this.getTypeOfExpressionExpectingType(constraint).type;

                            if (requiresSpecialization(constraintType, /* ignorePseudoGeneric */ true)) {
                                this.addError(Localizer.Diagnostic.typeVarBoundGeneric(), constraint);
                            }

                            return convertToInstance(constraintType);
                        });

                        if (constraints.length < 2) {
                            this.addDiagnostic(
                                AnalyzerNodeInfo.getFileInfo(declaration.node.boundExpression).diagnosticRuleSet
                                    .reportGeneralTypeIssues,
                                DiagnosticRule.reportGeneralTypeIssues,
                                Localizer.Diagnostic.typeVarSingleConstraint(),
                                declaration.node.boundExpression
                            );
                        } else if (declaration.node.typeParamCategory === TypeParameterCategory.TypeVar) {
                            typeVar.details.constraints = constraints;
                        }
                    } else {
                        const boundType = this.getTypeOfExpressionExpectingType(declaration.node.boundExpression).type;

                        if (requiresSpecialization(boundType, /* ignorePseudoGeneric */ true)) {
                            this.addError(
                                Localizer.Diagnostic.typeVarConstraintGeneric(),
                                declaration.node.boundExpression
                            );
                        }

                        if (declaration.node.typeParamCategory === TypeParameterCategory.TypeVar) {
                            typeVar.details.boundType = convertToInstance(boundType);
                        }
                    }
                }

                if (declaration.node.defaultExpression) {
                    // TODO - need to finish. For now, just evaluate the expression
                    // to generate any errors.
                    this.getTypeOfExpression(
                        declaration.node.defaultExpression,
                        EvaluatorFlags.AllowUnpackedTupleOrTypeVarTuple
                    );
                }

                typeVar.details.isTypeParamSyntax = true;

                // Associate the type variable with the owning scope.
                const scopeNode = ParseTreeUtils.getTypeVarScopeNode(declaration.node);
                if (scopeNode) {
                    let scopeType: TypeVarScopeType;
                    if (scopeNode.nodeType === ParseNodeType.Class) {
                        scopeType = TypeVarScopeType.Class;

                        // Set the variance to "auto" for class-scoped TypeVars.
                        typeVar.details.declaredVariance = Variance.Auto;
                    } else if (scopeNode.nodeType === ParseNodeType.Function) {
                        scopeType = TypeVarScopeType.Function;
                    } else {
                        assert(scopeNode.nodeType === ParseNodeType.TypeAlias);
                        scopeType = TypeVarScopeType.TypeAlias;
                    }

                    typeVar = TypeVarType.cloneForScopeId(
                        typeVar,
                        this.getScopeIdForNode(
                            scopeNode.nodeType === ParseNodeType.TypeAlias ? scopeNode.name : scopeNode
                        ),
                        scopeNode.name.value,
                        scopeType
                    );
                }

                return typeVar;
            }

            case DeclarationType.Variable: {
                const typeAnnotationNode = declaration.typeAnnotationNode;

                if (typeAnnotationNode) {
                    const typeAliasNode = this.isDeclaredTypeAlias(typeAnnotationNode)
                        ? ParseTreeUtils.getTypeAnnotationNode(typeAnnotationNode)
                        : undefined;
                    let declaredType: Type;

                    if (declaration.isRuntimeTypeExpression) {
                        declaredType = convertToInstance(
                            this.getTypeOfExpressionExpectingType(typeAnnotationNode, {
                                allowFinal: true,
                                allowRequired: true,
                            }).type
                        );
                    } else {
                        const declNode =
                            declaration.isDefinedByMemberAccess &&
                            declaration.node.parent?.nodeType === ParseNodeType.MemberAccess
                                ? declaration.node.parent
                                : declaration.node;
                        declaredType = this.getTypeOfAnnotation(typeAnnotationNode, {
                            isVariableAnnotation: true,
                            allowClassVar: ParseTreeUtils.isClassVarAllowedForAssignmentTarget(declNode),
                            allowFinal: ParseTreeUtils.isFinalAllowedForAssignmentTarget(declNode),
                        });
                    }

                    if (declaredType) {
                        // Apply enum transform if appropriate.
                        if (declaration.node.nodeType === ParseNodeType.Name) {
                            declaredType =
                                transformTypeForPossibleEnumClass(this, declaration.node, () => declaredType) ||
                                declaredType;
                        }

                        if (typeAliasNode && typeAliasNode.valueExpression.nodeType === ParseNodeType.Name) {
                            declaredType = this.transformTypeForTypeAlias(
                                declaredType,
                                typeAliasNode.valueExpression,
                                declaration.node
                            );
                        }

                        return declaredType;
                    }
                }

                return undefined;
            }

            case DeclarationType.Alias: {
                return undefined;
            }
        }
    }

    getInferredTypeOfDeclaration(symbol: Symbol, decl: Declaration): Type | undefined {
        const resolvedDecl = this.resolveAliasDeclaration(
            decl,
            /* resolveLocalNames */ true,
            /* allowExternallyHiddenAccess */ AnalyzerNodeInfo.getFileInfo(decl.node).isStubFile
        );

        // We couldn't resolve the alias. Substitute an unknown
        // type in this case.
        if (!resolvedDecl) {
            return this._evaluatorOptions.evaluateUnknownImportsAsAny ? AnyType.create() : UnknownType.create();
        }

        const applyLoaderActionsToModuleType = (
            moduleType: ModuleType,
            loaderActions: ModuleLoaderActions,
            importLookup: ImportLookup
        ): Type => {
            if (loaderActions.path && loaderActions.loadSymbolsFromPath) {
                const lookupResults = importLookup(loaderActions.path);
                if (lookupResults) {
                    moduleType.fields = lookupResults.symbolTable;
                    moduleType.docString = lookupResults.docString;
                } else {
                    return this._evaluatorOptions.evaluateUnknownImportsAsAny ? AnyType.create() : UnknownType.create();
                }
            }

            if (loaderActions.implicitImports) {
                loaderActions.implicitImports.forEach((implicitImport, name) => {
                    // Recursively apply loader actions.
                    let symbolType: Type;

                    if (implicitImport.isUnresolved) {
                        symbolType = UnknownType.create();
                    } else {
                        const moduleName = moduleType.moduleName ? moduleType.moduleName + '.' + name : '';
                        const importedModuleType = ModuleType.create(moduleName, implicitImport.path);
                        symbolType = applyLoaderActionsToModuleType(
                            importedModuleType,
                            implicitImport,
                            this._importLookup
                        );
                    }

                    const importedModuleSymbol = Symbol.createWithType(SymbolFlags.None, symbolType);
                    moduleType.loaderFields.set(name, importedModuleSymbol);
                });
            }

            return moduleType;
        };

        // If the resolved declaration is still an alias, the alias
        // is pointing at a module, and we need to synthesize a
        // module type.
        if (resolvedDecl.type === DeclarationType.Alias) {
            // Build a module type that corresponds to the declaration and
            // its associated loader actions.
            let moduleName = resolvedDecl.moduleName;
            if (decl.type === DeclarationType.Alias) {
                if (decl.symbolName) {
                    moduleName += '.' + decl.symbolName;
                }

                // If the module name is relative to the current file, use that
                // file's module name as a reference.
                if (moduleName.startsWith('.')) {
                    const fileInfo = AnalyzerNodeInfo.getFileInfo(decl.node);
                    const nameParts = fileInfo.moduleName.split('.');
                    moduleName = moduleName.substr(1);

                    while (moduleName.startsWith('.') && nameParts.length > 0) {
                        moduleName = moduleName.substr(1);
                        nameParts.pop();
                    }

                    moduleName = nameParts.join('.') + '.' + moduleName;
                }
            }
            const moduleType = ModuleType.create(moduleName, resolvedDecl.path);
            if (resolvedDecl.symbolName && resolvedDecl.submoduleFallback) {
                return applyLoaderActionsToModuleType(moduleType, resolvedDecl.submoduleFallback, this._importLookup);
            } else {
                return applyLoaderActionsToModuleType(moduleType, resolvedDecl, this._importLookup);
            }
        }

        const declaredType = this.getTypeForDeclaration(resolvedDecl);
        if (declaredType) {
            return declaredType;
        }

        // If this is part of a "py.typed" package, don't fall back on type inference
        // unless it's marked Final, is a constant, or is a declared type alias.
        const fileInfo = AnalyzerNodeInfo.getFileInfo(resolvedDecl.node);
        let isUnambiguousType = !fileInfo.isInPyTypedPackage || fileInfo.isStubFile;

        // If this is a py.typed package, determine if this is a case where an unannotated
        // variable is considered "unambiguous" because all type checkers are almost
        // guaranteed to infer its type the same.
        if (!isUnambiguousType) {
            if (resolvedDecl.type === DeclarationType.Variable) {
                // Special-case variables within an enum class. These are effectively
                // constants, so we'll treat them as unambiguous.
                const enclosingClass = ParseTreeUtils.getEnclosingClass(resolvedDecl.node, /* stopAtFunction */ true);
                if (enclosingClass) {
                    const classTypeInfo = this.getTypeOfClass(enclosingClass);
                    if (classTypeInfo && ClassType.isEnumClass(classTypeInfo.classType)) {
                        isUnambiguousType = true;
                    }
                }

                if (resolvedDecl.isFinal || resolvedDecl.isConstant) {
                    isUnambiguousType = true;
                }
            }
        }

        // If the resolved declaration had no defined type, use the
        // inferred type for this node.
        if (resolvedDecl.type === DeclarationType.Parameter) {
            return this.evaluateTypeForSubnode(resolvedDecl.node.name!, () => {
                this.evaluateTypeOfParameter(resolvedDecl.node);
            })?.type;
        }

        if (resolvedDecl.type === DeclarationType.Variable && resolvedDecl.inferredTypeSource) {
            // If this is a type alias, evaluate types for the entire assignment
            // statement rather than just the RHS of the assignment.
            const typeSource =
                resolvedDecl.typeAliasName && resolvedDecl.inferredTypeSource.parent
                    ? resolvedDecl.inferredTypeSource.parent
                    : resolvedDecl.inferredTypeSource;
            let inferredType = this.evaluateTypeForSubnode(resolvedDecl.node, () => {
                this.evaluateTypesForStatement(typeSource);
            })?.type;

            if (inferredType && resolvedDecl.node.nodeType === ParseNodeType.Name) {
                // See if this is an enum member. If so, we need to handle it as a special case.
                const enumMemberType = transformTypeForPossibleEnumClass(this, resolvedDecl.node, () => {
                    return (
                        this.evaluateTypeForSubnode(resolvedDecl.inferredTypeSource!, () => {
                            this.evaluateTypesForStatement(resolvedDecl.inferredTypeSource!);
                        })?.type ?? UnknownType.create()
                    );
                });
                if (enumMemberType) {
                    inferredType = enumMemberType;
                }
            }

            if (inferredType && resolvedDecl.typeAliasName) {
                // If this was a speculative type alias, it becomes a real type alias only
                // in the event that its inferred type is instantiable or explicitly Any
                // (but not an ellipsis).
                if (
                    TypeBase.isInstantiable(inferredType) &&
                    !isUnknown(inferredType) &&
                    !isEllipsisType(inferredType)
                ) {
                    inferredType = this.transformTypeForTypeAlias(
                        inferredType,
                        resolvedDecl.typeAliasName,
                        resolvedDecl.node
                    );

                    isUnambiguousType = true;
                }
            }

            // Determine whether we need to mark the annotation as ambiguous.
            if (inferredType && fileInfo.isInPyTypedPackage && !fileInfo.isStubFile) {
                if (!isUnambiguousType) {
                    // See if this particular inference can be considered "unambiguous".
                    // Any symbol that is assigned more than once is considered ambiguous.
                    if (this.isUnambiguousInference(symbol, decl, inferredType)) {
                        isUnambiguousType = true;
                    }
                }

                if (!isUnambiguousType) {
                    inferredType = TypeBase.cloneForAmbiguousType(inferredType);
                }
            }

            return inferredType;
        }

        return undefined;
    }

    // Applies some heuristics to determine whether it's likely that all Python
    // type checkers will infer the same type.
    isUnambiguousInference(symbol: Symbol, decl: Declaration, inferredType: Type): boolean {
        const nonSlotsDecls = symbol.getDeclarations().filter((decl) => {
            return decl.type !== DeclarationType.Variable || !decl.isInferenceAllowedInPyTyped;
        });

        // Any symbol with more than one assignment is considered ambiguous.
        if (nonSlotsDecls.length > 1) {
            return false;
        }

        if (decl.type !== DeclarationType.Variable) {
            return false;
        }

        // If there are no non-slots declarations, don't mark the inferred type as ambiguous.
        if (nonSlotsDecls.length === 0) {
            return true;
        }

        // TypeVar definitions don't require a declaration.
        if (isTypeVar(inferredType)) {
            return true;
        }

        let assignmentNode: AssignmentNode | undefined;

        const parentNode = decl.node.parent;
        if (parentNode) {
            // Is this a simple assignment (x = y) or an assignment of an instance variable (self.x = y)?
            if (parentNode.nodeType === ParseNodeType.Assignment) {
                assignmentNode = parentNode;
            } else if (
                parentNode.nodeType === ParseNodeType.MemberAccess &&
                parentNode.parent?.nodeType === ParseNodeType.Assignment
            ) {
                assignmentNode = parentNode.parent;
            }
        }

        if (!assignmentNode) {
            return false;
        }

        const assignedType = this.getTypeOfExpression(assignmentNode.rightExpression).type;

        // Assume that literal values will always result in the same inferred type.
        if (isClassInstance(assignedType) && isLiteralType(assignedType)) {
            return true;
        }

        // If the assignment is a simple name corresponding to an unambiguous
        // type, we'll assume the resulting variable will receive the same
        // unambiguous type.
        if (assignmentNode.rightExpression.nodeType === ParseNodeType.Name && !TypeBase.isAmbiguous(assignedType)) {
            return true;
        }

        return false;
    }

    // If the specified declaration is an alias declaration that points to a symbol,
    // it resolves the alias and looks up the symbol, then returns the first declaration
    // associated with that symbol. It does this recursively if necessary. If a symbol
    // lookup fails, undefined is returned. If resolveLocalNames is true, the method
    // resolves aliases through local renames ("as" clauses found in import statements).
    resolveAliasDeclaration(
        declaration: Declaration,
        resolveLocalNames: boolean,
        allowExternallyHiddenAccess = false
    ): Declaration | undefined {
        return DeclarationUtils.resolveAliasDeclaration(
            this._importLookup,
            declaration,
            resolveLocalNames,
            allowExternallyHiddenAccess
        )?.declaration;
    }

    resolveAliasDeclarationWithInfo(
        declaration: Declaration,
        resolveLocalNames: boolean,
        allowExternallyHiddenAccess = false
    ): DeclarationUtils.ResolvedAliasInfo | undefined {
        return DeclarationUtils.resolveAliasDeclaration(
            this._importLookup,
            declaration,
            resolveLocalNames,
            allowExternallyHiddenAccess
        );
    }

    // Returns the type of the symbol. If the type is explicitly declared, that type
    // is returned. If not, the type is inferred from assignments to the symbol. All
    // assigned types are evaluated and combined into a union. If a "usageNode"
    // node is specified, only declarations that are outside of the current execution
    // scope or that are reachable (as determined by code flow analysis) are considered.
    // This helps in cases where there are cyclical dependencies between symbols.
    getEffectiveTypeOfSymbol(symbol: Symbol): Type {
        return this.getEffectiveTypeOfSymbolForUsage(symbol).type;
    }

    getEffectiveTypeOfSymbolForUsage(symbol: Symbol, usageNode?: NameNode, useLastDecl = false): EffectiveTypeResult {
        // If there's a declared type, it takes precedence over inferred types.
        if (symbol.hasTypedDeclarations()) {
            const declaredType = this.getDeclaredTypeOfSymbol(symbol, usageNode);
            const typedDecls = symbol.getTypedDeclarations();
            let isIncomplete = false;

            if (declaredType) {
                if (isFunction(declaredType) && FunctionType.isPartiallyEvaluated(declaredType)) {
                    isIncomplete = true;
                } else if (isClass(declaredType) && ClassType.isPartiallyEvaluated(declaredType)) {
                    isIncomplete = true;
                }
            }

            return {
                type: declaredType ?? UnknownType.create(),
                isIncomplete,
                includesVariableDecl: typedDecls.some((decl) => decl.type === DeclarationType.Variable),
                includesIllegalTypeAliasDecl: !typedDecls.every((decl) => isPossibleTypeAliasDeclaration(decl)),
                isRecursiveDefinition: !declaredType,
            };
        }

        // Look in the cache to see if we've computed this already.
        let cacheEntries = this._effectiveTypeCache.get(symbol.id);
        let evaluationAttempts = 0;
        const usageNodeId = usageNode ? usageNode.id : undefined;
        const effectiveTypeCacheKey = `${usageNodeId === undefined ? '.' : usageNodeId.toString()}${
            useLastDecl ? '*' : ''
        }`;
        if (cacheEntries) {
            const result = cacheEntries.get(effectiveTypeCacheKey);
            if (result) {
                if (!result.isIncomplete) {
                    return result;
                }

                evaluationAttempts = (result.evaluationAttempts ?? 0) + 1;
            }
        }

        // Infer the type.
        const typesToCombine: Type[] = [];
        const decls = symbol.getDeclarations();
        const isFinalVar = isFinalVariable(symbol);
        let isIncomplete = false;
        let sawPendingEvaluation = false;
        let includesVariableDecl = false;
        let includesSpeculativeResult = false;

        let declIndexToConsider: number | undefined;

        // Limit the number of declarations to explore.
        if (decls.length > maxDeclarationsToUseForInference) {
            return {
                type: UnknownType.create(),
                isIncomplete: false,
                includesVariableDecl: false,
                includesIllegalTypeAliasDecl: !decls.every((decl) => isPossibleTypeAliasDeclaration(decl)),
                isRecursiveDefinition: false,
            };
        }

        // If the caller has requested that we use only the last decl, we
        // will use only the last one, but we'll ignore decls that are in
        // except clauses.
        if (useLastDecl) {
            decls.forEach((decl, index) => {
                if (!decl.isInExceptSuite) {
                    declIndexToConsider = index;
                }
            });
        }

        let sawExplicitTypeAlias = false;
        decls.forEach((decl, index) => {
            let considerDecl = declIndexToConsider === undefined || index === declIndexToConsider;

            // If we have already seen an explicit type alias, do not consider
            // additional decls. This can happen if multiple TypeAlias declarations
            // are provided -- normally an error, but it can happen in stdlib stubs
            // if the user sets the pythonPlatform to "All".
            if (sawExplicitTypeAlias) {
                considerDecl = false;
            }

            if (usageNode !== undefined) {
                if (decl.type !== DeclarationType.Alias) {
                    // Is the declaration in the same execution scope as the "usageNode" node?
                    const usageScope = ParseTreeUtils.getExecutionScopeNode(usageNode);
                    const declScope = ParseTreeUtils.getExecutionScopeNode(decl.node);
                    if (usageScope === declScope) {
                        if (!this.isFlowPathBetweenNodes(decl.node, usageNode)) {
                            considerDecl = false;
                        }
                    }
                }
            }

            if (considerDecl) {
                const isExplicitTypeAlias = isExplicitTypeAliasDeclaration(decl);
                const isTypeAlias = isExplicitTypeAlias || this.isPossibleTypeAliasOrTypedDict(decl);

                if (isExplicitTypeAlias) {
                    sawExplicitTypeAlias = true;
                }

                // If this is a type alias, evaluate it outside of the recursive symbol
                // resolution check so we can evaluate the full assignment statement.
                if (
                    isTypeAlias &&
                    decl.type === DeclarationType.Variable &&
                    decl.inferredTypeSource?.parent?.nodeType === ParseNodeType.Assignment
                ) {
                    this.evaluateTypesForAssignmentStatement(decl.inferredTypeSource.parent);

                    if (decl.typeAliasAnnotation) {
                        // Mark "TypeAlias" declaration as accessed.
                        this.getTypeOfAnnotation(decl.typeAliasAnnotation, {
                            isVariableAnnotation: true,
                            allowFinal: ParseTreeUtils.isFinalAllowedForAssignmentTarget(decl.node),
                            allowClassVar: ParseTreeUtils.isClassVarAllowedForAssignmentTarget(decl.node),
                        });
                    }
                }

                if (this.pushSymbolResolution(symbol, decl)) {
                    try {
                        let type = this.getInferredTypeOfDeclaration(symbol, decl);

                        if (!this.popSymbolResolution(symbol)) {
                            isIncomplete = true;
                        }

                        if (type) {
                            if (decl.type === DeclarationType.Variable) {
                                includesVariableDecl = true;

                                let isConstant = decl.type === DeclarationType.Variable && !!decl.isConstant;

                                // Treat enum values declared within an enum class as though they are const even
                                // though they may not be named as such.
                                if (
                                    isClassInstance(type) &&
                                    ClassType.isEnumClass(type) &&
                                    isDeclInEnumClass(this, decl)
                                ) {
                                    isConstant = true;
                                }

                                // If the symbol is constant, we can retain the literal
                                // value. Otherwise, strip literal values to widen the type.
                                if (TypeBase.isInstance(type) && !isExplicitTypeAlias && !isConstant && !isFinalVar) {
                                    type = this.stripLiteralValue(type);
                                }
                            }
                            typesToCombine.push(type);

                            if (this._speculativeTypeTracker.isSpeculative(decl.node)) {
                                includesSpeculativeResult = true;
                            }
                        } else {
                            isIncomplete = true;
                        }
                    } catch (e: any) {
                        // Clean up the stack before rethrowing.
                        this.popSymbolResolution(symbol);
                        throw e;
                    }
                } else {
                    // If this resolves to a class decl, we can use a partially-evaluated
                    // version of the class type.
                    const resolvedDecl = this.resolveAliasDeclaration(
                        decl,
                        /* resolveLocalNames */ true,
                        /* allowExternallyHiddenAccess */ AnalyzerNodeInfo.getFileInfo(decl.node).isStubFile
                    );

                    if (resolvedDecl?.type === DeclarationType.Class) {
                        const classTypeInfo = this.getTypeOfClass(resolvedDecl.node);
                        if (classTypeInfo?.decoratedType) {
                            typesToCombine.push(classTypeInfo.decoratedType);
                        }
                    }

                    isIncomplete = true;

                    // Note that at least one decl could not be evaluated because
                    // it was already in the process of being evaluated. Don't set
                    // this flag if we've already attempted the type evaluation
                    // many times because this probably means there's a cyclical
                    // dependency that cannot be broken.
                    if (evaluationAttempts < maxEffectiveTypeEvaluationAttempts) {
                        sawPendingEvaluation = true;
                    }
                }
            }
        });

        if (typesToCombine.length > 0) {
            const result: EffectiveTypeResult = {
                type: combineTypes(typesToCombine),
                isIncomplete: sawPendingEvaluation,
                includesVariableDecl,
                includesIllegalTypeAliasDecl: !decls.every((decl) => isPossibleTypeAliasDeclaration(decl)),
                isRecursiveDefinition: false,
                evaluationAttempts,
            };

            if (!includesSpeculativeResult) {
                // Add the entry to the cache so we don't need to compute it next time.
                if (!cacheEntries) {
                    cacheEntries = new Map<string, EffectiveTypeResult>();
                    this._effectiveTypeCache.set(symbol.id, cacheEntries);
                }

                cacheEntries.set(effectiveTypeCacheKey, result);
            }

            return result;
        }

        return {
            type: UnboundType.create(),
            isIncomplete,
            includesVariableDecl,
            includesIllegalTypeAliasDecl: !decls.every((decl) => isPossibleTypeAliasDeclaration(decl)),
            isRecursiveDefinition: false,
            evaluationAttempts,
        };
    }

    getDeclaredTypeOfSymbol(symbol: Symbol, usageNode?: NameNode): Type | undefined {
        const synthesizedType = symbol.getSynthesizedType();
        if (synthesizedType) {
            return synthesizedType;
        }

        let typedDecls = symbol.getTypedDeclarations();

        if (typedDecls.length === 0) {
            // There was no declaration with a defined type.
            return undefined;
        }

        // If there is more than one typed decl, filter out any that are not
        // reachable from the usage node (if specified). This can happen in
        // cases where a property symbol is redefined to add a setter, deleter,
        // etc.
        if (usageNode && typedDecls.length > 1) {
            const filteredTypedDecls = typedDecls.filter((decl) => {
                if (decl.type !== DeclarationType.Alias) {
                    // Is the declaration in the same execution scope as the "usageNode" node?
                    const usageScope = ParseTreeUtils.getExecutionScopeNode(usageNode);
                    const declScope = ParseTreeUtils.getExecutionScopeNode(decl.node);

                    if (usageScope === declScope) {
                        if (!this.isFlowPathBetweenNodes(decl.node, usageNode, /* allowSelf */ false)) {
                            return false;
                        }
                    }
                }
                return true;
            });

            if (filteredTypedDecls.length === 0) {
                return UnboundType.create();
            }

            typedDecls = filteredTypedDecls;
        }

        // Start with the last decl. If that's already being resolved,
        // use the next-to-last decl, etc. This can happen when resolving
        // property methods. Often the setter method is defined in reference to
        // the initial property, which defines the getter method with the same
        // symbol name.
        let declIndex = typedDecls.length - 1;
        while (declIndex >= 0) {
            const decl = typedDecls[declIndex];

            // If there's a partially-constructed type that is allowed
            // for recursive symbol resolution, return it as the resolved type.
            const partialType = this.getSymbolResolutionPartialType(symbol, decl);
            if (partialType) {
                return partialType;
            }

            if (this.getIndexOfSymbolResolution(symbol, decl) < 0) {
                if (this.pushSymbolResolution(symbol, decl)) {
                    try {
                        const type = this.getTypeForDeclaration(decl);

                        // If there was recursion detected, don't use this declaration.
                        // The exception is it's a class declaration because getTypeOfClass
                        // handles recursion by populating a partially-created class type
                        // in the type cache. This exception is required to handle the
                        // circular dependency between the "type" and "object" classes in
                        // builtins.pyi (since "object" is a "type" and "type" is an "object").
                        if (this.popSymbolResolution(symbol) || decl.type === DeclarationType.Class) {
                            return type;
                        }
                    } catch (e: any) {
                        // Clean up the stack before rethrowing.
                        this.popSymbolResolution(symbol);
                        throw e;
                    }
                }
            }

            declIndex--;
        }

        return undefined;
    }

    inferReturnTypeIfNecessary(type: Type) {
        if (isFunction(type)) {
            this.getFunctionEffectiveReturnType(type);
        } else if (isOverloadedFunction(type)) {
            type.overloads.forEach((overload) => {
                this.getFunctionEffectiveReturnType(overload);
            });
        }
    }

    // Returns the return type of the function. If the type is explicitly provided in
    // a type annotation, that type is returned. If not, an attempt is made to infer
    // the return type. If a list of args is provided, the inference logic may take
    // into account argument types to infer the return type.
    getFunctionEffectiveReturnType(type: FunctionType, args?: ValidateArgTypeParams[], inferTypeIfNeeded = true) {
        const specializedReturnType = FunctionType.getSpecializedReturnType(type);
        if (specializedReturnType) {
            return this.adjustCallableReturnType(specializedReturnType);
        }

        if (inferTypeIfNeeded) {
            return this.getFunctionInferredReturnType(type, args);
        }

        return UnknownType.create();
    }

    getFunctionInferredReturnType(type: FunctionType, args?: ValidateArgTypeParams[]) {
        let returnType: Type | undefined;
        let isIncomplete = false;
        let analyzeUnannotatedFunctions = true;

        // Don't attempt to infer the return type for a stub file.
        if (FunctionType.isStubDefinition(type)) {
            return UnknownType.create();
        }

        // If the return type has already been lazily evaluated,
        // don't bother computing it again.
        if (type.inferredReturnType) {
            returnType = type.inferredReturnType;
        } else {
            // Don't bother inferring the return type of __init__ because it's
            // always None.
            if (FunctionType.isInstanceMethod(type) && type.details.name === '__init__') {
                returnType = NoneType.createInstance();
            } else if (type.details.declaration) {
                const functionNode = type.details.declaration.node;
                analyzeUnannotatedFunctions =
                    AnalyzerNodeInfo.getFileInfo(functionNode).diagnosticRuleSet.analyzeUnannotatedFunctions;

                // Skip return type inference if we are in "skip unannotated function" mode.
                if (analyzeUnannotatedFunctions && !this.checkCodeFlowTooComplex(functionNode.suite)) {
                    const codeFlowComplexity = AnalyzerNodeInfo.getCodeFlowComplexity(functionNode);

                    // For very complex functions that have no annotated parameter types,
                    // don't attempt to infer the return type because it can be extremely
                    // expensive.
                    const parametersAreAnnotated =
                        type.details.parameters.length <= 1 ||
                        type.details.parameters.some((param) => param.hasDeclaredType);

                    if (parametersAreAnnotated || codeFlowComplexity < maxReturnTypeInferenceCodeFlowComplexity) {
                        // Temporarily disable speculative mode while we
                        // lazily evaluate the return type.
                        let returnTypeResult: TypeResult | undefined;
                        this.disableSpeculativeMode(() => {
                            returnTypeResult = this.inferFunctionReturnType(
                                functionNode,
                                FunctionType.isAbstractMethod(type)
                            );
                        });

                        returnType = returnTypeResult?.type;
                        if (returnTypeResult?.isIncomplete) {
                            isIncomplete = true;
                        }

                        // Do we need to wrap this in an awaitable?
                        if (returnType && FunctionType.isWrapReturnTypeInAwait(type)) {
                            returnType = this.createAwaitableReturnType(
                                functionNode,
                                returnType,
                                !!type.details.declaration?.isGenerator
                            );
                        }
                    }
                }
            }

            if (!returnType) {
                returnType = UnknownType.create();
            }

            // Cache the type for next time.
            if (!isIncomplete) {
                type.inferredReturnType = returnType;
            }
        }

        // If the type is partially unknown and the function has one or more unannotated
        // params, try to analyze the function with the provided argument types and
        // attempt to do a better job at inference.
        if (
            !isIncomplete &&
            analyzeUnannotatedFunctions &&
            isPartlyUnknown(returnType) &&
            FunctionType.hasUnannotatedParams(type) &&
            !FunctionType.isStubDefinition(type) &&
            !FunctionType.isPyTypedDefinition(type) &&
            args
        ) {
            const contextualReturnType = this.getFunctionInferredReturnTypeUsingArguments(type, args);
            if (contextualReturnType) {
                returnType = contextualReturnType;
            }
        }

        return returnType;
    }

    getFunctionInferredReturnTypeUsingArguments(type: FunctionType, args: ValidateArgTypeParams[]): Type | undefined {
        let contextualReturnType: Type | undefined;

        if (!type.details.declaration) {
            return undefined;
        }
        const functionNode = type.details.declaration.node;
        const codeFlowComplexity = AnalyzerNodeInfo.getCodeFlowComplexity(functionNode);

        if (codeFlowComplexity >= maxReturnCallSiteTypeInferenceCodeFlowComplexity) {
            return undefined;
        }

        // If an arg hasn't been matched to a specific named parameter,
        // it's an unpacked value that corresponds to multiple parameters.
        // That's an edge case that we don't handle here.
        if (args.some((arg) => !arg.paramName)) {
            return undefined;
        }

        // Detect recurrence. If a function invokes itself either directly
        // or indirectly, we won't attempt to infer contextual return
        // types any further.
        if (this._returnTypeInferenceContextStack.some((context) => context.functionNode === functionNode)) {
            return undefined;
        }

        const functionType = this.getTypeOfFunction(functionNode);
        if (!functionType) {
            return undefined;
        }

        // Very complex functions with many arguments can take a long time to analyze,
        // so we'll use a heuristic and avoiding this inference technique for any
        // call site that involves too many arguments.
        if (args.length > maxReturnTypeInferenceArgumentCount) {
            return undefined;
        }

        // Don't explore arbitrarily deep in the call graph.
        if (this._returnTypeInferenceContextStack.length >= maxReturnTypeInferenceStackSize) {
            return undefined;
        }

        const paramTypes: Type[] = [];
        let isResultFromCache = false;

        // Suppress diagnostics because we don't want to generate errors.
        this.suppressDiagnostics(functionNode, () => {
            // Allocate a new temporary type cache for the context of just
            // this function so we can analyze it separately without polluting
            // the main type cache.
            const prevTypeCache = this._returnTypeInferenceTypeCache;
            this._returnTypeInferenceContextStack.push({
                functionNode,
                codeFlowAnalyzer: this._codeFlowEngine.createCodeFlowAnalyzer(),
            });

            try {
                this._returnTypeInferenceTypeCache = new Map<number, CachedType>();

                let allArgTypesAreUnknown = true;
                functionNode.parameters.forEach((param, index) => {
                    if (param.name) {
                        let paramType: Type | undefined;
                        const arg = args.find((arg) => param.name!.value === arg.paramName);

                        if (arg && arg.argument.valueExpression) {
                            paramType = this.getTypeOfExpression(arg.argument.valueExpression).type;
                            if (!isUnknown(paramType)) {
                                allArgTypesAreUnknown = false;
                            }
                        } else if (param.defaultValue) {
                            paramType = this.getTypeOfExpression(param.defaultValue).type;
                            if (!isUnknown(paramType)) {
                                allArgTypesAreUnknown = false;
                            }
                        } else if (index === 0) {
                            // If this is an instance or class method, use the implied
                            // parameter type for the "self" or "cls" parameter.
                            if (
                                FunctionType.isInstanceMethod(functionType.functionType) ||
                                FunctionType.isClassMethod(functionType.functionType)
                            ) {
                                if (functionType.functionType.details.parameters.length > 0) {
                                    if (functionNode.parameters[0].name) {
                                        paramType = functionType.functionType.details.parameters[0].type;
                                    }
                                }
                            }
                        }

                        if (!paramType) {
                            paramType = UnknownType.create();
                        }

                        paramTypes.push(paramType);
                        this.writeTypeCache(param.name, paramType, EvaluatorFlags.None, /* isIncomplete */ false);
                    }
                });

                // Don't bother trying to determine the contextual return
                // type if none of the argument types are known.
                if (!allArgTypesAreUnknown) {
                    // See if the return type is already cached. If so, skip the
                    // inference step, which is potentially very expensive.
                    const cacheEntry = functionType.functionType.callSiteReturnTypeCache?.find((entry) => {
                        return (
                            entry.paramTypes.length === paramTypes.length &&
                            entry.paramTypes.every((t, i) => isTypeSame(t, paramTypes[i]))
                        );
                    });

                    if (cacheEntry) {
                        contextualReturnType = cacheEntry.returnType;
                        isResultFromCache = true;
                    } else {
                        contextualReturnType = this.inferFunctionReturnType(
                            functionNode,
                            FunctionType.isAbstractMethod(type)
                        )?.type;
                    }
                }
            } finally {
                this._returnTypeInferenceContextStack.pop();
                this._returnTypeInferenceTypeCache = prevTypeCache;
            }
        });

        if (contextualReturnType) {
            contextualReturnType = removeUnbound(contextualReturnType);

            // Do we need to wrap this in an awaitable?
            if (FunctionType.isWrapReturnTypeInAwait(type) && !isNever(contextualReturnType)) {
                contextualReturnType = this.createAwaitableReturnType(
                    functionNode,
                    contextualReturnType,
                    !!type.details.declaration?.isGenerator
                );
            }

            if (!isResultFromCache) {
                // Cache the resulting type.
                if (!functionType.functionType.callSiteReturnTypeCache) {
                    functionType.functionType.callSiteReturnTypeCache = [];
                }
                if (functionType.functionType.callSiteReturnTypeCache.length >= maxCallSiteReturnTypeCacheSize) {
                    functionType.functionType.callSiteReturnTypeCache =
                        functionType.functionType.callSiteReturnTypeCache.slice(1);
                }
                functionType.functionType.callSiteReturnTypeCache.push({
                    paramTypes,
                    returnType: contextualReturnType,
                });
            }

            return contextualReturnType;
        }

        return undefined;
    }

    getFunctionDeclaredReturnType(node: FunctionNode): Type | undefined {
        const functionTypeInfo = this.getTypeOfFunction(node)!;
        if (!functionTypeInfo) {
            // We hit a recursive dependency.
            return AnyType.create();
        }

        // Ignore this check for abstract methods, which often
        // don't actually return any value.
        if (FunctionType.isAbstractMethod(functionTypeInfo.functionType)) {
            return AnyType.create();
        }

        if (FunctionType.isGenerator(functionTypeInfo.functionType)) {
            return getDeclaredGeneratorReturnType(functionTypeInfo.functionType);
        }

        return functionTypeInfo.functionType.details.declaredReturnType;
    }

    getTypeOfMember(member: ClassMember): Type {
        if (isInstantiableClass(member.classType)) {
            return partiallySpecializeType(
                this.getEffectiveTypeOfSymbol(member.symbol),
                member.classType,
                /* selfClass */ undefined,
                this._typeClassType ?? UnknownType.create()
            );
        }
        return UnknownType.create();
    }

    getTypeOfMemberInternal(member: ClassMember, selfClass: ClassType | undefined): TypeResult | undefined {
        if (isInstantiableClass(member.classType)) {
            const typeResult = this.getEffectiveTypeOfSymbolForUsage(member.symbol);

            if (typeResult) {
                // If the type is a function or overloaded function, infer
                // and cache the return type if necessary. This needs to be done
                // prior to specializing.
                this.inferReturnTypeIfNecessary(typeResult.type);

                return {
                    type: partiallySpecializeType(typeResult.type, member.classType, selfClass),
                    isIncomplete: !!typeResult.isIncomplete,
                };
            }
        }

        return undefined;
    }

    assignClass(
        destType: ClassType,
        srcType: ClassType,
        diag: DiagnosticAddendum | undefined,
        destTypeVarContext: TypeVarContext | undefined,
        srcTypeVarContext: TypeVarContext | undefined,
        flags: AssignTypeFlags,
        recursionCount: number,
        reportErrorsUsingObjType: boolean
    ): boolean {
        // If the source or dest types are partially evaluated (i.e. they are in the
        // process of being constructed), assume they are assignable rather than risk
        // emitting false positives.
        if (ClassType.isHierarchyPartiallyEvaluated(destType) || ClassType.isHierarchyPartiallyEvaluated(srcType)) {
            return true;
        }

        // Handle typed dicts. They also use a form of structural typing for type
        // checking, as defined in PEP 589.
        if (
            ClassType.isTypedDictClass(destType) &&
            ClassType.isTypedDictClass(srcType) &&
            !ClassType.isSameGenericClass(destType, srcType)
        ) {
            if (!assignTypedDictToTypedDict(this, destType, srcType, diag, destTypeVarContext, flags, recursionCount)) {
                return false;
            }

            if (ClassType.isFinal(destType) !== ClassType.isFinal(srcType)) {
                diag?.addMessage(
                    Localizer.DiagnosticAddendum.typedDictFinalMismatch().format({
                        sourceType: this.printType(convertToInstance(srcType)),
                        destType: this.printType(convertToInstance(destType)),
                    })
                );
                return false;
            }

            // If invariance is being enforced, the two TypedDicts must be assignable to each other.
            if ((flags & AssignTypeFlags.EnforceInvariance) !== 0) {
                return assignTypedDictToTypedDict(
                    this,
                    srcType,
                    destType,
                    /* diag */ undefined,
                    /* typeVarContext */ undefined,
                    flags,
                    recursionCount
                );
            }

            return true;
        }

        // Handle special-case type promotions.
        const promotionList = typePromotions.get(destType.details.fullName);
        if (
            promotionList &&
            promotionList.some((srcName) =>
                srcType.details.mro.some((mroClass) => isClass(mroClass) && srcName === mroClass.details.fullName)
            )
        ) {
            if ((flags & AssignTypeFlags.EnforceInvariance) === 0) {
                return true;
            }
        }

        // Is it a structural type (i.e. a protocol)? If so, we need to
        // perform a member-by-member check.
        const inheritanceChain: InheritanceChain = [];
        const isDerivedFrom = ClassType.isDerivedFrom(srcType, destType, inheritanceChain);

        // Use the slow path for protocols if the dest doesn't explicitly
        // derive from the source. We also need to use this path if we're
        // testing to see if the metaclass matches the protocol.
        if (ClassType.isProtocolClass(destType) && !isDerivedFrom) {
            if (
                !assignClassToProtocol(
                    this,
                    destType,
                    srcType,
                    diag?.createAddendum(),
                    destTypeVarContext,
                    srcTypeVarContext,
                    flags,
                    /* treatSourceAsInstantiable */ false,
                    recursionCount
                )
            ) {
                diag?.addMessage(
                    Localizer.DiagnosticAddendum.protocolIncompatible().format({
                        sourceType: this.printType(convertToInstance(srcType)),
                        destType: this.printType(convertToInstance(destType)),
                    })
                );
                return false;
            }

            return true;
        }

        if ((flags & AssignTypeFlags.EnforceInvariance) === 0 || ClassType.isSameGenericClass(srcType, destType)) {
            if (isDerivedFrom) {
                assert(inheritanceChain.length > 0);

                if (
                    this.assignClassWithTypeArgs(
                        destType,
                        srcType,
                        inheritanceChain,
                        diag?.createAddendum(),
                        destTypeVarContext,
                        srcTypeVarContext,
                        flags,
                        recursionCount
                    )
                ) {
                    return true;
                }
            }
        }

        // Everything is assignable to an object.
        if (ClassType.isBuiltIn(destType, 'object')) {
            if ((flags & AssignTypeFlags.EnforceInvariance) === 0) {
                return true;
            }
        }

        const destErrorType = reportErrorsUsingObjType ? ClassType.cloneAsInstance(destType) : destType;
        const srcErrorType = reportErrorsUsingObjType ? ClassType.cloneAsInstance(srcType) : srcType;

        let destErrorTypeText = this.printType(destErrorType);
        let srcErrorTypeText = this.printType(srcErrorType);

        // If the text is the same, use the fully-qualified name rather than the short name.
        if (destErrorTypeText === srcErrorTypeText && destType.details.fullName && srcType.details.fullName) {
            destErrorTypeText = destType.details.fullName;
            srcErrorTypeText = srcType.details.fullName;
        }

        diag?.addMessage(
            Localizer.DiagnosticAddendum.typeIncompatible().format({
                sourceType: srcErrorTypeText,
                destType: destErrorTypeText,
            })
        );
        return false;
    }

    // This function is used to validate or infer the variance of type
    // parameters within a class.
    assignClassToSelf(destType: ClassType, srcType: ClassType, recursionCount = 0): boolean {
        assert(ClassType.isSameGenericClass(destType, srcType));
        assert(destType.details.typeParameters.length > 0);

        const diag = new DiagnosticAddendum();
        const typeVarContext = new TypeVarContext();
        let isAssignable = true;

        destType.details.fields.forEach((symbol, name) => {
            if (isAssignable && symbol.isClassMember() && !symbol.isIgnoredForProtocolMatch()) {
                const memberInfo = lookUpClassMember(srcType, name);
                assert(memberInfo !== undefined);

                let destMemberType = this.getDeclaredTypeOfSymbol(symbol);
                if (destMemberType) {
                    const srcMemberType = this.getTypeOfMember(memberInfo!);
                    destMemberType = partiallySpecializeType(destMemberType, destType);

                    // Properties require special processing.
                    if (
                        isClassInstance(destMemberType) &&
                        ClassType.isPropertyClass(destMemberType) &&
                        isClassInstance(srcMemberType) &&
                        ClassType.isPropertyClass(srcMemberType)
                    ) {
                        if (
                            !assignProperty(
                                this,
                                ClassType.cloneAsInstantiable(destMemberType),
                                ClassType.cloneAsInstantiable(srcMemberType),
                                destType,
                                srcType,
                                diag,
                                typeVarContext,
                                /* selfTypeVarContext */ undefined,
                                recursionCount
                            )
                        ) {
                            isAssignable = false;
                        }
                    } else {
                        const primaryDecl = symbol.getDeclarations()[0];
                        // Class and instance variables that are mutable need to
                        // enforce invariance.
                        const flags =
                            primaryDecl?.type === DeclarationType.Variable && !primaryDecl.isFinal
                                ? AssignTypeFlags.EnforceInvariance
                                : AssignTypeFlags.Default;
                        if (
                            !this.assignType(
                                destMemberType,
                                srcMemberType,
                                diag,
                                typeVarContext,
                                /* srcTypeVarContext */ undefined,
                                flags,
                                recursionCount
                            )
                        ) {
                            isAssignable = false;
                        }
                    }
                }
            }
        });

        // Now handle generic base classes.
        destType.details.baseClasses.forEach((baseClass) => {
            if (
                isInstantiableClass(baseClass) &&
                !ClassType.isBuiltIn(baseClass, 'object') &&
                !ClassType.isBuiltIn(baseClass, 'Protocol') &&
                !ClassType.isBuiltIn(baseClass, 'Generic') &&
                baseClass.details.typeParameters.length > 0
            ) {
                const specializedDestBaseClass = specializeForBaseClass(destType, baseClass);
                const specializedSrcBaseClass = specializeForBaseClass(srcType, baseClass);
                if (!this.assignClassToSelf(specializedDestBaseClass, specializedSrcBaseClass, recursionCount)) {
                    isAssignable = false;
                }
            }
        });

        return isAssignable;
    }

    assignTupleTypeArgs(
        destType: ClassType,
        srcType: ClassType,
        diag: DiagnosticAddendum | undefined,
        typeVarContext: TypeVarContext | undefined,
        flags: AssignTypeFlags,
        recursionCount: number
    ) {
        const destTypeArgs = [...(destType.tupleTypeArguments ?? [])];
        const srcTypeArgs = [...(srcType.tupleTypeArguments ?? [])];

        const destVariadicIndex = destTypeArgs.findIndex((t) => isVariadicTypeVar(t.type));
        const destUnboundedIndex = destTypeArgs.findIndex((t) => t.isUnbounded);
        const srcUnboundedIndex = srcTypeArgs.findIndex((t) => t.isUnbounded);

        // If the source is unbounded, expand the unbounded argument to try
        // to make the source and dest arg counts match.
        if (srcUnboundedIndex >= 0) {
            const typeToReplicate = srcTypeArgs.length > 0 ? srcTypeArgs[srcUnboundedIndex].type : AnyType.create();

            while (srcTypeArgs.length < destTypeArgs.length) {
                srcTypeArgs.splice(srcUnboundedIndex, 0, { type: typeToReplicate, isUnbounded: true });
            }
        }

        // If the dest is unbounded or contains a variadic, determine which
        // source args map to the unbounded or variadic arg.
        if (destUnboundedIndex >= 0 || destVariadicIndex >= 0) {
            // If there's a variadic within the destination, package up the corresponding
            // source arguments into a tuple.
            const srcArgsToCapture = srcTypeArgs.length - destTypeArgs.length + 1;
            if (srcArgsToCapture >= 0) {
                if (destVariadicIndex >= 0) {
                    if (this._tupleClassType && isInstantiableClass(this._tupleClassType)) {
                        const removedArgs = srcTypeArgs.splice(destVariadicIndex, srcArgsToCapture);

                        // Package up the remaining type arguments into a tuple object.
                        const variadicTuple = convertToInstance(
                            specializeTupleClass(
                                this._tupleClassType,
                                removedArgs.map((typeArg) => {
                                    return {
                                        type: this.stripLiteralValue(typeArg.type),
                                        isUnbounded: typeArg.isUnbounded,
                                    };
                                }),
                                /* isTypeArgumentExplicit */ true,
                                /* isUnpackedTuple */ true
                            )
                        );
                        srcTypeArgs.splice(destVariadicIndex, 0, {
                            type: variadicTuple,
                            isUnbounded: false,
                        });
                    }
                } else {
                    const removedArgTypes = srcTypeArgs.splice(destUnboundedIndex, srcArgsToCapture).map((t) => {
                        if (isTypeVar(t.type) && isUnpackedVariadicTypeVar(t.type) && !t.type.isVariadicInUnion) {
                            return TypeVarType.cloneForUnpacked(t.type, /* isInUnion */ true);
                        }
                        return t.type;
                    });
                    srcTypeArgs.splice(destUnboundedIndex, 0, {
                        type: removedArgTypes.length > 0 ? combineTypes(removedArgTypes) : AnyType.create(),
                        isUnbounded: false,
                    });
                }
            }
        }

        if (srcTypeArgs.length === destTypeArgs.length) {
            for (let argIndex = 0; argIndex < srcTypeArgs.length; argIndex++) {
                const entryDiag = diag?.createAddendum();

                if (
                    !this.assignType(
                        destTypeArgs[argIndex].type,
                        srcTypeArgs[argIndex].type,
                        entryDiag?.createAddendum(),
                        typeVarContext,
                        /* srcTypeVarContext */ undefined,
                        flags | AssignTypeFlags.RetainLiteralsForTypeVar,
                        recursionCount
                    )
                ) {
                    if (entryDiag) {
                        entryDiag.addMessage(
                            Localizer.DiagnosticAddendum.tupleEntryTypeMismatch().format({
                                entry: argIndex + 1,
                            })
                        );
                    }
                    return false;
                }
            }
        } else {
            if (srcUnboundedIndex >= 0) {
                // PEP 646 allows an indeterminate tuple type to be assigned to
                // a determinate tuple type if it's associated with a TypeVarTuple.
                if (!destType.isUnpacked) {
                    diag?.addMessage(
                        Localizer.DiagnosticAddendum.tupleSizeMismatchIndeterminate().format({
                            expected: destTypeArgs.length,
                        })
                    );

                    return false;
                }
            } else {
                diag?.addMessage(
                    Localizer.DiagnosticAddendum.tupleSizeMismatch().format({
                        expected: destTypeArgs.length,
                        received: srcTypeArgs.length,
                    })
                );

                return false;
            }
        }

        return true;
    }

    // Determines whether the specified type can be assigned to the
    // specified inheritance chain, taking into account its type arguments.
    assignClassWithTypeArgs(
        destType: ClassType,
        srcType: ClassType,
        inheritanceChain: InheritanceChain,
        diag: DiagnosticAddendum | undefined,
        destTypeVarContext: TypeVarContext | undefined,
        srcTypeVarContext: TypeVarContext | undefined,
        flags: AssignTypeFlags,
        recursionCount: number
    ): boolean {
        let curSrcType = srcType;
        let curTypeVarContext = destTypeVarContext;
        let effectiveFlags = flags;

        this.inferTypeParameterVarianceForClass(destType);

        effectiveFlags |= AssignTypeFlags.SkipSolveTypeVars;

        if (!destTypeVarContext) {
            curTypeVarContext = new TypeVarContext(getTypeVarScopeId(destType));
            effectiveFlags &= ~AssignTypeFlags.SkipSolveTypeVars;
        } else {
            // If we're using the caller's type var context, don't solve the
            // type vars in this pass. We'll do this after we're done looping
            // through the inheritance chain.
            effectiveFlags |= AssignTypeFlags.SkipSolveTypeVars;
        }

        for (let ancestorIndex = inheritanceChain.length - 1; ancestorIndex >= 0; ancestorIndex--) {
            const ancestorType = inheritanceChain[ancestorIndex];

            // If we've hit an "unknown", all bets are off, and we need to assume
            // that the type is assignable.
            if (isUnknown(ancestorType)) {
                return true;
            }

            // If we've hit an 'object', it's assignable.
            if (ClassType.isBuiltIn(ancestorType, 'object')) {
                return true;
            }

            // If this isn't the first time through the loop, specialize
            // for the next ancestor in the chain.
            if (ancestorIndex < inheritanceChain.length - 1) {
                curSrcType = specializeForBaseClass(curSrcType, ancestorType);
            }

            // Handle built-in types that support arbitrary numbers
            // of type parameters like Tuple.
            if (ancestorIndex === 0 && destType.tupleTypeArguments && curSrcType.tupleTypeArguments) {
                return this.assignTupleTypeArgs(destType, curSrcType, diag, curTypeVarContext, flags, recursionCount);
            }

            // If there are no type parameters on this class, we're done.
            const ancestorTypeParams = ClassType.getTypeParameters(ancestorType);
            if (ancestorTypeParams.length === 0) {
                continue;
            }

            // If the dest type isn't specialized, there are no type args to validate.
            if (!ancestorType.typeArguments) {
                return true;
            }

            // Validate that the type arguments match.
            if (
                !this.verifyTypeArgumentsAssignable(
                    ancestorType,
                    curSrcType,
                    diag,
                    curTypeVarContext,
                    /* srcTypeVarContext */ undefined,
                    effectiveFlags,
                    recursionCount
                )
            ) {
                return false;
            }

            // Allocate a new type var map for the next time through the loop.
            curTypeVarContext = new TypeVarContext(getTypeVarScopeId(ancestorType));
            effectiveFlags &= ~AssignTypeFlags.SkipSolveTypeVars;
        }

        if (destType.typeArguments) {
            // If the dest type is specialized, make sure the specialized source
            // type arguments are assignable to the dest type arguments.
            if (
                !this.verifyTypeArgumentsAssignable(
                    destType,
                    curSrcType,
                    diag,
                    destTypeVarContext,
                    srcTypeVarContext,
                    flags,
                    recursionCount
                )
            ) {
                return false;
            }
        } else if (
            destTypeVarContext &&
            destType.details.typeParameters.length > 0 &&
            curSrcType.typeArguments &&
            !destTypeVarContext.isLocked()
        ) {
            // Populate the typeVar map with type arguments of the source.
            const srcTypeArgs = curSrcType.typeArguments;
            for (let i = 0; i < destType.details.typeParameters.length; i++) {
                const typeArgType = i < srcTypeArgs.length ? srcTypeArgs[i] : UnknownType.create();
                destTypeVarContext.setTypeVarType(
                    destType.details.typeParameters[i],
                    /* narrowBound */ undefined,
                    typeArgType
                );
            }
        }

        return true;
    }

    getGetterTypeFromProperty(propertyClass: ClassType, inferTypeIfNeeded: boolean): Type | undefined {
        if (!ClassType.isPropertyClass(propertyClass)) {
            return undefined;
        }

        const fgetSymbol = propertyClass.details.fields.get('fget');

        if (fgetSymbol) {
            const fgetType = this.getDeclaredTypeOfSymbol(fgetSymbol);
            if (fgetType && isFunction(fgetType)) {
                return this.getFunctionEffectiveReturnType(fgetType, /* args */ undefined, inferTypeIfNeeded);
            }
        }

        return undefined;
    }

    verifyTypeArgumentsAssignable(
        destType: ClassType,
        srcType: ClassType,
        diag: DiagnosticAddendum | undefined,
        destTypeVarContext: TypeVarContext | undefined,
        srcTypeVarContext: TypeVarContext | undefined,
        flags: AssignTypeFlags,
        recursionCount: number
    ): boolean {
        assert(ClassType.isSameGenericClass(destType, srcType));

        this.inferTypeParameterVarianceForClass(destType);

        const destTypeParams = ClassType.getTypeParameters(destType);
        let destTypeArgs: Type[];
        let srcTypeArgs: Type[] | undefined;

        // If either source or dest type arguments are missing, they are
        // treated as "Any", so they are assumed to be assignable.
        if (!destType.typeArguments || !srcType.typeArguments) {
            return true;
        }

        if (ClassType.isTupleClass(destType)) {
            destTypeArgs = destType.tupleTypeArguments?.map((t) => t.type) ?? [];
            srcTypeArgs = srcType.tupleTypeArguments?.map((t) => t.type);
        } else {
            destTypeArgs = destType.typeArguments!;
            srcTypeArgs = srcType.typeArguments;
        }

        if (srcTypeArgs) {
            for (let srcArgIndex = 0; srcArgIndex < srcTypeArgs.length; srcArgIndex++) {
                const srcTypeArg = srcTypeArgs[srcArgIndex];

                // In most cases, the number of type args should match the number
                // of type arguments, but there are a few special cases where this
                // isn't true (e.g. assigning a Tuple[X, Y, Z] to a tuple[W]).
                const destArgIndex = srcArgIndex >= destTypeArgs.length ? destTypeArgs.length - 1 : srcArgIndex;
                const destTypeArg = destArgIndex >= 0 ? destTypeArgs[destArgIndex] : UnknownType.create();
                const destTypeParam = destArgIndex < destTypeParams.length ? destTypeParams[destArgIndex] : undefined;
                const assignmentDiag = new DiagnosticAddendum();

                if (!destTypeParam || TypeVarType.getVariance(destTypeParam) === Variance.Covariant) {
                    if (
                        !this.assignType(
                            destTypeArg,
                            srcTypeArg,
                            assignmentDiag,
                            destTypeVarContext,
                            srcTypeVarContext,
                            flags | AssignTypeFlags.RetainLiteralsForTypeVar,
                            recursionCount
                        )
                    ) {
                        if (diag) {
                            if (destTypeParam) {
                                const childDiag = diag.createAddendum();
                                childDiag.addMessage(
                                    Localizer.DiagnosticAddendum.typeVarIsCovariant().format({
                                        name: TypeVarType.getReadableName(destTypeParam),
                                    })
                                );
                                childDiag.addAddendum(assignmentDiag);
                            } else {
                                diag.addAddendum(assignmentDiag);
                            }
                        }
                        return false;
                    }
                } else if (TypeVarType.getVariance(destTypeParam) === Variance.Contravariant) {
                    if (
                        !this.assignType(
                            srcTypeArg,
                            destTypeArg,
                            assignmentDiag,
                            srcTypeVarContext,
                            destTypeVarContext,
                            (flags ^ AssignTypeFlags.ReverseTypeVarMatching) | AssignTypeFlags.RetainLiteralsForTypeVar,
                            recursionCount
                        )
                    ) {
                        if (diag) {
                            const childDiag = diag.createAddendum();
                            childDiag.addMessage(
                                Localizer.DiagnosticAddendum.typeVarIsContravariant().format({
                                    name: TypeVarType.getReadableName(destTypeParam),
                                })
                            );
                            childDiag.addAddendum(assignmentDiag);
                        }
                        return false;
                    }
                } else {
                    if (
                        !this.assignType(
                            destTypeArg,
                            srcTypeArg,
                            assignmentDiag,
                            destTypeVarContext,
                            srcTypeVarContext,
                            flags | AssignTypeFlags.EnforceInvariance,
                            recursionCount
                        )
                    ) {
                        // Don't report errors with type variables in "pseudo-random"
                        // classes since these type variables are not real.
                        if (!ClassType.isPseudoGenericClass(destType)) {
                            if (diag) {
                                const childDiag = diag.createAddendum();
                                childDiag.addMessage(
                                    Localizer.DiagnosticAddendum.typeVarIsInvariant().format({
                                        name: TypeVarType.getReadableName(destTypeParam),
                                    })
                                );
                                childDiag.addAddendum(assignmentDiag);
                            }
                            return false;
                        }
                    }
                }
            }
        }

        return true;
    }

    // Determines if the source type can be assigned to the dest type.
    // If typeVarContext is provided, type variables within the destType are
    // matched against existing type variables in the map. If a type variable
    // in the dest type is not in the type map already, it is assigned a type
    // and added to the map.
    assignType(
        destType: Type,
        srcType: Type,
        diag?: DiagnosticAddendum,
        destTypeVarContext?: TypeVarContext,
        srcTypeVarContext?: TypeVarContext,
        flags = AssignTypeFlags.Default,
        recursionCount = 0
    ): boolean {
        // Handle the case where the dest and src types are the same object.
        // We can normally shortcut this and say that they are compatible,
        // but if the type includes TypeVars, we need to go through
        // the rest of the logic.
        if (destType === srcType && !requiresSpecialization(destType)) {
            return true;
        }

        if (recursionCount > maxTypeRecursionCount) {
            return true;
        }
        recursionCount++;

        // If the source and dest refer to the recursive type aliases, handle
        // the case specially to avoid recursing down both type aliases.
        if (
            isTypeVar(destType) &&
            destType.details.recursiveTypeAliasScopeId &&
            isTypeVar(srcType) &&
            srcType.details.recursiveTypeAliasScopeId
        ) {
            // Do the source and dest refer to the same recursive type alias?
            if (
                destType.typeAliasInfo?.typeArguments &&
                srcType.typeAliasInfo?.typeArguments &&
                destType.details.recursiveTypeAliasScopeId === srcType.details.recursiveTypeAliasScopeId
            ) {
                let isAssignable = true;
                const srcTypeArgs = srcType.typeAliasInfo.typeArguments;
                destType.typeAliasInfo.typeArguments.forEach((destTypeArg, index) => {
                    const srcTypeArg = index < srcTypeArgs.length ? srcTypeArgs[index] : UnknownType.create();
                    if (
                        !this.assignType(
                            destTypeArg,
                            srcTypeArg,
                            diag,
                            destTypeVarContext,
                            srcTypeVarContext,
                            flags,
                            recursionCount
                        )
                    ) {
                        isAssignable = false;
                    }
                });

                return isAssignable;
            } else {
                // Have we already recursed once?
                if ((flags & AssignTypeFlags.SkipRecursiveTypeCheck) !== 0) {
                    return true;
                }

                // Note that we are comparing two recursive types and do
                // not recursive more than once.
                flags |= AssignTypeFlags.SkipRecursiveTypeCheck;
            }
        }

        // Transform recursive type aliases if necessary.
        const transformedDestType = transformPossibleRecursiveTypeAlias(destType);
        const transformedSrcType = transformPossibleRecursiveTypeAlias(srcType);

        // Did both the source and dest include recursive type aliases?
        // If so, we are potentially dealing with different recursive type
        // aliases that are defined in the same way.
        if (
            transformedDestType !== destType &&
            transformedSrcType !== srcType &&
            isUnion(transformedDestType) &&
            isUnion(transformedSrcType)
        ) {
            // Use a smaller recursive limit in this case to prevent runaway recursion.
            if (recursionCount > maxRecursiveTypeAliasRecursionCount) {
                return true;
            }
        }

        destType = transformedDestType;
        srcType = transformedSrcType;

        // If the source or dest is unbound, allow the assignment. The
        // error will be reported elsewhere.
        if (isUnbound(destType) || isUnbound(srcType)) {
            return true;
        }

        // If we're in "overload overlap" mode, convert top-level type variables
        // to their concrete forms in the source.
        if ((flags & AssignTypeFlags.OverloadOverlapCheck) !== 0) {
            srcType = this.makeTopLevelTypeVarsConcrete(srcType);
        }

        // Strip a few of the flags we don't want to propagate to other calls.
        const originalFlags = flags;
        flags &= ~(AssignTypeFlags.AllowBoolTypeGuard | AssignTypeFlags.AllowTypeVarNarrowing);

        // Before performing any other checks, see if the dest type is a
        // TypeVar that we are attempting to match.
        if (isTypeVar(destType)) {
            if (isTypeSame(destType, srcType)) {
                if (destType.scopeId && destTypeVarContext?.hasSolveForScope(destType.scopeId)) {
                    return assignTypeToTypeVar(
                        this,
                        destType,
                        srcType,
                        diag,
                        destTypeVarContext,
                        flags,
                        recursionCount
                    );
                }
                return true;
            }

            // If the dest is a constrained or bound type variable and all of the
            // types in the source are conditioned on that same type variable
            // and have compatible types, we'll consider it assignable.
            if (this.assignConditionalTypeToTypeVar(destType, srcType, recursionCount)) {
                return true;
            }

            // If the source is a conditional type associated with a bound TypeVar
            // and the bound TypeVar matches the condition, the types are compatible.
            const destTypeVar = destType;
            if (
                TypeBase.isInstantiable(destType) === TypeBase.isInstantiable(srcType) &&
                srcType.condition &&
                srcType.condition.some((cond) => {
                    return !cond.isConstrainedTypeVar && cond.typeVarName === destTypeVar.nameWithScope;
                })
            ) {
                return true;
            }

            if (isUnion(srcType)) {
                const srcWithoutAny = removeFromUnion(srcType, (type) => isAnyOrUnknown(type));
                if (isTypeSame(destType, srcWithoutAny)) {
                    return true;
                }
            }

            // Handle the special case where both types are Self types. We'll allow
            // them to be treated as equivalent to handle certain common idioms.
            if (
                isTypeVar(srcType) &&
                srcType.details.isSynthesizedSelf &&
                srcType.details.boundType &&
                destType.details.isSynthesizedSelf &&
                destType.details.boundType
            ) {
                if ((flags & AssignTypeFlags.ReverseTypeVarMatching) === 0 && destTypeVarContext) {
                    assignTypeToTypeVar(
                        this,
                        destType,
                        srcType,
                        diag,
                        destTypeVarContext,
                        originalFlags,
                        recursionCount
                    );
                }
                return true;
            }

            // If the dest is a variadic type variable, and the source is a tuple
            // with a single entry that is the same variadic type variable, it's a match.
            if (
                isVariadicTypeVar(destType) &&
                isClassInstance(srcType) &&
                isTupleClass(srcType) &&
                srcType.tupleTypeArguments &&
                srcType.tupleTypeArguments.length === 1
            ) {
                if (isTypeSame(destType, srcType.tupleTypeArguments[0].type, {}, recursionCount)) {
                    return true;
                }
            }

            if ((flags & AssignTypeFlags.ReverseTypeVarMatching) === 0 || !isTypeVar(srcType)) {
                const targetTypeVarContext =
                    (flags & AssignTypeFlags.ReverseTypeVarMatching) === 0 ? destTypeVarContext : srcTypeVarContext;
                if (
                    !assignTypeToTypeVar(
                        this,
                        destType,
                        srcType,
                        diag,
                        targetTypeVarContext ?? new TypeVarContext(),
                        originalFlags,
                        recursionCount
                    )
                ) {
                    return false;
                }

                if (isAnyOrUnknown(srcType) && (flags & AssignTypeFlags.OverloadOverlapCheck) !== 0) {
                    return false;
                }

                return true;
            }
        }

        if (isTypeVar(srcType)) {
            if ((flags & AssignTypeFlags.ReverseTypeVarMatching) !== 0) {
                // The caller has requested that we solve for source type variables
                // rather than dest. If the type variable is not in the scope of the
                // provided TypeVarContext, simply verify that the concrete types are
                // compatible.
                if (!srcTypeVarContext || !srcTypeVarContext.hasSolveForScope(getTypeVarScopeId(srcType))) {
                    return this.assignType(
                        this.makeTopLevelTypeVarsConcrete(destType),
                        this.makeTopLevelTypeVarsConcrete(srcType),
                        diag,
                        /* destTypeVarContext */ undefined,
                        /* srcTypeVarContext */ undefined,
                        originalFlags,
                        recursionCount
                    );
                } else {
                    // Reverse the order of assignment to populate the TypeVarContext for
                    // the source TypeVar. Normally we set the AllowTypeVarNarrowing flag
                    // so the wide type bound of the TypeVar is set rather than the narrow
                    // type bound. This allows the type to be further narrowed through other
                    // assignments. However, if we're populating the expected type in the
                    // TypeVarContext, we don't want to allow further narrowing.
                    let effectiveFlags = originalFlags;
                    if ((originalFlags & AssignTypeFlags.PopulatingExpectedType) !== 0) {
                        effectiveFlags &= ~(
                            AssignTypeFlags.ReverseTypeVarMatching | AssignTypeFlags.AllowTypeVarNarrowing
                        );
                    } else {
                        effectiveFlags |= AssignTypeFlags.AllowTypeVarNarrowing;
                    }

                    if (
                        assignTypeToTypeVar(
                            this,
                            srcType as TypeVarType,
                            destType,
                            diag,
                            srcTypeVarContext,
                            effectiveFlags,
                            recursionCount
                        )
                    ) {
                        return true;
                    }

                    // If the dest type is a union, only one of the subtypes needs to match.
                    let isAssignable = false;
                    if (isUnion(destType)) {
                        doForEachSubtype(destType, (destSubtype) => {
                            if (
                                assignTypeToTypeVar(
                                    this,
                                    srcType as TypeVarType,
                                    destSubtype,
                                    diag,
                                    srcTypeVarContext,
                                    originalFlags | AssignTypeFlags.AllowTypeVarNarrowing,
                                    recursionCount
                                )
                            ) {
                                isAssignable = true;
                            }
                        });
                    }
                    return isAssignable;
                }
            }

            if ((flags & AssignTypeFlags.EnforceInvariance) !== 0) {
                if (isAnyOrUnknown(destType)) {
                    return true;
                }

                // If the source is a ParamSpec and the dest is a "...", this is
                // effectively like an "Any" signature, so we'll treat it as though
                // it's Any.
                if (
                    isParamSpec(srcType) &&
                    isFunction(destType) &&
                    FunctionType.shouldSkipArgsKwargsCompatibilityCheck(destType) &&
                    destType.details.parameters.length <= 2
                ) {
                    return true;
                }

                diag?.addMessage(
                    Localizer.DiagnosticAddendum.typeAssignmentMismatch().format({
                        sourceType: this.printType(srcType),
                        destType: this.printType(destType),
                    })
                );
                return false;
            }
        }

        if (isAnyOrUnknown(destType)) {
            return true;
        }

        if (isAnyOrUnknown(srcType)) {
            const targetTypeVarContext =
                (flags & AssignTypeFlags.ReverseTypeVarMatching) === 0 ? destTypeVarContext : srcTypeVarContext;
            if (targetTypeVarContext) {
                // If it's an ellipsis type, convert it to a regular "Any"
                // type. These are functionally equivalent, but "Any" looks
                // better in the text representation.
                const typeVarSubstitution = isEllipsisType(srcType) ? AnyType.create() : srcType;
                setTypeArgumentsRecursive(destType, typeVarSubstitution, targetTypeVarContext, recursionCount);
            }
            if ((flags & AssignTypeFlags.OverloadOverlapCheck) === 0) {
                return true;
            }
        }

        if (isNever(srcType)) {
            const targetTypeVarContext =
                (flags & AssignTypeFlags.ReverseTypeVarMatching) === 0 ? destTypeVarContext : srcTypeVarContext;
            if (targetTypeVarContext) {
                setTypeArgumentsRecursive(destType, UnknownType.create(), targetTypeVarContext, recursionCount);
            }
            return true;
        }

        // Handle the special case where the expression is an actual
        // UnionType special form.
        if (isUnion(srcType) && TypeBase.isSpecialForm(srcType)) {
            srcType = this._unionType || this._objectType || AnyType.create();
        }

        if (isUnion(destType)) {
            if (isUnion(srcType)) {
                if (
                    this.assignFromUnionType(
                        destType,
                        srcType,
                        /* diag */ undefined,
                        destTypeVarContext,
                        srcTypeVarContext,
                        originalFlags,
                        recursionCount
                    )
                ) {
                    return true;
                }
            } else {
                const clonedDestTypeVarContext = destTypeVarContext?.clone();
                const clonedSrcTypeVarContext = srcTypeVarContext?.clone();
                if (
                    this.assignToUnionType(
                        destType,
                        srcType,
                        /* diag */ undefined,
                        clonedDestTypeVarContext,
                        clonedSrcTypeVarContext,
                        originalFlags,
                        recursionCount
                    )
                ) {
                    if (destTypeVarContext && clonedDestTypeVarContext) {
                        destTypeVarContext.copyFromClone(clonedDestTypeVarContext);
                    }
                    if (srcTypeVarContext && clonedSrcTypeVarContext) {
                        srcTypeVarContext.copyFromClone(clonedSrcTypeVarContext);
                    }
                    return true;
                }
            }
        }

        const expandedSrcType = this.makeTopLevelTypeVarsConcrete(srcType);
        if (isUnion(expandedSrcType)) {
            return this.assignFromUnionType(
                destType,
                expandedSrcType,
                diag,
                destTypeVarContext,
                srcTypeVarContext,
                originalFlags,
                recursionCount
            );
        }

        if (isUnion(destType)) {
            return this.assignToUnionType(
                destType,
                srcType,
                diag,
                destTypeVarContext,
                srcTypeVarContext,
                originalFlags,
                recursionCount
            );
        }

        if (isNoneInstance(destType) && isNoneInstance(srcType)) {
            return true;
        }

        if (isNoneTypeClass(destType)) {
            if (isNoneTypeClass(srcType)) {
                return true;
            }

            if (isInstantiableClass(srcType) && ClassType.isBuiltIn(srcType, 'NoneType')) {
                return true;
            }
        }

        // Is the src a specialized "Type" object?
        if (isClassInstance(expandedSrcType) && ClassType.isBuiltIn(expandedSrcType, 'type')) {
            const srcTypeArgs = expandedSrcType.typeArguments;
            let typeTypeArg: Type | undefined;
            let instantiableType: Type | undefined;

            if (srcTypeArgs && srcTypeArgs.length >= 1) {
                typeTypeArg = srcTypeArgs[0];
                if (isAnyOrUnknown(typeTypeArg)) {
                    if (isClassInstance(destType) && ClassType.isBuiltIn(expandedSrcType, 'type')) {
                        return true;
                    }
                    return TypeBase.isInstantiable(destType);
                }
                instantiableType = convertToInstantiable(typeTypeArg);
            } else if (TypeBase.isInstantiable(destType)) {
                typeTypeArg = this._objectType ?? AnyType.create();
                instantiableType = expandedSrcType;
            }

            if (instantiableType && typeTypeArg) {
                if (isClassInstance(typeTypeArg) || isTypeVar(typeTypeArg)) {
                    if (
                        this.assignType(
                            destType,
                            instantiableType,
                            diag?.createAddendum(),
                            destTypeVarContext,
                            srcTypeVarContext,
                            flags,
                            recursionCount
                        )
                    ) {
                        return true;
                    }

                    diag?.addMessage(
                        Localizer.DiagnosticAddendum.typeAssignmentMismatch().format({
                            sourceType: this.printType(srcType),
                            destType: this.printType(destType),
                        })
                    );
                    return false;
                }
            }
        }

        if (isInstantiableClass(destType)) {
            if (isInstantiableClass(expandedSrcType)) {
                // PEP 544 says that if the dest type is a Type[Proto] class,
                // the source must be a "concrete" (non-protocol) class.
                if (ClassType.isProtocolClass(destType)) {
                    if (
                        ClassType.isProtocolClass(expandedSrcType) &&
                        isInstantiableClass(srcType) &&
                        !srcType.includeSubclasses
                    ) {
                        diag?.addMessage(
                            Localizer.DiagnosticAddendum.protocolSourceIsNotConcrete().format({
                                sourceType: this.printType(convertToInstance(srcType)),
                                destType: this.printType(destType),
                            })
                        );
                        return false;
                    }
                }

                if (
                    this.assignClass(
                        destType,
                        expandedSrcType,
                        diag,
                        destTypeVarContext,
                        srcTypeVarContext,
                        flags,
                        recursionCount,
                        /* reportErrorsUsingObjType */ false
                    )
                ) {
                    return true;
                }

                diag?.addMessage(
                    Localizer.DiagnosticAddendum.typeAssignmentMismatch().format({
                        sourceType: this.printType(srcType),
                        destType: this.printType(destType),
                    })
                );
                return false;
            }
        }

        if (isClassInstance(destType)) {
            // Is the dest a specialized "Type" object?
            if (ClassType.isBuiltIn(destType, 'Type')) {
                const destTypeArgs = destType.typeArguments;
                if (destTypeArgs && destTypeArgs.length >= 1) {
                    if (TypeBase.isInstance(destTypeArgs[0]) && TypeBase.isInstantiable(srcType)) {
                        return this.assignType(
                            destTypeArgs[0],
                            convertToInstance(srcType),
                            diag,
                            destTypeVarContext,
                            srcTypeVarContext,
                            flags,
                            recursionCount
                        );
                    }
                }
            } else if (ClassType.isBuiltIn(destType, 'type')) {
                if (isAnyOrUnknown(srcType) && (flags & AssignTypeFlags.OverloadOverlapCheck) !== 0) {
                    return false;
                }

                // Is the dest a "type" object? Assume that all instantiable
                // types are assignable to "type".
                if (TypeBase.isInstantiable(srcType)) {
                    const isLiteral = isClass(srcType) && srcType.literalValue !== undefined;
                    return !isLiteral;
                }
            } else if (ClassType.isBuiltIn(destType, ['TypeGuard', 'StrictTypeGuard'])) {
                // All the source to be a "bool".
                if ((originalFlags & AssignTypeFlags.AllowBoolTypeGuard) !== 0) {
                    if (isClassInstance(srcType) && ClassType.isBuiltIn(srcType, 'bool')) {
                        return true;
                    }
                }
            }

            let concreteSrcType = this.makeTopLevelTypeVarsConcrete(srcType);
            if (isClass(concreteSrcType) && TypeBase.isInstance(concreteSrcType)) {
                if (destType.literalValue !== undefined) {
                    const srcLiteral = concreteSrcType.literalValue;
                    if (srcLiteral === undefined || !ClassType.isLiteralValueSame(concreteSrcType, destType)) {
                        diag?.addMessage(
                            Localizer.DiagnosticAddendum.literalAssignmentMismatch().format({
                                sourceType: this.printType(srcType),
                                destType: this.printType(destType),
                            })
                        );

                        return false;
                    }
                }

                // Handle LiteralString special form.
                if (ClassType.isBuiltIn(destType, 'LiteralString')) {
                    if (ClassType.isBuiltIn(concreteSrcType, 'str') && concreteSrcType.literalValue !== undefined) {
                        return true;
                    } else if (ClassType.isBuiltIn(concreteSrcType, 'LiteralString')) {
                        return true;
                    }
                } else if (
                    ClassType.isBuiltIn(concreteSrcType, 'LiteralString') &&
                    this._strClassType &&
                    isInstantiableClass(this._strClassType)
                ) {
                    concreteSrcType = ClassType.cloneAsInstance(this._strClassType);
                }

                if (
                    !this.assignClass(
                        ClassType.cloneAsInstantiable(destType),
                        ClassType.cloneAsInstantiable(concreteSrcType),
                        diag,
                        destTypeVarContext,
                        srcTypeVarContext,
                        flags,
                        recursionCount,
                        /* reportErrorsUsingObjType */ true
                    )
                ) {
                    return false;
                }

                return true;
            } else if (isFunction(concreteSrcType) || isOverloadedFunction(concreteSrcType)) {
                // Is the destination a callback protocol (defined in PEP 544)?
                const destCallbackType = this.getCallbackProtocolType(destType, recursionCount);
                if (destCallbackType) {
                    return this.assignType(
                        destCallbackType,
                        concreteSrcType,
                        diag,
                        destTypeVarContext,
                        srcTypeVarContext,
                        flags,
                        recursionCount
                    );
                }

                // All functions are objects, so try to assign as an object.
                if (this._objectType && isClassInstance(this._objectType)) {
                    return this.assignType(
                        destType,
                        this._objectType,
                        diag,
                        destTypeVarContext,
                        srcTypeVarContext,
                        flags,
                        recursionCount
                    );
                }
            } else if (isModule(concreteSrcType)) {
                // Is the destination the built-in "ModuleType"?
                if (ClassType.isBuiltIn(destType, 'ModuleType')) {
                    return true;
                }

                if (ClassType.isProtocolClass(destType)) {
                    return assignModuleToProtocol(
                        this,
                        ClassType.cloneAsInstantiable(destType),
                        concreteSrcType,
                        diag,
                        destTypeVarContext,
                        flags,
                        recursionCount
                    );
                }
            } else if (isInstantiableClass(concreteSrcType)) {
                // See if the destType is an instantiation of a Protocol
                // class that is effectively a function.
                const callbackType = this.getCallbackProtocolType(destType, recursionCount);
                if (callbackType) {
                    return this.assignType(
                        callbackType,
                        concreteSrcType,
                        diag,
                        destTypeVarContext,
                        srcTypeVarContext,
                        flags,
                        recursionCount
                    );
                }

                // If the destType is an instantiation of a Protocol,
                // see if the class type itself satisfies the protocol.
                if (ClassType.isProtocolClass(destType)) {
                    return assignClassToProtocol(
                        this,
                        ClassType.cloneAsInstantiable(destType),
                        concreteSrcType,
                        diag,
                        destTypeVarContext,
                        srcTypeVarContext,
                        flags,
                        /* treatSourceAsInstantiable */ true,
                        recursionCount
                    );
                }

                // Determine if the metaclass can be assigned to the object.
                const metaclass = concreteSrcType.details.effectiveMetaclass;
                if (metaclass) {
                    if (isAnyOrUnknown(metaclass)) {
                        return true;
                    } else {
                        return this.assignClass(
                            ClassType.cloneAsInstantiable(destType),
                            metaclass,
                            diag,
                            destTypeVarContext,
                            srcTypeVarContext,
                            flags,
                            recursionCount,
                            /* reportErrorsUsingObjType */ false
                        );
                    }
                }
            } else if (isAnyOrUnknown(concreteSrcType)) {
                return (flags & AssignTypeFlags.OverloadOverlapCheck) === 0;
            } else if (isUnion(concreteSrcType)) {
                return this.assignType(
                    destType,
                    concreteSrcType,
                    diag,
                    destTypeVarContext,
                    srcTypeVarContext,
                    flags,
                    recursionCount
                );
            }
        }

        if (isFunction(destType)) {
            let srcFunction: FunctionType | undefined;
            let concreteSrcType = this.makeTopLevelTypeVarsConcrete(srcType);

            if (isClassInstance(concreteSrcType)) {
                const boundMethod = this.getBoundMethod(concreteSrcType, '__call__', recursionCount);
                if (boundMethod) {
                    concreteSrcType = removeParamSpecVariadicsFromSignature(boundMethod);
                }
            }

            // If it's a class, use the constructor for type compatibility checking.
            if (isInstantiableClass(concreteSrcType) && concreteSrcType.literalValue === undefined) {
                const constructor = this.createFunctionFromConstructor(concreteSrcType, recursionCount);
                if (constructor) {
                    concreteSrcType = constructor;
                }
            }

            if (isOverloadedFunction(concreteSrcType)) {
                // Overloads are not compatible with ParamSpec.
                if (destType.details.paramSpec) {
                    diag?.addMessage(Localizer.DiagnosticAddendum.paramSpecOverload());
                    return false;
                }

                // Find first overloaded function that matches the parameters.
                // We don't want to pollute the current typeVarContext, so we'll
                // make a copy of the existing one if it's specified.
                const overloads = OverloadedFunctionType.getOverloads(concreteSrcType);
                const overloadIndex = overloads.findIndex((overload) => {
                    return this.assignType(
                        destType,
                        overload,
                        diag?.createAddendum(),
                        destTypeVarContext?.clone(),
                        srcTypeVarContext?.clone(),
                        flags,
                        recursionCount
                    );
                });

                if (overloadIndex < 0) {
                    diag?.addMessage(
                        Localizer.DiagnosticAddendum.noOverloadAssignable().format({ type: this.printType(destType) })
                    );
                    return false;
                }
                srcFunction = overloads[overloadIndex];
            } else if (isFunction(concreteSrcType)) {
                srcFunction = concreteSrcType;
            } else if (isAnyOrUnknown(concreteSrcType)) {
                return (flags & AssignTypeFlags.OverloadOverlapCheck) === 0;
            }

            if (srcFunction) {
                if (
                    this.assignFunction(
                        destType,
                        srcFunction,
                        diag?.createAddendum(),
                        destTypeVarContext ?? new TypeVarContext(getTypeVarScopeId(destType)),
                        srcTypeVarContext ?? new TypeVarContext(getTypeVarScopeId(srcFunction)),
                        flags,
                        recursionCount
                    )
                ) {
                    return true;
                }
            }
        }

        if (isOverloadedFunction(destType)) {
            const overloadDiag = diag?.createAddendum();

            // All overloads in the dest must be assignable.
            const isAssignable = OverloadedFunctionType.getOverloads(destType).every((destOverload) => {
                if (destTypeVarContext) {
                    destTypeVarContext.addSolveForScope(getTypeVarScopeId(destOverload));
                }

                const result = this.assignType(
                    destOverload,
                    srcType,
                    overloadDiag?.createAddendum(),
                    destTypeVarContext ?? new TypeVarContext(getTypeVarScopeId(destOverload)),
                    srcTypeVarContext,
                    flags,
                    recursionCount
                );
                return result;
            });

            if (!isAssignable) {
                if (overloadDiag) {
                    overloadDiag.addMessage(
                        Localizer.DiagnosticAddendum.overloadNotAssignable().format({
                            name: destType.overloads[0].details.name,
                        })
                    );
                }
                return false;
            }

            return true;
        }

        if (isClassInstance(destType) && ClassType.isBuiltIn(destType, 'object')) {
            if ((flags & AssignTypeFlags.EnforceInvariance) === 0) {
                // All types (including None, Module, OverloadedFunction) derive from object.
                return true;
            }
        }

        // Are we trying to assign None to a protocol?
        if (isNoneInstance(srcType) && isClassInstance(destType) && ClassType.isProtocolClass(destType)) {
            if (this._noneType && isInstantiableClass(this._noneType)) {
                return assignClassToProtocol(
                    this,
                    ClassType.cloneAsInstantiable(destType),
                    this._noneType,
                    diag,
                    destTypeVarContext,
                    srcTypeVarContext,
                    flags,
                    /* treatSourceAsInstantiable */ false,
                    recursionCount
                );
            }
        }

        if (isNoneInstance(destType)) {
            diag?.addMessage(Localizer.DiagnosticAddendum.assignToNone());
            return false;
        }

        diag?.addMessage(
            Localizer.DiagnosticAddendum.typeAssignmentMismatch().format({
                sourceType: this.printType(srcType),
                destType: this.printType(destType),
            })
        );

        return false;
    }

    assignFromUnionType(
        destType: Type,
        srcType: UnionType,
        diag: DiagnosticAddendum | undefined,
        destTypeVarContext: TypeVarContext | undefined,
        srcTypeVarContext: TypeVarContext | undefined,
        flags: AssignTypeFlags,
        recursionCount: number
    ): boolean {
        // Start by checking for an exact match. This is needed to handle unions
        // that contain recursive type aliases.
        if (isTypeSame(srcType, destType, {}, recursionCount)) {
            return true;
        }

        // Handle the case where the source and dest are both unions. Try
        // to eliminate as many exact type matches between the src and dest.
        if (isUnion(destType)) {
            // Handle the special case where the dest is a union of Any and
            // a type variable and AssignTypeFlags.AllowTypeVarNarrowing is
            // in effect. This occurs, for example, with the return type of
            // the getattr function.
            if ((flags & AssignTypeFlags.AllowTypeVarNarrowing) !== 0) {
                const nonAnySubtypes = destType.subtypes.filter((t) => !isAnyOrUnknown(t));
                if (nonAnySubtypes.length === 1 && isTypeVar(nonAnySubtypes[0])) {
                    this.assignType(
                        nonAnySubtypes[0],
                        srcType,
                        /* diag */ undefined,
                        destTypeVarContext,
                        srcTypeVarContext,
                        flags,
                        recursionCount
                    );

                    // This always succeeds because the destination contains Any.
                    return true;
                }
            }

            const remainingDestSubtypes: Type[] = [];
            let remainingSrcSubtypes: Type[] = [...srcType.subtypes];
            let isIncompatible = false;

            // First attempt to match all of the non-generic types in the dest
            // to non-generic types in the source.
            destType.subtypes.forEach((destSubtype) => {
                if (requiresSpecialization(destSubtype)) {
                    remainingDestSubtypes.push(destSubtype);
                } else {
                    const srcTypeIndex = remainingSrcSubtypes.findIndex((srcSubtype) =>
                        isTypeSame(srcSubtype, destSubtype, {}, recursionCount)
                    );

                    if (srcTypeIndex >= 0) {
                        remainingSrcSubtypes.splice(srcTypeIndex, 1);
                    } else {
                        remainingDestSubtypes.push(destSubtype);
                    }
                }
            });

            // For all remaining source subtypes, attempt to find a dest subtype
            // whose primary type matches.
            sortTypes(remainingSrcSubtypes).forEach((srcSubtype) => {
                const destTypeIndex = remainingDestSubtypes.findIndex((destSubtype) => {
                    if (
                        isClass(srcSubtype) &&
                        isClass(destSubtype) &&
                        TypeBase.isInstance(srcSubtype) === TypeBase.isInstance(destSubtype) &&
                        ClassType.isSameGenericClass(srcSubtype, destSubtype)
                    ) {
                        return true;
                    }

                    if (isFunction(srcSubtype) || isOverloadedFunction(srcSubtype)) {
                        if (isFunction(destSubtype) || isOverloadedFunction(destSubtype)) {
                            return true;
                        }
                    }

                    return false;
                });

                if (destTypeIndex >= 0) {
                    if (
                        !this.assignType(
                            remainingDestSubtypes[destTypeIndex],
                            srcSubtype,
                            diag?.createAddendum(),
                            destTypeVarContext,
                            srcTypeVarContext,
                            flags,
                            recursionCount
                        )
                    ) {
                        isIncompatible = true;
                    }

                    remainingDestSubtypes.splice(destTypeIndex, 1);
                    remainingSrcSubtypes = remainingSrcSubtypes.filter((t) => t !== srcSubtype);
                }
            });

            // If there is are remaining dest subtypes and they're all type variables,
            // attempt to assign the remaining source subtypes to them.
            if (!isIncompatible && (remainingDestSubtypes.length !== 0 || remainingSrcSubtypes.length !== 0)) {
                const isReversed = (flags & AssignTypeFlags.ReverseTypeVarMatching) !== 0;
                const effectiveDestSubtypes = isReversed ? remainingSrcSubtypes : remainingDestSubtypes;

                if (effectiveDestSubtypes.length === 0 || effectiveDestSubtypes.some((t) => !isTypeVar(t))) {
                    isIncompatible = true;
                } else if (remainingDestSubtypes.length === remainingSrcSubtypes.length) {
                    // If the number of remaining source subtypes is the same as the number
                    // of dest TypeVars, try to assign each source subtype to its own dest TypeVar.
                    remainingDestSubtypes.forEach((destSubtype, index) => {
                        const srcSubtype = remainingSrcSubtypes[index];
                        if (
                            !this.assignType(
                                destSubtype,
                                srcSubtype,
                                diag?.createAddendum(),
                                destTypeVarContext,
                                srcTypeVarContext,
                                flags,
                                recursionCount
                            )
                        ) {
                            isIncompatible = true;
                        }
                    });
                } else {
                    // Try to assign a union of the remaining source types to
                    // the first destination TypeVar.
                    if (
                        !this.assignType(
                            isReversed ? combineTypes(remainingDestSubtypes) : remainingDestSubtypes[0],
                            isReversed ? remainingSrcSubtypes[0] : combineTypes(remainingSrcSubtypes),
                            diag?.createAddendum(),
                            destTypeVarContext,
                            srcTypeVarContext,
                            flags,
                            recursionCount
                        )
                    ) {
                        isIncompatible = true;
                    }
                }
            }

            if (!isIncompatible) {
                return true;
            }
        }

        // For union sources, all of the types need to be assignable to the dest.
        let isIncompatible = false;

        // Sort the subtypes so we have a deterministic order for unions.
        doForEachSubtype(
            srcType,
            (subtype, subtypeIndex, allSubtypes) => {
                if (isIncompatible) {
                    return;
                }

                if (
                    !this.assignType(
                        destType,
                        subtype,
                        /* diag */ undefined,
                        destTypeVarContext,
                        srcTypeVarContext,
                        flags,
                        recursionCount
                    )
                ) {
                    const concreteSubtype = this.makeTopLevelTypeVarsConcrete(subtype);

                    // Determine if the current subtype is subsumed by another subtype
                    // in the same union. If so, we can ignore this.
                    let isSubtypeSubsumed = false;
                    allSubtypes.forEach((innerSubtype, innerSubtypeIndex) => {
                        if (isSubtypeSubsumed || subtypeIndex === innerSubtypeIndex || isAnyOrUnknown(innerSubtype)) {
                            return;
                        }

                        if (this.isProperSubtype(innerSubtype, concreteSubtype, recursionCount)) {
                            isSubtypeSubsumed = true;
                        }
                    });

                    // Try again with a concrete version of the subtype.
                    if (
                        !isSubtypeSubsumed &&
                        !this.assignType(
                            destType,
                            concreteSubtype,
                            diag?.createAddendum(),
                            destTypeVarContext,
                            srcTypeVarContext,
                            flags,
                            recursionCount
                        )
                    ) {
                        isIncompatible = true;
                    }
                }
            },
            /* sortSubtypes */ true
        );

        if (isIncompatible) {
            diag?.addMessage(
                Localizer.DiagnosticAddendum.typeAssignmentMismatch().format({
                    sourceType: this.printType(srcType),
                    destType: this.printType(destType),
                })
            );
            return false;
        }

        return true;
    }

    // Determines whether the srcType is a subtype of destType but the converse
    // is not true. It's important that we check both directions to avoid
    // matches for types like `tuple[Any]` and `tuple[int]` from being considered
    // proper subtypes of each other.
    isProperSubtype(destType: Type, srcType: Type, recursionCount: number) {
        // If the destType has a condition, don't consider the srcType a proper subtype.
        if (destType.condition) {
            return false;
        }

        // Shortcut the check if either type is Any or Unknown.
        if (isAnyOrUnknown(destType) || isAnyOrUnknown(srcType)) {
            return true;
        }

        // Shortcut the check if either type is a class whose hierarchy contains an unknown type.
        if (isClass(destType) && destType.details.mro.some((mro) => isAnyOrUnknown(mro))) {
            return true;
        }

        if (isClass(srcType) && srcType.details.mro.some((mro) => isAnyOrUnknown(mro))) {
            return true;
        }

        return (
            this.assignType(
                destType,
                srcType,
                /* diag */ undefined,
                /* destTypeVarContext */ undefined,
                /* srcTypeVarContext */ undefined,
                AssignTypeFlags.Default,
                recursionCount
            ) &&
            !this.assignType(
                srcType,
                destType,
                /* diag */ undefined,
                /* destTypeVarContext */ undefined,
                /* srcTypeVarContext */ undefined,
                AssignTypeFlags.Default,
                recursionCount
            )
        );
    }

    assignToUnionType(
        destType: UnionType,
        srcType: Type,
        diag: DiagnosticAddendum | undefined,
        destTypeVarContext: TypeVarContext | undefined,
        srcTypeVarContext: TypeVarContext | undefined,
        flags: AssignTypeFlags,
        recursionCount: number
    ): boolean {
        // If we need to enforce invariance, the source needs to be compatible
        // with all subtypes in the dest, unless those subtypes are subclasses
        // of other subtypes.
        if (flags & AssignTypeFlags.EnforceInvariance) {
            let isIncompatible = false;

            doForEachSubtype(destType, (subtype, index) => {
                if (
                    !isIncompatible &&
                    !this.assignType(
                        subtype,
                        srcType,
                        diag?.createAddendum(),
                        destTypeVarContext,
                        srcTypeVarContext,
                        flags,
                        recursionCount
                    )
                ) {
                    // Determine whether this subtype is assignable to
                    // another subtype elsewhere in the union. If so, we can ignore
                    // the incompatibility.
                    let skipSubtype = false;
                    if (!isAnyOrUnknown(subtype)) {
                        doForEachSubtype(destType, (otherSubtype, otherIndex) => {
                            if (index !== otherIndex && !skipSubtype) {
                                if (
                                    this.assignType(
                                        otherSubtype,
                                        subtype,
                                        /* diag */ undefined,
                                        /* destTypeVarContext */ undefined,
                                        /* srcTypeVarContext */ undefined,
                                        AssignTypeFlags.Default,
                                        recursionCount
                                    )
                                ) {
                                    skipSubtype = true;
                                }
                            }
                        });
                    }
                    if (!skipSubtype) {
                        isIncompatible = true;
                    }
                }
            });

            if (isIncompatible) {
                diag?.addMessage(
                    Localizer.DiagnosticAddendum.typeAssignmentMismatch().format({
                        sourceType: this.printType(srcType),
                        destType: this.printType(destType),
                    })
                );
                return false;
            }

            return true;
        }

        // For union destinations, we just need to match one of the types.
        const diagAddendum = diag ? new DiagnosticAddendum() : undefined;

        let foundMatch = false;

        // Does the union contain any type variables that need to be solved?
        // If so, we need to use a slower path.
        if (!requiresSpecialization(destType)) {
            for (const subtype of destType.subtypes) {
                if (
                    this.assignType(
                        subtype,
                        srcType,
                        diagAddendum?.createAddendum(),
                        destTypeVarContext,
                        srcTypeVarContext,
                        flags,
                        recursionCount
                    )
                ) {
                    foundMatch = true;
                    break;
                }
            }
        } else {
            // Run through all subtypes in the union. Don't stop at the first
            // match we find because we may need to match TypeVars in other
            // subtypes. We special-case "None" so we can handle Optional[T]
            // without matching the None to the type var.
            if (isNoneInstance(srcType) && isOptionalType(destType)) {
                foundMatch = true;
            } else {
                let bestDestTypeVarContext: TypeVarContext | undefined;
                let bestSrcTypeVarContext: TypeVarContext | undefined;
                let bestTypeVarContextScore: number | undefined;

                // If the srcType is a literal, try to use the fast-path lookup
                // in case the destType is a union with hundreds of literals.
                if (
                    isClassInstance(srcType) &&
                    isLiteralType(srcType) &&
                    UnionType.containsType(destType, srcType, /* exclusionSet */ undefined, recursionCount)
                ) {
                    return true;
                }

                doForEachSubtype(destType, (subtype) => {
                    // Make a temporary clone of the typeVarContext. We don't want to modify
                    // the original typeVarContext until we find the "optimal" typeVar mapping.
                    const destTypeVarContextClone = destTypeVarContext?.clone();
                    const srcTypeVarContextClone = srcTypeVarContext?.clone();
                    if (
                        this.assignType(
                            subtype,
                            srcType,
                            diagAddendum?.createAddendum(),
                            destTypeVarContextClone,
                            srcTypeVarContextClone,
                            flags,
                            recursionCount
                        )
                    ) {
                        foundMatch = true;
                        if (destTypeVarContextClone) {
                            // Ask the typeVarContext to compute a "score" for the current
                            // contents of the table.
                            let typeVarContextScore = destTypeVarContextClone.getScore();

                            // If the type matches exactly, prefer it over other types.
                            if (isTypeSame(subtype, this.stripLiteralValue(srcType))) {
                                typeVarContextScore = Number.POSITIVE_INFINITY;
                            }

                            if (
                                bestTypeVarContextScore === undefined ||
                                bestTypeVarContextScore <= typeVarContextScore
                            ) {
                                // We found a typeVar mapping with a higher score than before.
                                bestTypeVarContextScore = typeVarContextScore;
                                bestDestTypeVarContext = destTypeVarContextClone;
                                bestSrcTypeVarContext = srcTypeVarContextClone;
                            }
                        }
                    }
                });

                // If we found a winning type var mapping, copy it back to typeVarContext.
                if (destTypeVarContext && bestDestTypeVarContext) {
                    destTypeVarContext.copyFromClone(bestDestTypeVarContext);
                }
                if (srcTypeVarContext && bestSrcTypeVarContext) {
                    srcTypeVarContext.copyFromClone(bestSrcTypeVarContext);
                }
            }
        }

        // If the source is a constrained TypeVar, see if we can assign all of the
        // constraints to the union.
        if (!foundMatch) {
            if (isTypeVar(srcType) && srcType.details.constraints.length > 0) {
                foundMatch = this.assignType(
                    destType,
                    this.makeTopLevelTypeVarsConcrete(srcType),
                    diagAddendum?.createAddendum(),
                    destTypeVarContext,
                    srcTypeVarContext,
                    flags,
                    recursionCount
                );
            }
        }

        if (!foundMatch) {
            if (diag && diagAddendum) {
                diag.addMessage(
                    Localizer.DiagnosticAddendum.typeAssignmentMismatch().format({
                        sourceType: this.printType(srcType),
                        destType: this.printType(destType),
                    })
                );
                diag.addAddendum(diagAddendum);
            }
            return false;
        }

        return true;
    }

    assignConditionalTypeToTypeVar(destType: TypeVarType, srcType: Type, recursionCount: number): boolean {
        // The srcType is assignable only if all of its subtypes are assignable.
        return !findSubtype(srcType, (srcSubtype) => {
            if (isTypeSame(destType, srcSubtype, { ignorePseudoGeneric: true }, recursionCount)) {
                return false;
            }

            const destTypeVarName = TypeVarType.getNameWithScope(destType);

            // Determine which conditions on this type apply to this type variable.
            // There might be more than one of them.
            const applicableConditions = (getTypeCondition(srcSubtype) ?? []).filter(
                (constraint) => constraint.typeVarName === destTypeVarName
            );

            // If there are no applicable conditions, it's not assignable.
            if (applicableConditions.length === 0) {
                return true;
            }

            return !applicableConditions.some((condition) => {
                if (condition.typeVarName === TypeVarType.getNameWithScope(destType)) {
                    if (destType.details.boundType) {
                        assert(
                            condition.constraintIndex === 0,
                            'Expected constraint for bound TypeVar to have index of 0'
                        );

                        return this.assignType(
                            destType.details.boundType,
                            srcSubtype,
                            /* diag */ undefined,
                            /* destTypeVarContext */ undefined,
                            /* srcTypeVarContext */ undefined,
                            AssignTypeFlags.Default,
                            recursionCount
                        );
                    }

                    if (destType.details.constraints.length > 0) {
                        assert(
                            condition.constraintIndex < destType.details.constraints.length,
                            'Constraint for constrained TypeVar is out of bounds'
                        );

                        return this.assignType(
                            destType.details.constraints[condition.constraintIndex],
                            srcSubtype,
                            /* diag */ undefined,
                            /* destTypeVarContext */ undefined,
                            /* srcTypeVarContext */ undefined,
                            AssignTypeFlags.Default,
                            recursionCount
                        );
                    }

                    // This is a non-bound and non-constrained type variable with a matching condition.
                    return true;
                }

                return false;
            });
        });
    }

    // Synthesize a function that represents the constructor for this class
    // taking into consideration the __init__ and __new__ methods.
    createFunctionFromConstructor(
        classType: ClassType,
        recursionCount = 0
    ): FunctionType | OverloadedFunctionType | undefined {
        // Use the __init__ method if available. It's usually more detailed.
        const initInfo = lookUpClassMember(
            classType,
            '__init__',
            ClassMemberLookupFlags.SkipInstanceVariables | ClassMemberLookupFlags.SkipObjectBaseClass
        );

        if (initInfo) {
            const initType = this.getTypeOfMember(initInfo);
            const objectType = ClassType.cloneAsInstance(classType);

            const convertInitToConstructor = (initSubtype: FunctionType) => {
                let constructorFunction = this.bindFunctionToClassOrObject(
                    objectType,
                    initSubtype,
                    /* memberClass */ undefined,
                    /* errorNode */ undefined,
                    recursionCount
                ) as FunctionType | undefined;
                if (constructorFunction) {
                    constructorFunction = FunctionType.clone(constructorFunction);
                    constructorFunction.details.declaredReturnType = objectType;
                    if (constructorFunction.specializedTypes) {
                        constructorFunction.specializedTypes.returnType = objectType;
                    }
                }
                return constructorFunction;
            };

            if (isFunction(initType)) {
                return convertInitToConstructor(initType);
            } else if (isOverloadedFunction(initType)) {
                const initOverloads: FunctionType[] = [];
                initType.overloads.forEach((overload) => {
                    const converted = convertInitToConstructor(overload);
                    if (converted) {
                        initOverloads.push(converted);
                    }
                });

                if (initOverloads.length === 0) {
                    return undefined;
                } else if (initOverloads.length === 1) {
                    return initOverloads[0];
                }

                return OverloadedFunctionType.create(initOverloads);
            }
        }

        // Fall back on the __new__ method if __init__ isn't available.
        const newInfo = lookUpClassMember(
            classType,
            '__new__',
            ClassMemberLookupFlags.SkipInstanceVariables | ClassMemberLookupFlags.SkipObjectBaseClass
        );

        if (newInfo) {
            const newType = this.getTypeOfMember(newInfo);

            const convertNewToConstructor = (newSubtype: FunctionType) => {
                return this.bindFunctionToClassOrObject(
                    classType,
                    newSubtype,
                    /* memberClass */ undefined,
                    /* errorNode */ undefined,
                    recursionCount,
                    /* treatConstructorAsClassMember */ true
                ) as FunctionType | undefined;
            };

            if (isFunction(newType)) {
                return convertNewToConstructor(newType);
            } else if (isOverloadedFunction(newType)) {
                const newOverloads: FunctionType[] = [];
                newType.overloads.forEach((overload) => {
                    const converted = convertNewToConstructor(overload);
                    if (converted) {
                        newOverloads.push(converted);
                    }
                });

                if (newOverloads.length === 0) {
                    return undefined;
                } else if (newOverloads.length === 1) {
                    return newOverloads[0];
                }

                return OverloadedFunctionType.create(newOverloads);
            }
        }

        // Return a generic constructor.
        const constructorFunction = FunctionType.createSynthesizedInstance(
            '__new__',
            FunctionTypeFlags.ConstructorMethod
        );
        constructorFunction.details.declaredReturnType = ClassType.cloneAsInstance(classType);
        FunctionType.addDefaultParameters(constructorFunction);
        return constructorFunction;
    }

    // If the class is a protocol and it has a `__call__` method but no other methods
    // or attributes that would be incompatible with a function, this method returns
    // the signature of the call implied by the `__call__` method. Otherwise it returns
    // undefined.
    getCallbackProtocolType(objType: ClassType, recursionCount = 0): FunctionType | OverloadedFunctionType | undefined {
        if (!isClassInstance(objType) || !ClassType.isProtocolClass(objType)) {
            return undefined;
        }

        // Make sure that the protocol class doesn't define any fields that
        // a normal function wouldn't be compatible with.
        for (const mroClass of objType.details.mro) {
            if (isClass(mroClass) && ClassType.isProtocolClass(mroClass)) {
                for (const field of mroClass.details.fields) {
                    if (field[0] !== '__call__' && !field[1].isIgnoredForProtocolMatch()) {
                        let fieldIsPartOfFunction = false;

                        if (this._functionObj && isClass(this._functionObj)) {
                            if (this._functionObj.details.fields.has(field[0])) {
                                fieldIsPartOfFunction = true;
                            }
                        }

                        if (!fieldIsPartOfFunction) {
                            return undefined;
                        }
                    }
                }
            }
        }

        const boundMethod = this.getBoundMethod(objType, '__call__', recursionCount);
        if (boundMethod) {
            return removeParamSpecVariadicsFromSignature(boundMethod);
        }

        return undefined;
    }

    assignFunctionParameter(
        destType: Type,
        srcType: Type,
        paramIndex: number | undefined,
        diag: DiagnosticAddendum | undefined,
        destTypeVarContext: TypeVarContext,
        srcTypeVarContext: TypeVarContext,
        flags: AssignTypeFlags,
        recursionCount: number
    ) {
        // Handle the special case where the dest type is a synthesized
        // "self" for a protocol class.
        if (
            isTypeVar(destType) &&
            destType.details.isSynthesized &&
            destType.details.boundType &&
            isClassInstance(destType.details.boundType) &&
            ClassType.isProtocolClass(destType.details.boundType)
        ) {
            return true;
        }

        if (isVariadicTypeVar(destType) && !isUnpacked(srcType)) {
            return false;
        }

        let specializedSrcType = srcType;
        let specializedDestType = destType;
        let reverseMatchingFailed = false;

        if ((flags & AssignTypeFlags.ReverseTypeVarMatching) === 0) {
            specializedDestType = applySolvedTypeVars(
                destType,
                destTypeVarContext,
                /* unknownIfNotFound */ undefined,
                /* useNarrowBoundOnly */ true
            );

            if (requiresSpecialization(specializedDestType)) {
                reverseMatchingFailed = !this.assignType(
                    specializedSrcType,
                    specializedDestType,
                    /* diag */ undefined,
                    srcTypeVarContext,
                    destTypeVarContext,
                    (flags ^ AssignTypeFlags.ReverseTypeVarMatching) |
                        AssignTypeFlags.IgnoreTypeVarScope |
                        AssignTypeFlags.RetainLiteralsForTypeVar,
                    recursionCount
                );

                specializedDestType = applySolvedTypeVars(destType, destTypeVarContext);
            }
        } else {
            specializedSrcType = applySolvedTypeVars(
                srcType,
                srcTypeVarContext,
                /* unknownIfNotFound */ undefined,
                /* useNarrowBoundOnly */ true
            );

            if (requiresSpecialization(specializedSrcType)) {
                reverseMatchingFailed = !this.assignType(
                    specializedSrcType,
                    specializedDestType,
                    /* diag */ undefined,
                    srcTypeVarContext,
                    destTypeVarContext,
                    (flags ^ AssignTypeFlags.ReverseTypeVarMatching) |
                        AssignTypeFlags.IgnoreTypeVarScope |
                        AssignTypeFlags.RetainLiteralsForTypeVar,
                    recursionCount
                );

                specializedSrcType = applySolvedTypeVars(srcType, srcTypeVarContext);
            }

            if (reverseMatchingFailed) {
                if (diag && paramIndex !== undefined) {
                    diag.addMessage(
                        Localizer.DiagnosticAddendum.paramAssignment().format({
                            index: paramIndex + 1,
                            sourceType: this.printType(destType),
                            destType: this.printType(srcType),
                        })
                    );
                }

                return false;
            }
        }

        // Handle the special case where the source is a Self type and the
        // destination is not.
        if (!isTypeVar(specializedDestType) || !specializedDestType.details.isSynthesizedSelf) {
            if (
                isTypeVar(specializedSrcType) &&
                specializedSrcType.details.isSynthesizedSelf &&
                specializedSrcType.details.boundType
            ) {
                specializedSrcType = applySolvedTypeVars(
                    specializedSrcType.details.boundType,
                    new TypeVarContext(getTypeVarScopeId(specializedSrcType)),
                    /* unknownIfNotFound */ true
                );
            }
        }

        if (
            !this.assignType(
                specializedSrcType,
                specializedDestType,
                diag?.createAddendum(),
                srcTypeVarContext,
                destTypeVarContext,
                flags,
                recursionCount
            )
        ) {
            // There are cases involving lambdas where the parameter types are type
            // variables and match exactly but fail the assignment check because the
            // TypeVars are out of scope. This happens because parameter types assigned
            // to lambdas during bidirectional inference do not match the TypeVar scope
            // of the lambda itself.
            if (!isTypeSame(destType, srcType)) {
                if (diag && paramIndex !== undefined) {
                    diag.addMessage(
                        Localizer.DiagnosticAddendum.paramAssignment().format({
                            index: paramIndex + 1,
                            sourceType: this.printType(destType),
                            destType: this.printType(srcType),
                        })
                    );
                }

                return false;
            }
        }

        return true;
    }

    // Determines whether we need to pack some of the source positionals
    // into a tuple that matches a variadic *args parameter in the destination.
    adjustSourceParamDetailsForDestVariadic(srcDetails: ParameterListDetails, destDetails: ParameterListDetails) {
        // If there is no *args parameter in the dest, we have nothing to do.
        if (destDetails.argsIndex === undefined) {
            return;
        }

        // If the source doesn't have enough positional parameters, we have nothing to do.
        if (srcDetails.params.length < destDetails.argsIndex) {
            return;
        }

        let srcLastToPackIndex = srcDetails.params.findIndex(
            (p, i) => i >= destDetails.argsIndex! && p.source === ParameterSource.KeywordOnly
        );
        if (srcLastToPackIndex < 0) {
            srcLastToPackIndex = srcDetails.params.length;
        }

        const destFirstNonPositional = destDetails.firstKeywordOnlyIndex ?? destDetails.params.length;
        const suffixLength = destFirstNonPositional - destDetails.argsIndex - 1;
        const srcPositionalsToPack = srcDetails.params.slice(destDetails.argsIndex, srcLastToPackIndex - suffixLength);
        const srcTupleTypes: TupleTypeArgument[] = [];
        srcPositionalsToPack.forEach((entry) => {
            if (entry.param.category === ParameterCategory.VarArgList) {
                if (isUnpackedVariadicTypeVar(entry.type)) {
                    srcTupleTypes.push({ type: entry.type, isUnbounded: false });
                } else if (isUnpackedClass(entry.type) && entry.type.tupleTypeArguments) {
                    appendArray(srcTupleTypes, entry.type.tupleTypeArguments);
                } else {
                    srcTupleTypes.push({ type: entry.type, isUnbounded: true });
                }
            } else {
                srcTupleTypes.push({ type: entry.type, isUnbounded: false });
            }
        });

        if (srcTupleTypes.length !== 1 || !isVariadicTypeVar(srcTupleTypes[0].type)) {
            let srcPositionalsType: Type;
            if (this._tupleClassType && isInstantiableClass(this._tupleClassType)) {
                srcPositionalsType = convertToInstance(
                    specializeTupleClass(
                        this._tupleClassType,
                        srcTupleTypes,
                        /* isTypeArgumentExplicit */ true,
                        /* isUnpackedTuple */ true
                    )
                );
            } else {
                srcPositionalsType = UnknownType.create();
            }

            // Snip out the portion of the source positionals that map to the variadic
            // dest parameter and replace it with a single parameter that is typed as a
            // tuple containing the individual types of the replaced parameters.
            srcDetails.params = [
                ...srcDetails.params.slice(0, destDetails.argsIndex),
                {
                    param: {
                        category: ParameterCategory.VarArgList,
                        name: '_arg_combined',
                        isNameSynthesized: true,
                        hasDeclaredType: true,
                        type: srcPositionalsType,
                    },
                    type: srcPositionalsType,
                    index: -1,
                    source: ParameterSource.PositionOnly,
                },
                ...srcDetails.params.slice(
                    destDetails.argsIndex + srcPositionalsToPack.length,
                    srcDetails.params.length
                ),
            ];

            const argsIndex = srcDetails.params.findIndex(
                (param) => param.param.category === ParameterCategory.VarArgList
            );
            srcDetails.argsIndex = argsIndex >= 0 ? argsIndex : undefined;

            const kwargsIndex = srcDetails.params.findIndex(
                (param) => param.param.category === ParameterCategory.VarArgDictionary
            );
            srcDetails.kwargsIndex = kwargsIndex >= 0 ? kwargsIndex : undefined;

            const firstKeywordOnlyIndex = srcDetails.params.findIndex(
                (param) => param.source === ParameterSource.KeywordOnly
            );
            srcDetails.firstKeywordOnlyIndex = firstKeywordOnlyIndex >= 0 ? firstKeywordOnlyIndex : undefined;

            srcDetails.positionOnlyParamCount = Math.max(
                0,
                srcDetails.params.findIndex(
                    (p) =>
                        p.source !== ParameterSource.PositionOnly ||
                        p.param.category !== ParameterCategory.Simple ||
                        p.param.hasDefault
                )
            );
        }
    }

    assignFunction(
        destType: FunctionType,
        srcType: FunctionType,
        diag: DiagnosticAddendum | undefined,
        destTypeVarContext: TypeVarContext,
        srcTypeVarContext: TypeVarContext,
        flags: AssignTypeFlags,
        recursionCount: number
    ): boolean {
        let canAssign = true;
        const checkReturnType = (flags & AssignTypeFlags.SkipFunctionReturnTypeCheck) === 0;
        flags &= ~AssignTypeFlags.SkipFunctionReturnTypeCheck;

        destType = removeParamSpecVariadicsFromFunction(destType);
        srcType = removeParamSpecVariadicsFromFunction(srcType);

        const destParamDetails = getParameterListDetails(destType);
        const srcParamDetails = getParameterListDetails(srcType);
        this.adjustSourceParamDetailsForDestVariadic(srcParamDetails, destParamDetails);

        const targetIncludesParamSpec =
            (flags & AssignTypeFlags.ReverseTypeVarMatching) !== 0
                ? !!srcType.details.paramSpec
                : !!destType.details.paramSpec;

        const destPositionalCount =
            destParamDetails.argsIndex ?? destParamDetails.firstKeywordOnlyIndex ?? destParamDetails.params.length;
        const srcPositionalCount =
            srcParamDetails.argsIndex ?? srcParamDetails.firstKeywordOnlyIndex ?? srcParamDetails.params.length;
        const positionalsToMatch = Math.min(destPositionalCount, srcPositionalCount);

        // Match positional parameters.
        for (let paramIndex = 0; paramIndex < positionalsToMatch; paramIndex++) {
            const destParam = destParamDetails.params[paramIndex];
            const srcParam = srcParamDetails.params[paramIndex];

            // Find the original index of this source param. If we synthesized it above (for
            // a variadic parameter), it may not be found.
            const srcParamType = srcParam.type;
            const destParamType = destParam.type;

            const destParamName = destParam.param.name ?? '';
            const srcParamName = srcParam.param.name ?? '';
            if (destParamName && !isPrivateOrProtectedName(destParamName) && !isPrivateOrProtectedName(srcParamName)) {
                const isDestPositionalOnly = destParam.source === ParameterSource.PositionOnly;
                if (
                    !isDestPositionalOnly &&
                    destParam.param.category !== ParameterCategory.VarArgList &&
                    srcParam.param.category !== ParameterCategory.VarArgList &&
                    destParamName !== srcParamName
                ) {
                    diag?.createAddendum().addMessage(
                        Localizer.DiagnosticAddendum.functionParamName().format({
                            srcName: srcParamName,
                            destName: destParamName,
                        })
                    );
                    canAssign = false;
                }
            }

            if (!!destParam.param.hasDefault && !srcParam.param.hasDefault) {
                diag?.createAddendum().addMessage(
                    Localizer.DiagnosticAddendum.functionParamDefaultMissing().format({
                        name: srcParamName,
                    })
                );
                canAssign = false;
            }

            // Handle the special case of an overloaded __init__ method whose self
            // parameter is annotated.
            if (
                paramIndex === 0 &&
                srcType.details.name === '__init__' &&
                FunctionType.isInstanceMethod(srcType) &&
                destType.details.name === '__init__' &&
                FunctionType.isInstanceMethod(destType) &&
                FunctionType.isOverloaded(destType) &&
                destParam.param.hasDeclaredType
            ) {
                continue;
            }

            if (
                !this.assignFunctionParameter(
                    destParamType,
                    srcParamType,
                    paramIndex,
                    diag?.createAddendum(),
                    destTypeVarContext,
                    srcTypeVarContext,
                    flags,
                    recursionCount
                )
            ) {
                // Handle the special case where the source parameter is a synthesized
                // TypeVar for "self" or "cls".
                if (
                    (flags & AssignTypeFlags.SkipSelfClsTypeCheck) === 0 ||
                    !isTypeVar(srcParamType) ||
                    !srcParamType.details.isSynthesized
                ) {
                    canAssign = false;
                }
            }
        }

        if (
            !FunctionType.shouldSkipArgsKwargsCompatibilityCheck(destType) &&
            destParamDetails.firstPositionOrKeywordIndex < srcParamDetails.positionOnlyParamCount &&
            !targetIncludesParamSpec
        ) {
            diag?.createAddendum().addMessage(
                Localizer.DiagnosticAddendum.argsPositionOnly().format({
                    expected: srcParamDetails.positionOnlyParamCount,
                    received: destParamDetails.firstPositionOrKeywordIndex,
                })
            );
            canAssign = false;
        }

        if (destPositionalCount < srcPositionalCount) {
            // If the dest type includes a ParamSpec, the additional parameters
            // can be assigned to it, so no need to report an error here.
            if (!targetIncludesParamSpec) {
                const nonDefaultSrcParamCount = srcParamDetails.params.filter(
                    (p) => !!p.param.name && !p.param.hasDefault && p.param.category === ParameterCategory.Simple
                ).length;

                if (destParamDetails.argsIndex === undefined) {
                    if (destPositionalCount < nonDefaultSrcParamCount) {
                        if (
                            destParamDetails.firstPositionOrKeywordIndex > 0 &&
                            destParamDetails.firstPositionOrKeywordIndex < srcPositionalCount
                        ) {
                            diag?.createAddendum().addMessage(
                                Localizer.DiagnosticAddendum.functionTooFewParams().format({
                                    expected: nonDefaultSrcParamCount,
                                    received: destPositionalCount,
                                })
                            );
                            canAssign = false;
                        }
                    }
                } else {
                    // Make sure the remaining positional arguments are of the
                    // correct type for the *args parameter.
                    const destArgsType = destParamDetails.params[destParamDetails.argsIndex].type;
                    if (!isAnyOrUnknown(destArgsType)) {
                        for (let paramIndex = destPositionalCount; paramIndex < srcPositionalCount; paramIndex++) {
                            const srcParamType = srcParamDetails.params[paramIndex].type;
                            if (
                                !this.assignFunctionParameter(
                                    destArgsType,
                                    srcParamType,
                                    paramIndex,
                                    diag?.createAddendum(),
                                    destTypeVarContext,
                                    srcTypeVarContext,
                                    flags,
                                    recursionCount
                                )
                            ) {
                                canAssign = false;
                            }
                        }
                    }
                }
            }
        } else if (srcPositionalCount < destPositionalCount) {
            if (srcParamDetails.argsIndex !== undefined) {
                // Make sure the remaining dest parameters can be assigned to the source
                // *args parameter type.
                const srcArgsType = srcParamDetails.params[srcParamDetails.argsIndex].type;
                for (let paramIndex = srcPositionalCount; paramIndex < destPositionalCount; paramIndex++) {
                    const destParamType = destParamDetails.params[paramIndex].type;
                    if (isVariadicTypeVar(destParamType) && !isVariadicTypeVar(srcArgsType)) {
                        diag?.addMessage(Localizer.DiagnosticAddendum.typeVarTupleRequiresKnownLength());
                        canAssign = false;
                    } else {
                        if (
                            !this.assignFunctionParameter(
                                destParamType,
                                srcArgsType,
                                paramIndex,
                                diag?.createAddendum(),
                                destTypeVarContext,
                                srcTypeVarContext,
                                flags,
                                recursionCount
                            )
                        ) {
                            canAssign = false;
                        }

                        if (
                            destParamDetails.params[paramIndex].source !== ParameterSource.PositionOnly &&
                            srcParamDetails.kwargsIndex === undefined
                        ) {
                            diag?.addMessage(
                                Localizer.DiagnosticAddendum.namedParamMissingInSource().format({
                                    name: destParamDetails.params[paramIndex].param.name ?? '',
                                })
                            );
                            canAssign = false;
                        }
                    }
                }
            } else {
                diag?.addMessage(
                    Localizer.DiagnosticAddendum.functionTooManyParams().format({
                        expected: srcPositionalCount,
                        received: destPositionalCount,
                    })
                );
                canAssign = false;
            }
        }

        // If both src and dest have an "*args" parameter, make sure
        // their types are compatible.
        if (
            srcParamDetails.argsIndex !== undefined &&
            destParamDetails.argsIndex !== undefined &&
            !FunctionType.shouldSkipArgsKwargsCompatibilityCheck(destType)
        ) {
            let destArgsType = destParamDetails.params[destParamDetails.argsIndex].type;
            let srcArgsType = srcParamDetails.params[srcParamDetails.argsIndex].type;

            if (this._tupleClassType && isInstantiableClass(this._tupleClassType)) {
                if (!isUnpacked(destArgsType)) {
                    destArgsType = ClassType.cloneForUnpacked(
                        ClassType.cloneAsInstance(
                            specializeTupleClass(
                                this._tupleClassType,
                                [{ type: destArgsType, isUnbounded: true }],
                                /* isTypeArgumentExplicit */ true
                            )
                        )
                    );
                }

                if (!isUnpacked(srcArgsType)) {
                    srcArgsType = ClassType.cloneForUnpacked(
                        ClassType.cloneAsInstance(
                            specializeTupleClass(
                                this._tupleClassType,
                                [{ type: srcArgsType, isUnbounded: true }],
                                /* isTypeArgumentExplicit */ true
                            )
                        )
                    );
                }
            }

            if (
                !this.assignFunctionParameter(
                    destArgsType,
                    srcArgsType,
                    destParamDetails.params[destParamDetails.argsIndex].index,
                    diag?.createAddendum(),
                    destTypeVarContext,
                    srcTypeVarContext,
                    flags,
                    recursionCount
                )
            ) {
                canAssign = false;
            }
        }

        // If the dest has an "*args" but the source doesn't, report the incompatibility.
        // The converse situation is OK.
        if (
            !FunctionType.shouldSkipArgsKwargsCompatibilityCheck(destType) &&
            srcParamDetails.argsIndex === undefined &&
            destParamDetails.argsIndex !== undefined &&
            !destParamDetails.hasUnpackedVariadicTypeVar &&
            !targetIncludesParamSpec
        ) {
            diag?.createAddendum().addMessage(
                Localizer.DiagnosticAddendum.argsParamMissing().format({
                    paramName: destParamDetails.params[destParamDetails.argsIndex].param.name ?? '',
                })
            );
            canAssign = false;
        }

        // Handle matching of named (keyword) parameters.
        if (!targetIncludesParamSpec) {
            // Build a dictionary of named parameters in the dest.
            const destParamMap = new Map<string, VirtualParameterDetails>();

            if (destParamDetails.firstKeywordOnlyIndex !== undefined) {
                destParamDetails.params.forEach((param, index) => {
                    if (index >= destParamDetails.firstKeywordOnlyIndex!) {
                        if (param.param.name && param.param.category === ParameterCategory.Simple) {
                            destParamMap.set(param.param.name, param);
                        }
                    }
                });
            }

            // If the dest has fewer positional arguments than the source, the remaining
            // positional arguments in the source can be treated as named arguments.
            let srcStartOfNamed =
                srcParamDetails.firstKeywordOnlyIndex !== undefined
                    ? srcParamDetails.firstKeywordOnlyIndex
                    : srcParamDetails.params.length;
            if (destPositionalCount < srcPositionalCount && destParamDetails.argsIndex === undefined) {
                srcStartOfNamed = destPositionalCount;
            }

            if (srcStartOfNamed >= 0) {
                srcParamDetails.params.forEach((srcParamInfo, index) => {
                    if (index >= srcStartOfNamed) {
                        if (srcParamInfo.param.name && srcParamInfo.param.category === ParameterCategory.Simple) {
                            const destParamInfo = destParamMap.get(srcParamInfo.param.name);
                            const paramDiag = diag?.createAddendum();
                            const srcParamType = srcParamInfo.type;

                            if (!destParamInfo) {
                                if (destParamDetails.kwargsIndex === undefined && !srcParamInfo.param.hasDefault) {
                                    if (paramDiag) {
                                        paramDiag.addMessage(
                                            Localizer.DiagnosticAddendum.namedParamMissingInDest().format({
                                                name: srcParamInfo.param.name,
                                            })
                                        );
                                    }
                                    canAssign = false;
                                } else if (destParamDetails.kwargsIndex !== undefined) {
                                    // Make sure we can assign the type to the Kwargs.
                                    if (
                                        !this.assignFunctionParameter(
                                            destParamDetails.params[destParamDetails.kwargsIndex].type,
                                            srcParamType,
                                            destParamDetails.params[destParamDetails.kwargsIndex].index,
                                            diag?.createAddendum(),
                                            destTypeVarContext,
                                            srcTypeVarContext,
                                            flags,
                                            recursionCount
                                        )
                                    ) {
                                        canAssign = false;
                                    }
                                }
                            } else {
                                const destParamType = destParamInfo.type;
                                const specializedDestParamType = destTypeVarContext
                                    ? applySolvedTypeVars(destParamType, destTypeVarContext)
                                    : destParamType;

                                if (
                                    !this.assignFunctionParameter(
                                        destParamInfo.type,
                                        srcParamType,
                                        /* paramIndex */ undefined,
                                        paramDiag?.createAddendum(),
                                        destTypeVarContext,
                                        srcTypeVarContext,
                                        flags,
                                        recursionCount
                                    )
                                ) {
                                    if (paramDiag) {
                                        paramDiag.addMessage(
                                            Localizer.DiagnosticAddendum.namedParamTypeMismatch().format({
                                                name: srcParamInfo.param.name,
                                                sourceType: this.printType(specializedDestParamType),
                                                destType: this.printType(srcParamType),
                                            })
                                        );
                                    }
                                    canAssign = false;
                                }

                                if (!!destParamInfo.param.hasDefault && !srcParamInfo.param.hasDefault) {
                                    diag?.createAddendum().addMessage(
                                        Localizer.DiagnosticAddendum.functionParamDefaultMissing().format({
                                            name: srcParamInfo.param.name,
                                        })
                                    );
                                    canAssign = false;
                                }

                                destParamMap.delete(srcParamInfo.param.name);
                            }
                        }
                    }
                });
            }

            // See if there are any unmatched named parameters.
            destParamMap.forEach((destParamInfo, paramName) => {
                if (srcParamDetails.kwargsIndex !== undefined && destParamInfo.param.name) {
                    // Make sure the src kwargs type is compatible.
                    if (
                        !this.assignFunctionParameter(
                            destParamInfo.param.type,
                            srcParamDetails.params[srcParamDetails.kwargsIndex].type,
                            destParamInfo.index,
                            diag?.createAddendum(),
                            destTypeVarContext,
                            srcTypeVarContext,
                            flags,
                            recursionCount
                        )
                    ) {
                        canAssign = false;
                    }
                    destParamMap.delete(paramName);
                } else {
                    diag?.createAddendum().addMessage(
                        Localizer.DiagnosticAddendum.namedParamMissingInSource().format({ name: paramName })
                    );
                    canAssign = false;
                }
            });

            // If both src and dest have a "**kwargs" parameter, make sure their types are compatible.
            if (srcParamDetails.kwargsIndex !== undefined && destParamDetails.kwargsIndex !== undefined) {
                if (
                    !this.assignFunctionParameter(
                        destParamDetails.params[destParamDetails.kwargsIndex].type,
                        srcParamDetails.params[srcParamDetails.kwargsIndex].type,
                        destParamDetails.params[destParamDetails.kwargsIndex].index,
                        diag?.createAddendum(),
                        destTypeVarContext,
                        srcTypeVarContext,
                        flags,
                        recursionCount
                    )
                ) {
                    canAssign = false;
                }
            }

            // If the dest has a "**kwargs" but the source doesn't, report the incompatibility.
            // The converse situation is OK.
            if (
                !FunctionType.shouldSkipArgsKwargsCompatibilityCheck(destType) &&
                srcParamDetails.kwargsIndex === undefined &&
                srcType.details.paramSpec === undefined &&
                destParamDetails.kwargsIndex !== undefined
            ) {
                diag?.createAddendum().addMessage(
                    Localizer.DiagnosticAddendum.kwargsParamMissing().format({
                        paramName: destParamDetails.params[destParamDetails.kwargsIndex].param.name!,
                    })
                );
                canAssign = false;
            }
        }

        // If the source and the dest are using the same ParamSpec, any additional
        // concatenated parameters must match.
        if (
            targetIncludesParamSpec &&
            srcType.details.paramSpec?.nameWithScope === destType.details.paramSpec?.nameWithScope
        ) {
            const srcParamCount = srcType.details.parameters.length;
            const destParamCount = destType.details.parameters.length;

            if (srcParamCount !== destParamCount) {
                // If the dest has an extra position-only parameter separator appended
                // to the end of the signature, it's OK.
                if (
                    srcParamCount !== destParamCount - 1 ||
                    destType.details.parameters[destParamCount - 1].category !== ParameterCategory.Simple ||
                    !!destType.details.parameters[destParamCount - 1].name
                ) {
                    canAssign = false;
                }
            }
        }

        const effectiveSrcTypeVarContext =
            (flags & AssignTypeFlags.ReverseTypeVarMatching) === 0 ? srcTypeVarContext : destTypeVarContext;

        // If the target function was generic and we solved some of the type variables
        // in that generic type, assign them back to the destination typeVar.
        effectiveSrcTypeVarContext.getTypeVars().forEach((typeVarEntry) => {
            this.assignType(
                typeVarEntry.typeVar,
                effectiveSrcTypeVarContext.getTypeVarType(typeVarEntry.typeVar)!,
                /* diag */ undefined,
                destTypeVarContext,
                srcTypeVarContext,
                AssignTypeFlags.Default,
                recursionCount
            );
        });

        // Perform partial specialization of type variables to allow for
        // "higher-order" type variables.
        if (!destTypeVarContext.isLocked()) {
            destTypeVarContext.getTypeVars().forEach((entry) => {
                if (entry.narrowBound) {
                    const specializedType = applySolvedTypeVars(entry.narrowBound, destTypeVarContext);
                    if (specializedType !== entry.narrowBound) {
                        destTypeVarContext.setTypeVarType(
                            entry.typeVar,
                            specializedType,
                            entry.wideBound,
                            entry.retainLiteral
                        );
                    }
                }
            });
        }

        // Are we assigning to a function with a ParamSpec?
        if (targetIncludesParamSpec) {
            const effectiveDestType = (flags & AssignTypeFlags.ReverseTypeVarMatching) === 0 ? destType : srcType;
            const effectiveSrcType = (flags & AssignTypeFlags.ReverseTypeVarMatching) === 0 ? srcType : destType;

            if (effectiveDestType.details.paramSpec) {
                const requiredMatchParamCount = effectiveDestType.details.parameters.filter((p) => {
                    if (!p.name) {
                        return false;
                    }

                    if (p.category === ParameterCategory.Simple && isParamSpec(p.type)) {
                        return false;
                    }
                    return true;
                }).length;
                let matchedParamCount = 0;
                const remainingParams: ParamSpecEntry[] = [];

                // If there are parameters in the source that are not matched
                // to parameters in the dest, assume these are concatenated on
                // to the ParamSpec.
                effectiveSrcType.details.parameters.forEach((p, index) => {
                    if (matchedParamCount < requiredMatchParamCount) {
                        if (p.name) {
                            matchedParamCount++;
                        }
                    } else if (!p.name && p.category === ParameterCategory.Simple && remainingParams.length === 0) {
                        // Don't bother pushing a position-only separator if it
                        // is the first remaining param.
                    } else {
                        remainingParams.push({
                            category: p.category,
                            name: p.name,
                            isNameSynthesized: p.isNameSynthesized,
                            hasDefault: !!p.hasDefault,
                            defaultValueExpression: p.defaultValueExpression,
                            type: FunctionType.getEffectiveParameterType(effectiveSrcType, index),
                        });
                    }
                });

                const srcParamSpec = effectiveSrcType.details.paramSpec;
                const destParamSpec = effectiveDestType.details.paramSpec;
                const targetTypeVarContext =
                    (flags & AssignTypeFlags.ReverseTypeVarMatching) === 0 ? destTypeVarContext : srcTypeVarContext;

                if (targetTypeVarContext.hasSolveForScope(destParamSpec.scopeId)) {
                    // Synthesize a function based on the remaining parameters.
                    const remainingFunction = FunctionType.createInstance(
                        '',
                        '',
                        '',
                        effectiveSrcType.details.flags | FunctionTypeFlags.SynthesizedMethod,
                        effectiveSrcType.details.docString
                    );
                    remainingFunction.details.typeVarScopeId = effectiveSrcType.details.typeVarScopeId;
                    remainingParams.forEach((param) => {
                        FunctionType.addParameter(remainingFunction, param);
                    });
                    remainingFunction.details.paramSpec = srcParamSpec
                        ? (convertToInstance(srcParamSpec) as TypeVarType)
                        : undefined;

                    if (
                        !assignTypeToTypeVar(
                            this,
                            destParamSpec,
                            remainingFunction,
                            /* diag */ undefined,
                            targetTypeVarContext
                        )
                    ) {
                        // If we couldn't assign the function to the ParamSpec, see if we can
                        // assign only the ParamSpec. This is possible if there were no
                        // remaining parameters.
                        if (
                            remainingParams.length > 0 ||
                            !srcParamSpec ||
                            !assignTypeToTypeVar(
                                this,
                                destParamSpec,
                                convertToInstance(srcParamSpec) as TypeVarType,
                                /* diag */ undefined,
                                targetTypeVarContext
                            )
                        ) {
                            canAssign = false;
                        }
                    }
                } else {
                    // If there are any remaining parameters or the source doesn't include the
                    // dest param spec itself, it is not assignable in this case.
                    if (
                        !srcParamSpec ||
                        !isTypeSame(srcParamSpec, destParamSpec, { ignoreTypeFlags: true }) ||
                        remainingParams.length > 0
                    ) {
                        canAssign = false;
                    }
                }
            }
        }

        // Match the return parameter.
        if (checkReturnType) {
            const destReturnType = this.getFunctionEffectiveReturnType(destType);
            if (!isAnyOrUnknown(destReturnType)) {
                const srcReturnType = applySolvedTypeVars(
                    this.getFunctionEffectiveReturnType(srcType),
                    srcTypeVarContext
                );
                const returnDiag = diag?.createAddendum();

                let isReturnTypeCompatible = false;

                let effectiveFlags = flags;

                // If the source has a declared return type that includes a literal
                // in its annotation, assume that we will want the constraint
                // solver to retain literals.
                if (
                    srcType.details.declaredReturnType &&
                    containsLiteralType(srcType.details.declaredReturnType, /* includeTypeArgs */ true)
                ) {
                    effectiveFlags |= AssignTypeFlags.RetainLiteralsForTypeVar;
                }

                if (isNever(srcReturnType)) {
                    // We'll allow any function that returns NoReturn to match any
                    // function return type, consistent with other type checkers.
                    isReturnTypeCompatible = true;
                } else if (
                    this.assignType(
                        destReturnType,
                        srcReturnType,
                        returnDiag?.createAddendum(),
                        destTypeVarContext,
                        srcTypeVarContext,
                        effectiveFlags,
                        recursionCount
                    )
                ) {
                    isReturnTypeCompatible = true;
                } else {
                    // Handle the special case where the return type is a TypeGuard[T].
                    // This should also act as a bool, since that's its type at runtime.
                    if (
                        isClassInstance(srcReturnType) &&
                        ClassType.isBuiltIn(srcReturnType, ['TypeGuard', 'StrictTypeGuard']) &&
                        this._boolClassType &&
                        isInstantiableClass(this._boolClassType)
                    ) {
                        if (
                            this.assignType(
                                destReturnType,
                                ClassType.cloneAsInstance(this._boolClassType),
                                returnDiag?.createAddendum(),
                                destTypeVarContext,
                                srcTypeVarContext,
                                flags,
                                recursionCount
                            )
                        ) {
                            isReturnTypeCompatible = true;
                        }
                    }
                }

                if (!isReturnTypeCompatible) {
                    if (returnDiag) {
                        returnDiag.addMessage(
                            Localizer.DiagnosticAddendum.functionReturnTypeMismatch().format({
                                sourceType: this.printType(srcReturnType),
                                destType: this.printType(destReturnType),
                            })
                        );
                    }
                    canAssign = false;
                }
            }
        }

        return canAssign;
    }

    // If the declaredType contains type arguments that are "Any" and
    // the corresponding type argument in the assignedType is not "Any",
    // replace that type argument in the assigned type. This function assumes
    // that the caller has already verified that the assignedType is assignable
    // to the declaredType.
    replaceTypeArgsWithAny(
        declaredType: ClassType,
        assignedType: ClassType,
        recursionCount = 0
    ): ClassType | undefined {
        if (recursionCount > maxTypeRecursionCount) {
            return undefined;
        }
        recursionCount++;

        // If this is a tuple with defined tuple type arguments, don't overwrite them.
        if (assignedType.tupleTypeArguments) {
            return undefined;
        }

        if (
            assignedType.details.typeParameters.length > 0 &&
            assignedType.typeArguments &&
            assignedType.typeArguments.length <= assignedType.details.typeParameters.length
        ) {
            const typeVarContext = new TypeVarContext(getTypeVarScopeId(assignedType));
            populateTypeVarContextBasedOnExpectedType(
                this,
                ClassType.cloneForSpecialization(
                    assignedType,
                    /* typeArguments */ undefined,
                    /* isTypeArgumentExplicit */ false
                ),
                declaredType,
                typeVarContext,
                []
            );

            let replacedTypeArg = false;
            const newTypeArgs = assignedType.typeArguments.map((typeArg, index) => {
                const typeParam = assignedType.details.typeParameters[index];
                const expectedTypeArgType = typeVarContext.getTypeVarType(typeParam);

                if (expectedTypeArgType) {
                    if (isAny(expectedTypeArgType) || isAnyOrUnknown(typeArg)) {
                        replacedTypeArg = true;
                        return expectedTypeArgType;
                    } else if (isClassInstance(expectedTypeArgType) && isClassInstance(typeArg)) {
                        // Recursively replace Any in the type argument.
                        const recursiveReplacement = this.replaceTypeArgsWithAny(
                            expectedTypeArgType,
                            typeArg,
                            recursionCount
                        );
                        if (recursiveReplacement) {
                            replacedTypeArg = true;
                            return recursiveReplacement;
                        }
                    }
                }

                return typeArg;
            });

            if (replacedTypeArg) {
                return ClassType.cloneForSpecialization(assignedType, newTypeArgs, /* isTypeArgumentExplicit */ true);
            }
        }

        return undefined;
    }

    // When a value is assigned to a variable with a declared type,
    // we may be able to narrow the type based on the assignment.
    narrowTypeBasedOnAssignment(declaredType: Type, assignedType: Type): Type {
        const diag = new DiagnosticAddendum();

        const narrowedType = mapSubtypes(assignedType, (assignedSubtype) => {
            const narrowedSubtype = mapSubtypes(declaredType, (declaredSubtype) => {
                // We can't narrow "Any".
                if (isAnyOrUnknown(declaredType)) {
                    return declaredType;
                }

                if (this.assignType(declaredSubtype, assignedSubtype, diag)) {
                    // If the source is generic and has unspecified type arguments,
                    // see if we can determine then based on the declared type.
                    if (isInstantiableClass(declaredSubtype) && isInstantiableClass(assignedSubtype)) {
                        const result = this.replaceTypeArgsWithAny(declaredSubtype, assignedSubtype);
                        if (result) {
                            assignedSubtype = result;
                        }
                    } else if (isClassInstance(declaredSubtype) && isClassInstance(assignedSubtype)) {
                        const result = this.replaceTypeArgsWithAny(
                            ClassType.cloneAsInstantiable(declaredSubtype),
                            ClassType.cloneAsInstantiable(assignedSubtype)
                        );
                        if (result) {
                            assignedSubtype = ClassType.cloneAsInstance(result);
                        }
                    } else if (!isTypeVar(declaredSubtype) && isTypeVar(assignedSubtype)) {
                        // If the source is an unsolved TypeVar but the declared type is concrete,
                        // use the concrete type.
                        return declaredSubtype;
                    }

                    return assignedSubtype;
                }

                return undefined;
            });

            // If we couldn't assign the assigned subtype any of the declared
            // subtypes, the types are incompatible. Return the unnarrowed form.
            if (isNever(narrowedSubtype)) {
                return assignedSubtype;
            }

            return narrowedSubtype;
        });

        // If the result of narrowing is Any, stick with the declared (unnarrowed) type.
        // If the result of narrowing is an Unknown that is complete, stick with Unknown.
        // If it's incomplete, propagate the incomplete type for the benefit of
        // code flow analysis.
        if (isAnyOrUnknown(assignedType) && !isIncompleteUnknown(assignedType)) {
            return declaredType;
        }

        return narrowedType;
    }

    validateOverrideMethod(
        baseMethod: Type,
        overrideMethod: FunctionType | OverloadedFunctionType,
        diag: DiagnosticAddendum,
        enforceParamNames = true
    ): boolean {
        // If we're overriding a non-method with a method, report it as an error.
        // This occurs when a non-property overrides a property.
        if (!isFunction(baseMethod) && !isOverloadedFunction(baseMethod)) {
            diag.addMessage(Localizer.DiagnosticAddendum.overrideType().format({ type: this.printType(baseMethod) }));
            return false;
        }

        if (isFunction(baseMethod)) {
            // Handle the easy case - a simple function overriding another simple function.
            if (isFunction(overrideMethod)) {
                return this.validateOverrideMethodInternal(baseMethod, overrideMethod, diag, enforceParamNames);
            }

            // For an overload overriding a base method, at least one overload
            // must be compatible with the base method.
            if (
                OverloadedFunctionType.getOverloads(overrideMethod).some((overrideOverload) => {
                    return this.validateOverrideMethodInternal(
                        baseMethod,
                        overrideOverload,
                        /* diag */ undefined,
                        enforceParamNames
                    );
                })
            ) {
                return true;
            }

            // Or the implementation must be compatible.
            const overrideImplementation = OverloadedFunctionType.getImplementation(overrideMethod);
            if (overrideImplementation) {
                if (
                    this.validateOverrideMethodInternal(
                        baseMethod,
                        overrideImplementation,
                        /* diag */ undefined,
                        enforceParamNames
                    )
                ) {
                    return true;
                }
            }

            diag.addMessage(Localizer.DiagnosticAddendum.overrideNoOverloadMatches());
            return false;
        }

        // TODO - need to implement the case where the base method is overloaded
        return true;
    }

    validateOverrideMethodInternal(
        baseMethod: FunctionType,
        overrideMethod: FunctionType,
        diag: DiagnosticAddendum | undefined,
        enforceParamNames: boolean
    ): boolean {
        const baseParamDetails = getParameterListDetails(baseMethod);
        const overrideParamDetails = getParameterListDetails(overrideMethod);

        let canOverride = true;

        // Verify that we're not overriding a static, class or instance method with
        // an incompatible type.
        if (FunctionType.isStaticMethod(baseMethod)) {
            if (!FunctionType.isStaticMethod(overrideMethod)) {
                diag?.addMessage(Localizer.DiagnosticAddendum.overrideNotStaticMethod());
                canOverride = false;
            }
        } else if (FunctionType.isClassMethod(baseMethod)) {
            if (!FunctionType.isClassMethod(overrideMethod)) {
                diag?.addMessage(Localizer.DiagnosticAddendum.overrideNotClassMethod());
                canOverride = false;
            }
        }
        if (FunctionType.isInstanceMethod(baseMethod)) {
            if (!FunctionType.isInstanceMethod(overrideMethod)) {
                diag?.addMessage(Localizer.DiagnosticAddendum.overrideNotInstanceMethod());
                canOverride = false;
            }
        }

        // Verify that the positional param count matches exactly or that the override
        // adds only params that preserve the original signature.
        let foundParamCountMismatch = false;
        if (
            overrideParamDetails.positionParamCount < baseParamDetails.positionParamCount &&
            overrideParamDetails.argsIndex === undefined
        ) {
            foundParamCountMismatch = true;
        } else if (overrideParamDetails.positionParamCount > baseParamDetails.positionParamCount) {
            // Verify that all of the override parameters that extend the
            // signature are either *args, **kwargs or parameters with
            // default values.

            for (let i = baseParamDetails.positionParamCount; i < overrideParamDetails.positionParamCount; i++) {
                const overrideParam = overrideParamDetails.params[i].param;

                if (
                    overrideParam.category === ParameterCategory.Simple &&
                    overrideParam.name &&
                    !overrideParam.hasDefault
                ) {
                    foundParamCountMismatch = true;
                }
            }
        }

        if (foundParamCountMismatch) {
            diag?.addMessage(
                Localizer.DiagnosticAddendum.overridePositionalParamCount().format({
                    baseCount: baseParamDetails.params.length,
                    overrideCount: overrideParamDetails.params.length,
                })
            );
            canOverride = false;
        }

        const positionalParamCount = Math.min(
            baseParamDetails.positionParamCount,
            overrideParamDetails.positionParamCount
        );

        for (let i = 0; i < positionalParamCount; i++) {
            // If the first parameter is a "self" or "cls" parameter, skip the
            // test because these are allowed to violate the Liskov substitution
            // principle.
            if (i === 0) {
                if (
                    FunctionType.isInstanceMethod(overrideMethod) ||
                    FunctionType.isClassMethod(overrideMethod) ||
                    FunctionType.isConstructorMethod(overrideMethod)
                ) {
                    continue;
                }
            }

            const baseParam = baseParamDetails.params[i].param;
            const overrideParam = overrideParamDetails.params[i].param;

            if (
                i >= baseParamDetails.positionOnlyParamCount &&
                !isPrivateOrProtectedName(baseParam.name || '') &&
                baseParamDetails.params[i].source !== ParameterSource.PositionOnly &&
                baseParam.category === ParameterCategory.Simple &&
                baseParam.name !== overrideParam.name
            ) {
                if (overrideParam.category === ParameterCategory.Simple) {
                    if (enforceParamNames) {
                        if (overrideParamDetails.params[i].source === ParameterSource.PositionOnly) {
                            diag?.addMessage(
                                Localizer.DiagnosticAddendum.overrideParamNamePositionOnly().format({
                                    index: i + 1,
                                    baseName: baseParam.name || '*',
                                })
                            );
                        } else {
                            diag?.addMessage(
                                Localizer.DiagnosticAddendum.overrideParamName().format({
                                    index: i + 1,
                                    baseName: baseParam.name || '*',
                                    overrideName: overrideParam.name || '*',
                                })
                            );
                        }
                        canOverride = false;
                    }
                }
            } else if (
                i < overrideParamDetails.positionOnlyParamCount &&
                i >= baseParamDetails.positionOnlyParamCount
            ) {
                diag?.addMessage(
                    Localizer.DiagnosticAddendum.overrideParamNamePositionOnly().format({
                        index: i + 1,
                        baseName: baseParam.name || '*',
                    })
                );
                canOverride = false;
            } else {
                const baseParamType = baseParamDetails.params[i].type;
                const overrideParamType = overrideParamDetails.params[i].type;

                const baseIsSynthesizedTypeVar = isTypeVar(baseParamType) && baseParamType.details.isSynthesized;
                const overrideIsSynthesizedTypeVar =
                    isTypeVar(overrideParamType) && overrideParamType.details.isSynthesized;
                if (!baseIsSynthesizedTypeVar && !overrideIsSynthesizedTypeVar) {
                    if (
                        baseParam.category !== overrideParam.category ||
                        !this.assignType(
                            overrideParamType,
                            baseParamType,
                            diag?.createAddendum(),
                            new TypeVarContext(getTypeVarScopeId(overrideMethod)),
                            new TypeVarContext(getTypeVarScopeId(baseMethod)),
                            AssignTypeFlags.SkipSolveTypeVars
                        )
                    ) {
                        diag?.addMessage(
                            Localizer.DiagnosticAddendum.overrideParamType().format({
                                index: i + 1,
                                baseType: this.printType(baseParamType),
                                overrideType: this.printType(overrideParamType),
                            })
                        );
                        canOverride = false;
                    }
                }

                if (baseParamDetails.params[i].param.hasDefault && !overrideParamDetails.params[i].param.hasDefault) {
                    diag?.addMessage(
                        Localizer.DiagnosticAddendum.overrideParamNoDefault().format({
                            index: i + 1,
                        })
                    );
                    canOverride = false;
                }
            }
        }

        // Check for a *args match.
        if (baseParamDetails.argsIndex !== undefined) {
            if (overrideParamDetails.argsIndex === undefined) {
                diag?.addMessage(
                    Localizer.DiagnosticAddendum.overrideParamNameMissing().format({
                        name: baseParamDetails.params[baseParamDetails.argsIndex].param.name ?? '?',
                    })
                );
                canOverride = false;
            } else {
                const overrideParamType = overrideParamDetails.params[overrideParamDetails.argsIndex].type;
                const baseParamType = baseParamDetails.params[baseParamDetails.argsIndex].type;

                if (
                    !this.assignType(
                        overrideParamType,
                        baseParamType,
                        diag?.createAddendum(),
                        new TypeVarContext(getTypeVarScopeId(overrideMethod)),
                        /* srcTypeVarContext */ undefined,
                        AssignTypeFlags.SkipSolveTypeVars
                    )
                ) {
                    diag?.addMessage(
                        Localizer.DiagnosticAddendum.overrideParamKeywordType().format({
                            name: overrideParamDetails.params[overrideParamDetails.argsIndex].param.name ?? '?',
                            baseType: this.printType(baseParamType),
                            overrideType: this.printType(overrideParamType),
                        })
                    );
                    canOverride = false;
                }
            }
        }

        // Now check any keyword-only parameters.
        const baseKwOnlyParams = baseParamDetails.params.filter(
            (paramInfo) =>
                paramInfo.source === ParameterSource.KeywordOnly &&
                paramInfo.param.category === ParameterCategory.Simple
        );
        const overrideWkOnlyParams = overrideParamDetails.params.filter(
            (paramInfo) =>
                paramInfo.source === ParameterSource.KeywordOnly &&
                paramInfo.param.category === ParameterCategory.Simple
        );

        baseKwOnlyParams.forEach((paramInfo) => {
            const overrideParamInfo = overrideWkOnlyParams.find((pi) => paramInfo.param.name === pi.param.name);

            if (!overrideParamInfo && overrideParamDetails.kwargsIndex === undefined) {
                diag?.addMessage(
                    Localizer.DiagnosticAddendum.overrideParamNameMissing().format({
                        name: paramInfo.param.name ?? '?',
                    })
                );
                canOverride = false;
            } else {
                let targetParamType = overrideParamInfo?.type;
                if (!targetParamType) {
                    targetParamType = overrideParamDetails.params[overrideParamDetails.kwargsIndex!].type;
                }

                if (
                    !this.assignType(
                        targetParamType,
                        paramInfo.type,
                        diag?.createAddendum(),
                        new TypeVarContext(getTypeVarScopeId(overrideMethod)),
                        /* srcTypeVarContext */ undefined,
                        AssignTypeFlags.SkipSolveTypeVars
                    )
                ) {
                    diag?.addMessage(
                        Localizer.DiagnosticAddendum.overrideParamKeywordType().format({
                            name: paramInfo.param.name ?? '?',
                            baseType: this.printType(paramInfo.type),
                            overrideType: this.printType(targetParamType),
                        })
                    );
                    canOverride = false;
                }

                if (overrideParamInfo) {
                    if (paramInfo.param.hasDefault && !overrideParamInfo.param.hasDefault) {
                        diag?.addMessage(
                            Localizer.DiagnosticAddendum.overrideParamKeywordNoDefault().format({
                                name: overrideParamInfo.param.name ?? '?',
                            })
                        );
                        canOverride = false;
                    }
                }
            }
        });

        // Verify that any keyword-only parameters added by the overload are compatible
        // with the **kwargs in the base.
        overrideWkOnlyParams.forEach((paramInfo) => {
            const baseParamInfo = baseKwOnlyParams.find((pi) => paramInfo.param.name === pi.param.name);

            if (!baseParamInfo) {
                if (baseParamDetails.kwargsIndex === undefined) {
                    if (!paramInfo.param.hasDefault) {
                        diag?.addMessage(
                            Localizer.DiagnosticAddendum.overrideParamNameExtra().format({
                                name: paramInfo.param.name ?? '?',
                            })
                        );
                        canOverride = false;
                    }
                }
            }
        });

        // Now check the return type.
        const baseReturnType = this.getFunctionEffectiveReturnType(baseMethod);
        const overrideReturnType = this.getFunctionEffectiveReturnType(overrideMethod);
        if (
            !this.assignType(
                baseReturnType,
                overrideReturnType,
                diag?.createAddendum(),
                new TypeVarContext(getTypeVarScopeId(baseMethod)),
                /* srcTypeVarContext */ undefined,
                AssignTypeFlags.SkipSolveTypeVars
            )
        ) {
            diag?.addMessage(
                Localizer.DiagnosticAddendum.overrideReturnType().format({
                    baseType: this.printType(baseReturnType),
                    overrideType: this.printType(overrideReturnType),
                })
            );

            canOverride = false;
        }

        return canOverride;
    }

    // Validates that the specified source type matches the constraints
    // of the type variable. If successful, it returns the constraint
    // type that applies. If unsuccessful, it returns undefined.
    applyTypeArgToTypeVar(destType: TypeVarType, srcType: Type, diag: DiagnosticAddendum): Type | undefined {
        if (isAnyOrUnknown(srcType)) {
            return srcType;
        }

        let effectiveSrcType: Type = transformPossibleRecursiveTypeAlias(srcType);

        if (isTypeVar(srcType)) {
            if (isTypeSame(srcType, destType)) {
                return srcType;
            }

            effectiveSrcType = this.makeTopLevelTypeVarsConcrete(srcType);
        }

        // If this is a partially-evaluated class, don't perform any further
        // checks. Assume in this case that the type is compatible with the
        // bound or constraint.
        if (isClass(effectiveSrcType) && ClassType.isPartiallyEvaluated(effectiveSrcType)) {
            return srcType;
        }

        // If there's a bound type, make sure the source is derived from it.
        if (destType.details.boundType && !isTypeAliasPlaceholder(effectiveSrcType)) {
            if (
                !this.assignType(
                    destType.details.boundType,
                    effectiveSrcType,
                    diag.createAddendum(),
                    /* destTypeVarContext */ undefined,
                    /* srcTypeVarContext */ undefined
                )
            ) {
                // Avoid adding a message that will confuse users if the TypeVar was
                // synthesized for internal purposes.
                if (!destType.details.isSynthesized) {
                    diag.addMessage(
                        Localizer.DiagnosticAddendum.typeBound().format({
                            sourceType: this.printType(effectiveSrcType),
                            destType: this.printType(destType.details.boundType),
                            name: TypeVarType.getReadableName(destType),
                        })
                    );
                }
                return undefined;
            }
        }

        if (destType.details.isParamSpec) {
            if (isParamSpec(srcType)) {
                return srcType;
            }

            if (isFunction(srcType) && FunctionType.isParamSpecValue(srcType)) {
                return srcType;
            }

            if (isClassInstance(srcType) && ClassType.isBuiltIn(srcType, 'Concatenate')) {
                return srcType;
            }

            diag.addMessage(
                Localizer.DiagnosticAddendum.typeParamSpec().format({
                    type: this.printType(srcType),
                    name: TypeVarType.getReadableName(destType),
                })
            );

            return undefined;
        }

        if (isTypeVar(srcType) && srcType.details.isParamSpec) {
            diag.addMessage(Localizer.Diagnostic.paramSpecContext());
            return undefined;
        }

        // If there are no constraints, we're done.
        const constraints = destType.details.constraints;
        if (constraints.length === 0) {
            return srcType;
        }

        if (isTypeAliasPlaceholder(srcType)) {
            return srcType;
        }

        if (isTypeVar(srcType) && srcType.details.constraints.length > 0) {
            // Make sure all the source constraint types map to constraint types in the dest.
            if (
                srcType.details.constraints.every((sourceConstraint) => {
                    return constraints.some((destConstraint) => this.assignType(destConstraint, sourceConstraint));
                })
            ) {
                return srcType;
            }
        } else {
            let bestConstraintSoFar: Type | undefined;

            // Try to find the best (narrowest) match among the constraints.
            for (const constraint of constraints) {
                if (this.assignType(constraint, effectiveSrcType)) {
                    if (!bestConstraintSoFar || this.assignType(bestConstraintSoFar, constraint)) {
                        bestConstraintSoFar = constraint;
                    }
                }
            }

            if (bestConstraintSoFar) {
                return bestConstraintSoFar;
            }
        }

        diag.addMessage(
            Localizer.DiagnosticAddendum.typeConstrainedTypeVar().format({
                type: this.printType(srcType),
                name: TypeVarType.getReadableName(destType),
            })
        );

        return undefined;
    }

    getAbstractMethods(classType: ClassType): AbstractMethod[] {
        const symbolTable = new Map<string, AbstractMethod>();

        ClassType.getReverseMro(classType).forEach((mroClass) => {
            if (isInstantiableClass(mroClass)) {
                // See if this class is introducing a new abstract method that has not been
                // introduced previously or if it is overriding an abstract method with
                // a non-abstract one.
                mroClass.details.fields.forEach((symbol, symbolName) => {
                    // We do a quick-and-dirty evaluation of methods based on
                    // decorators to determine which ones are abstract. This allows
                    // us to avoid evaluating the full function types.
                    // Handle named tuple fields as though they are class members here.
                    // We model them as instance variables, but they're actually implemented
                    // using class variable descriptors, and these overwrite a class variable
                    // abstract method.
                    if (symbol.isClassMember() || symbol.isNamedTupleMemberMember()) {
                        let isAbstract: boolean;

                        const decl = getLastTypedDeclaredForSymbol(symbol);
                        if (decl && decl.type === DeclarationType.Function) {
                            const functionFlags = this.getFunctionFlagsFromDecorators(decl.node, true);
                            isAbstract = !!(functionFlags & FunctionTypeFlags.AbstractMethod);
                        } else {
                            // If a symbol is overridden by a non-function, it is no longer
                            // considered abstract. This can happen in some code, for example,
                            // when a base class declares an abstract property and a subclass
                            // "overrides" it with an instance variable.
                            isAbstract = false;
                        }

                        if (isAbstract) {
                            symbolTable.set(symbolName, {
                                symbol,
                                symbolName,
                                classType: mroClass,
                            });
                        } else {
                            symbolTable.delete(symbolName);
                        }
                    }
                });
            }
        });

        // Create a final list of methods that are abstract.
        const methodList: AbstractMethod[] = [];
        symbolTable.forEach((method) => {
            methodList.push(method);
        });

        return methodList;
    }

    // If the memberType is an instance or class method, creates a new
    // version of the function that has the "self" or "cls" parameter bound
    // to it. If treatAsClassMethod is true, the function is treated like a
    // class method even if it's not marked as such. That's needed to
    // special-case the __new__ magic method when it's invoked as a
    // constructor (as opposed to by name).
    bindFunctionToClassOrObject(
        baseType: ClassType | undefined,
        memberType: FunctionType | OverloadedFunctionType,
        memberClass?: ClassType,
        errorNode?: ParseNode,
        recursionCount = 0,
        treatConstructorAsClassMember = false,
        firstParamType?: ClassType | TypeVarType
    ): FunctionType | OverloadedFunctionType | undefined {
        if (isFunction(memberType)) {
            // If the caller specified no base type, always strip the
            // first parameter. This is used in cases like constructors.
            if (!baseType) {
                return FunctionType.clone(memberType, /* stripFirstParam */ true);
            }

            if (FunctionType.isInstanceMethod(memberType)) {
                const baseObj = isClassInstance(baseType)
                    ? baseType
                    : ClassType.cloneAsInstance(specializeClassType(baseType));
                return this.partiallySpecializeFunctionForBoundClassOrObject(
                    baseType,
                    memberType,
                    memberClass || ClassType.cloneAsInstantiable(baseObj),
                    errorNode,
                    recursionCount,
                    firstParamType || baseObj,
                    /* stripFirstParam */ isClassInstance(baseType)
                );
            }

            if (
                FunctionType.isClassMethod(memberType) ||
                (treatConstructorAsClassMember && FunctionType.isConstructorMethod(memberType))
            ) {
                const baseClass = isInstantiableClass(baseType) ? baseType : ClassType.cloneAsInstantiable(baseType);

                // If the caller passed an object as the base type, we need to also
                // convert the firstParamType to an instantiable.
                const effectiveFirstParamType = firstParamType
                    ? isInstantiableClass(baseType)
                        ? firstParamType
                        : (convertToInstantiable(firstParamType) as ClassType | TypeVarType)
                    : baseClass;

                return this.partiallySpecializeFunctionForBoundClassOrObject(
                    TypeBase.isInstance(baseType) ? ClassType.cloneAsInstantiable(baseType) : baseType,
                    memberType,
                    memberClass || baseClass,
                    errorNode,
                    recursionCount,
                    effectiveFirstParamType,
                    /* stripFirstParam */ true
                );
            }

            if (FunctionType.isStaticMethod(memberType)) {
                const baseClass = isInstantiableClass(baseType) ? baseType : ClassType.cloneAsInstantiable(baseType);

                return this.partiallySpecializeFunctionForBoundClassOrObject(
                    TypeBase.isInstance(baseType) ? ClassType.cloneAsInstantiable(baseType) : baseType,
                    memberType,
                    memberClass || baseClass,
                    errorNode,
                    recursionCount,
                    /* effectiveFirstParamType */ undefined,
                    /* stripFirstParam */ false
                );
            }
        } else if (isOverloadedFunction(memberType)) {
            const newOverloadType = OverloadedFunctionType.create([]);
            memberType.overloads.forEach((overload) => {
                const boundMethod = this.bindFunctionToClassOrObject(
                    baseType,
                    overload,
                    memberClass,
                    /* errorNode */ undefined,
                    recursionCount,
                    treatConstructorAsClassMember,
                    firstParamType
                );
                if (boundMethod) {
                    OverloadedFunctionType.addOverload(newOverloadType, boundMethod as FunctionType);
                }
            });

            if (newOverloadType.overloads.length === 1) {
                return newOverloadType.overloads[0];
            } else if (newOverloadType.overloads.length === 0) {
                // No overloads matched, so rebind with the errorNode
                // to report the error(s) to the user.
                if (errorNode) {
                    memberType.overloads.forEach((overload) => {
                        this.bindFunctionToClassOrObject(
                            baseType,
                            overload,
                            memberClass,
                            errorNode,
                            recursionCount,
                            treatConstructorAsClassMember,
                            firstParamType
                        );
                    });
                }
                return undefined;
            }

            return newOverloadType;
        }

        return memberType;
    }

    // Specializes the specified function for the specified class,
    // optionally stripping the first first parameter (the "self" or "cls")
    // off of the specialized function in the process. The baseType
    // is the type used to reference the member, and the memberClass
    // is the class that provided the member (could be an ancestor of
    // the baseType's class).
    partiallySpecializeFunctionForBoundClassOrObject(
        baseType: ClassType,
        memberType: FunctionType,
        memberClass: ClassType,
        errorNode: ParseNode | undefined,
        recursionCount: number,
        firstParamType: ClassType | TypeVarType | undefined,
        stripFirstParam = true
    ): FunctionType | undefined {
        const typeVarContext = new TypeVarContext(getTypeVarScopeId(memberClass));

        if (firstParamType && memberType.details.parameters.length > 0) {
            const memberTypeFirstParam = memberType.details.parameters[0];
            const memberTypeFirstParamType = FunctionType.getEffectiveParameterType(memberType, 0);

            // Fill out the typeVarContext for the "self" or "cls" parameter.
            typeVarContext.addSolveForScope(getTypeVarScopeId(memberType));
            const diag = new DiagnosticAddendum();

            if (
                isTypeVar(memberTypeFirstParamType) &&
                memberTypeFirstParamType.details.boundType &&
                isClassInstance(memberTypeFirstParamType.details.boundType) &&
                ClassType.isProtocolClass(memberTypeFirstParamType.details.boundType)
            ) {
                // Handle the protocol class specially. Some protocol classes
                // contain references to themselves or their subclasses, so if
                // we attempt to call assignType, we'll risk infinite recursion.
                // Instead, we'll assume it's assignable.
                if (!typeVarContext.isLocked()) {
                    typeVarContext.setTypeVarType(
                        memberTypeFirstParamType,
                        TypeBase.isInstantiable(memberTypeFirstParamType)
                            ? convertToInstance(firstParamType)
                            : firstParamType
                    );
                }
            } else if (
                !this.assignType(
                    memberTypeFirstParamType,
                    firstParamType,
                    diag,
                    typeVarContext,
                    /* srcTypeVarContext */ undefined,
                    AssignTypeFlags.Default,
                    recursionCount
                )
            ) {
                if (
                    memberTypeFirstParam.name &&
                    !memberTypeFirstParam.isNameSynthesized &&
                    memberTypeFirstParam.hasDeclaredType
                ) {
                    if (errorNode) {
                        const methodName = memberType.details.name || '(unnamed)';
                        this.addDiagnostic(
                            AnalyzerNodeInfo.getFileInfo(errorNode).diagnosticRuleSet.reportGeneralTypeIssues,
                            DiagnosticRule.reportGeneralTypeIssues,
                            Localizer.Diagnostic.bindTypeMismatch().format({
                                type: this.printType(baseType),
                                methodName: methodName,
                                paramName: memberTypeFirstParam.name,
                            }) + diag.getString(),
                            errorNode
                        );
                    } else {
                        // If there was no errorNode, we couldn't report the error,
                        // so we will instead return undefined and let the caller
                        // deal with the error.
                        return undefined;
                    }
                }
            }
        }

        // Get the effective return type, which will have the side effect of lazily
        // evaluating (and caching) the inferred return type if there is no defined return type.
        this.getFunctionEffectiveReturnType(memberType);

        const specializedFunction = applySolvedTypeVars(memberType, typeVarContext) as FunctionType;

        return FunctionType.clone(specializedFunction, stripFirstParam, baseType, getTypeVarScopeId(baseType));
    }

    printObjectTypeForClass(type: ClassType): string {
        return TypePrinter.printObjectTypeForClass(
            type,
            this._evaluatorOptions.printTypeFlags,
            this.getFunctionEffectiveReturnType.bind(this)
        );
    }

    printFunctionParts(type: FunctionType): [string[], string] {
        return TypePrinter.printFunctionParts(
            type,
            this._evaluatorOptions.printTypeFlags,
            this.getFunctionEffectiveReturnType.bind(this)
        );
    }

    printType(type: Type, options?: PrintTypeOptions): string {
        let flags = this._evaluatorOptions.printTypeFlags;

        if (options?.expandTypeAlias) {
            flags |= TypePrinter.PrintTypeFlags.ExpandTypeAlias;
        }
        if (options?.enforcePythonSyntax) {
            flags |= TypePrinter.PrintTypeFlags.PythonSyntax;
        }
        if (options?.useTypingUnpack) {
            flags |= TypePrinter.PrintTypeFlags.UseTypingUnpack;
        }

        return TypePrinter.printType(type, flags, this.getFunctionEffectiveReturnType.bind(this));
    }

    // Calls back into the parser to parse the contents of a string literal.
    // This is unfortunately needed in some cases — specifically where the
    // parser couldn't determine that the string literal would be used in
    // a context where it should be treated as a forward-declared type. This
    // call produces an expression tree that is not attached to the main parse
    // expression tree because we don't want to mutate the latter; the
    // expression tree created by this function is therefore used only temporarily.
    parseStringAsTypeAnnotation(node: StringListNode): ExpressionNode | undefined {
        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
        const parser = new Parser();
        const textValue = node.strings[0].value;

        // Determine the offset within the file where the string
        // literal's contents begin.
        const valueOffset =
            node.strings[0].start + node.strings[0].token.prefixLength + node.strings[0].token.quoteMarkLength;

        const parseOptions = new ParseOptions();
        parseOptions.isStubFile = fileInfo.isStubFile;
        parseOptions.pythonVersion = fileInfo.executionEnvironment.pythonVersion;
        parseOptions.reportErrorsForParsedStringContents = true;

        const parseResults = parser.parseTextExpression(
            fileInfo.fileContents,
            valueOffset,
            textValue.length,
            parseOptions,
            /* parseTextMode */ undefined,
            /* initialParenDepth */ undefined,
            fileInfo.typingSymbolAliases
        );

        if (parseResults.parseTree && parseResults.parseTree.nodeType !== ParseNodeType.FunctionAnnotation) {
            parseResults.diagnostics.forEach((diag) => {
                this.addError(diag.message, node);
            });

            parseResults.parseTree.parent = node;
            return parseResults.parseTree;
        }

        return undefined;
    }

    // Given a code flow node and a constrained TypeVar, determines whether that type
    // var can be "narrowed" to a single one of its constraints based on isinstance
    // checks within the code flow.
    narrowConstrainedTypeVar(node: ParseNode, typeVar: TypeVarType): Type | undefined {
        const flowNode = AnalyzerNodeInfo.getFlowNode(node);

        if (!flowNode) {
            return undefined;
        }

        return this._codeFlowEngine.narrowConstrainedTypeVar(flowNode, typeVar);
    }

    getPrintExpressionTypesSpaces() {
        return ' '.repeat(this._printExpressionSpaceCount);
    }

    getLineNum(node: ParseNode) {
        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
        const range = convertOffsetsToRange(node.start, node.start + node.length, fileInfo.lines);
        return (range.start.line + 1).toString();
    }

    printControlFlowGraph(
        flowNode: FlowNode,
        reference: CodeFlowReferenceExpressionNode | undefined,
        callName: string,
        logger: ConsoleInterface
    ) {
        return this._codeFlowEngine.printControlFlowGraph(flowNode, reference, callName, logger);
    }
}
